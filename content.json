{"meta":{"title":"鴻塵","subtitle":"","description":"鴻塵的博客","author":"鴻塵","url":"https://hwame.top","root":"/"},"pages":[{"title":"","date":"2023-08-19T16:35:16.947Z","updated":"2022-02-12T19:27:26.000Z","comments":true,"path":"baidu_verify_code-CzL5NY2WH2.html","permalink":"https://hwame.top/baidu_verify_code-CzL5NY2WH2.html","excerpt":"","text":"8369f22f23b7c87aaa52628d39d9a7ea"},{"title":"","date":"2023-08-19T16:35:16.964Z","updated":"2022-02-12T19:03:46.000Z","comments":true,"path":"google73552bba660504fd.html","permalink":"https://hwame.top/google73552bba660504fd.html","excerpt":"","text":"google-site-verification: google73552bba660504fd.html"},{"title":"相册","date":"2020-09-27T03:25:35.000Z","updated":"2020-10-24T05:36:02.000Z","comments":true,"path":"gallery/index.html","permalink":"https://hwame.top/gallery/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-08-21T03:31:23.000Z","updated":"2020-08-21T06:16:52.000Z","comments":false,"path":"categories/index.html","permalink":"https://hwame.top/categories/index.html","excerpt":"","text":""},{"title":"资源","date":"2020-08-21T03:31:57.000Z","updated":"2020-12-11T12:20:20.000Z","comments":true,"path":"repository/index.html","permalink":"https://hwame.top/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-08-21T03:21:11.000Z","updated":"2022-02-15T11:46:12.000Z","comments":true,"path":"links/index.html","permalink":"https://hwame.top/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-08-21T03:15:44.000Z","updated":"2020-08-21T06:13:12.000Z","comments":false,"path":"tags/index.html","permalink":"https://hwame.top/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-05-24T07:57:00.000Z","updated":"2023-12-16T17:57:14.215Z","comments":false,"path":"about/index.html","permalink":"https://hwame.top/about/index.html","excerpt":"","text":"点击「🐱‍🐉小恐龙🐱‍🐉」玩一会小恐龙快跑吧，按空格(space)/上(↑)/下(↓)/左(←)/右(→)键试试 游戏源码来自Chromium，本页面源码参考https://gitee.com/tczmh/dino 点击这个神奇的按钮👉📧吐槽一下📧👈"},{"title":"","date":"2023-12-16T17:56:43.405Z","updated":"2023-12-16T17:56:20.406Z","comments":true,"path":"dino.html","permalink":"https://hwame.top/dino.html","excerpt":"","text":"chrome小恐龙dinobody,html{padding:0;margin:0;width:100%;height:100%}.icon{-webkit-user-select:none;user-select:none;display:inline-block}.icon-offline{content:-webkit-image-set( url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABIAQMAAABvIyEEAAAABlBMVEUAAABTU1OoaSf/AAAAAXRSTlMAQObYZgAAAGxJREFUeF7tyMEJwkAQRuFf5ipMKxYQiJ3Z2nSwrWwBA0+DQZcdxEOueaePp9+dQZFB7GpUcURSVU66yVNFj6LFICatThZB6r/ko/pbRpUgilY0Cbw5sNmb9txGXUKyuH7eV25x39DtJXUNPQGJtWFV+BT/QAAAAABJRU5ErkJggg==\") 1x,url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAACQBAMAAAAVaP+LAAAAGFBMVEUAAABTU1NNTU1TU1NPT09SUlJSUlJTU1O8B7DEAAAAB3RSTlMAoArVKvVgBuEdKgAAAJ1JREFUeF7t1TEOwyAMQNG0Q6/UE+RMXD9d/tC6womIFSL9P+MnAYOXeTIzMzMzMzMzaz8J9Ri6HoITmuHXhISE8nEh9yxDh55aCEUoTGbbQwjqHwIkRAEiIaG0+0AA9VBMaE89Rogeoww936MQrWdBr4GN/z0IAdQ6nQ/FIpRXDwHcA+JIJcQowQAlFUA0MfQpXLlVQfkzR4igS6ENjknm/wiaGhsAAAAASUVORK5CYII=\") 2x);position:relative}.hidden{display:none}.offline .interstitial-wrapper{color:#2b2b2b;font-size:1em;line-height:1.55;margin:0 auto;max-width:600px;padding-top:100px;width:100%}.offline .runner-container{height:150px;max-width:600px;overflow:hidden;position:absolute;top:35px;width:44px}.offline .runner-canvas{height:150px;max-width:600px;opacity:1;overflow:hidden;position:absolute;top:0;z-index:2}.offline .controller{background:rgba(247,247,247,.1);height:100vh;left:0;position:absolute;top:0;width:100vw;z-index:1}#offline-resources{display:none}@media (max-width:420px){.suggested-left>#control-buttons,.suggested-right>#control-buttons{float:none}.snackbar{left:0;bottom:0;width:100%;border-radius:0}}@media (max-height:350px){h1{margin:0 0 15px}.icon-offline{margin:0 0 10px}.interstitial-wrapper{margin-top:5%}.nav-wrapper{margin-top:30px}}@media (min-width:600px) and (max-width:736px) and (orientation:landscape){.offline .interstitial-wrapper{margin-left:0;margin-right:0}}@media (min-width:420px) and (max-width:736px) and (min-height:240px) and (max-height:420px) and (orientation:landscape){.interstitial-wrapper{margin-bottom:100px}}@media (min-height:240px) and (orientation:landscape){.offline .interstitial-wrapper{margin-bottom:90px}.icon-offline{margin-bottom:20px}}@media (max-height:320px) and (orientation:landscape){.icon-offline{margin-bottom:0}.offline .runner-container{top:10px}}@media (max-width:240px){.interstitial-wrapper{overflow:inherit;padding:0 8px}}eval(function(i,a,e,o,t,c){if(t=function(i){return(i"}],"posts":[{"title":"Go语言中的通道","slug":"channel-and-goroutine-in-go","date":"2022-03-27T11:06:16.000Z","updated":"2022-03-27T12:00:41.000Z","comments":true,"path":"20220327/channel-and-goroutine-in-go.html","link":"","permalink":"https://hwame.top/20220327/channel-and-goroutine-in-go.html","excerpt":"摘要：看完这篇，Go语言的通道及Goroutine你就都会了…","text":"摘要：看完这篇，Go语言的通道及Goroutine你就都会了… 文章说明文章作者：鴻塵文章链接：https://hwame.top/20220327/channel-and-goroutine-in-go.html原文链接：https://mp.weixin.qq.com/s/-N1qUEE090wMpI6TWmFTWg参考资料： 看完这篇，Go语言的通道及Goroutine你就都会了 Go语言七篇入门教程四：通道及Goroutine 深入学习 Go 并发编程之通道 1.前言在go社区有这样一句话：不要通过共享内存来通信，而是通过通信来共享内存。 go官方是建议使用管道通信的方式来进行并发。 通道 是用于协程间交流的通信载体。严格地来说，通道就是数据传输的管道，数据通过这根管道被 “传入” 或被 “读出”。 因此协程可以发送数据到通道中，而另一个协程可以从该通道中读取数据。 在这里就要引入一个新名词： 协程将线程再细分为多个协程，比如说是一条流水线上的多人协作。那么就可以减少各个线程内部的等待时间。 2.通道简介Go 提供一个 chan 关键词去创建一个通道。一个通道只能传入一种类型的数据，其他的数据类型不允许被传输。 将线程再分成更细的协程，使得中间等待时候更少，提高效率！ 2.1.声明12345678910package mainimport &quot;fmt&quot;func main() &#123; var channel chan int //声明了一个可以传入 int 类型数据的通道 channel 。 fmt.Println(channel) //程序会打印nil, 因为通道的 0 值是 nil。&#125; 一个 nil 通道是没有用的。你不能向它传递数据或者读取数据。因此，我们必须使用 make 函数器创建一个可以使用的通道。 12345678910package mainimport &quot;fmt&quot;func main()&#123; channel := make(chan int) //声明了一个可以传入 int 类型数据的通道 channel 。 fmt.Println(channel) //程序会打印channel的地址。 0xc0000180c0&#125; 它是一个指针内存地址。通道变量默认是一个指针。多数情况下，当你想要和一个协程沟通的时候，你可以给函数或者方法传递一个通道作为参数。当从协程接收到通道参数后，你不需要再对其进行解引用就可以从通道接收或者发送数据。 2.2.读写Go 语言提供一个非常简洁的左箭头语法 &lt;- 去从通道读写数据。有变量接受管道值1channel &lt;- data 上面的代码意味着我们想要把 data 数据推入到通道 channel 中，注意看箭头的指向。 它表明是从 data数据 to到 通道 channel。因此我们可以当作我们正在把 data 推入到通道 channel。无变量接受管道值1&lt;- data 这个语句不会把数据传输给任何变量，但是仍然是一个有效的语句。 上面的通道操作默认是阻塞的。在以前的课程中，我们知道可以使用 time.Sleep 去阻塞一个通道。通道操作本质上是阻塞的。当一些数据被写入通道，对应的协程将阻塞直到有其他的协程可以从此通道接收数据。 通道操作会通知调度器去调度其他的协程，这就是为什么程序不会一直阻塞在一个协程。通道的这些特性在不同的协程沟通的时候非常有用，它避免了我们使用锁或者一些 hack 手段去达到阻塞协程的目的。 2.3.通道详解2.3.1.例子123456789101112131415161718192021222324252627282930313233343536package mainimport &quot;fmt&quot;func Rush(c chan string) &#123; fmt.Println(&quot;Hello &quot;+ &lt;-c + &quot;!&quot;) // 声明一个函数 greet, 这个函数的参数 c 是一个 string 类型的通道。 // 在这个函数中，我们从通道 c 中接收数据并打印到控制台上。&#125;func main()&#123; fmt.Println(&quot;Main Start&quot;) // main 函数的第一个语句是打印 main start 到控制台。 channel := make(chan string) // 在 main 函数中使用 make 函数创建一个 string 类型的通道赋值给 ‘ channel &#x27; 变量 go Rush(channel) // 把 channel 通道传递给 greet 函数并用 go 关键词以协程方式运行它。 // 此时，程序有两个协程并且正在调度运行的是 main goroutine 主函数 channel &lt;- &quot;DEMO&quot; // 给通道 channel 传入一个数据 DEMO. // 此时主线程将阻塞直到有协程接收这个数据. Go 的调度器开始调度 greet 协程接收通道 channel 的数据 fmt.Println(&quot;Main Stop&quot;) // 然后主线程激活并且执行后面的语句，打印 main stopped&#125;/*Main StartHello DEMO!Main Stop*/ 2.3.2.死锁 当通道读写数据时，所在协程会阻塞并且调度控制权会转移到其他未阻塞的协程。如果当前协程正在从一个没有任何值的通道中读取数据，那么当前协程会阻塞并且等待其他协程往此通道写入值。 因此，读操作将被阻塞。类似的，如果你发送数据到一个通道，它将阻塞当前协程直到有其他协程从通道中读取数据。此时写操作将阻塞 。 下面是一个主线程在进行通道操作的时候造成死锁的例子123456789101112131415161718192021222324package mainimport &quot;fmt&quot;func main() &#123; fmt.Println(&quot;main start&quot;) // main 函数的第一个语句是打印 main start 到控制台。 channel := make(chan string) // 在 main 函数中使用 make 函数创建一个 string 类型的通道赋值给 ‘ channel &#x27; 变量 channel &lt;- &quot;GoLang&quot; // 给通道 channel 传入一个数据 DEMO. // 此时主线程将阻塞直到有协程接收这个数据. Go 的调度器开始调度协程接收通道 channel 的数据 // 但是由于没有协程接受，没有协程是可被调度的。所有协程都进入休眠状态，即是主程序阻塞了。 fmt.Println(&quot;main stop&quot;)&#125;/*报错main startfatal error: all goroutines are asleep - deadlock! //所有协程都进入休眠状态,死锁goroutine 1 [chan send]:main.main()*/ 2.3.3.关闭通道123456789101112131415161718192021222324252627282930313233343536package mainimport &quot;fmt&quot;func RushChan(c chan string) &#123; &lt;- c fmt.Println(&quot;1&quot;) &lt;- c fmt.Println(&quot;2&quot;)&#125;func main() &#123; fmt.Println(&quot;main start&quot;) c := make(chan string, 1) go RushChan(c) c &lt;- &quot;Demo1&quot; close(c) /* 不能向一个关了的channel发信息 main start panic: send on closed channel */ c &lt;- &quot;Demo2&quot; //close(c) /* close 放这里的话可以 main start 1 2 Main Stop */ fmt.Println(&quot;Main Stop&quot;)&#125; 第一个操作 c &lt;- &quot;Demo2&quot; 将阻塞协程直到有其他协程从此通道中读取数据，因此 greet 会被调度器调度执行。第一个操作 &lt;-c 是非阻塞的 因为现在通道 c 有数据可读。第二个操作 &lt;-c 将被阻塞因为通道 c 已经没数据可读.此时 main 协程将被激活并且程序执行 close(c) 关闭通道操作。 2.3.4.缓冲区1c := make(chan Type, n) 当缓冲区参数不是 0 的时候。协程将不会阻塞除非缓冲区被填满。 当缓冲区满了之后，想要再往缓冲区发送数据只有等到有其他协程从缓冲区接收数据， 此时的发送协程是阻塞的。 有一点需要注意， 读缓冲区的操作是渴望式读取，意味着一旦读操作开始它将读取缓冲区所有数据，直到缓冲区为空。 原理上来说读操作的协程将不会阻塞直到缓冲区为空。12345678910111213141516171819202122232425262728293031323334package mainimport &quot;fmt&quot;func RushChan(c chan string) &#123; for &#123; val ,_ := &lt;-c fmt.Println(val) &#125;&#125;func main() &#123; fmt.Println(&quot;Main Start&quot;) c := make(chan string, 1) go RushChan(c) c &lt;- &quot;Demo1&quot; //结果1 //c &lt;- &quot;Demo2&quot; //结果2 fmt.Println(&quot;Main Stop&quot;)&#125;/*结果1：Main StartMain Stop*//*结果2：Main StartJoinMikeMain Stop*/ 由于这是一个缓冲的通道，当我只有 c &lt;- Demo1 的时候，这里面只是满了，但是是不会阻塞的。所以子协程接受到了这个数据 Demo1 ，但是由于是非阻塞，所以主线程没有被阻塞，并没有等子协程完成就结束了，结果1就是这样出现了。 当加多一个 c &lt;- Demo2 的时候，这时就要等缓冲区空了，也就是等有协程把 Demo1 读取，所以就会导致主线程阻塞，此时的结果就是结果2了。12345678910111213141516171819package mainimport &quot;fmt&quot;func RushChan(c chan string) &#123; for &#123; val ,_ := &lt;-c fmt.Println(val) &#125;&#125;func main() &#123; c := make(chan int,3) c &lt;- 1 c &lt;- 2 c &lt;- 3 close(c) for elem := range c &#123; fmt.Println(elem) &#125;&#125; 这里虽然关闭了通道，但是其实数据不仅在通道里面，数据还在缓冲区中的，我们依然可以读取到这个数据。 2.3.5.通道的长度和容量和切片类似，一个缓冲通道也有长度和容量。通道的长度是其内部缓冲队列未读的数据量，而通道的容量是缓冲区可最大盛放的数据量。 我们可以使用 len 函数去计算通道的长度，使用 cap 函数去获得通道的容量。和切片用法神似123456789101112131415161718192021222324252627282930package mainimport &quot;fmt&quot;func RushChan(c chan string) &#123; for &#123; val ,_ := &lt;-c fmt.Println(val) &#125;&#125;func main() &#123; c := make(chan int,3) c &lt;- 1 c &lt;- 2 fmt.Println(&quot;长度： &quot;,len(c)) fmt.Println(&lt;-c) fmt.Println(&quot;长度： &quot;,len(c)) fmt.Println(&lt;-c) fmt.Println(&quot;长度： &quot;,len(c)) fmt.Println(&quot;容量： &quot;,cap(c))&#125;/*结果：长度： 21长度： 12长度： 0容量： 3*/ 这个 c 通道容量为 3，但只盛放了 2 个数据。Go 就不用去阻塞主线程去调度其他协程。你也可以在主线程中去读取这些数据，因为虽然通道没有放满，也不会阻止你去从通道读取数据。 2.3.6.单向通道目前为止，我们已经学习到可以双向传递数据的通道，或者说，我们可以对通道做读操作和写操作。但是事实上我们也可以创建单向通道。比如只读通道只允许读操作，只写通道只允许写操作。单向通道也可以使用 make 函数创建，不过需要额外加一个箭头语法。12roc := make(&lt;-chan int)soc := make(chan&lt;- int) 在上面的程序中， roc 是一个只读通道，&lt;- 在 chan 关键词前面。 soc is 只写通道，&lt;- 在 chan 关键词后面。 他们也算不同的数据类型。 但是单向通道有什么作用呢 ?使用单向通道可以 提高程序的类型安全性， 使得程序不容易出错。 但是假如你在一个协程中只需要读操作某通道，但是在主线程中却需要读写操作这个通道该怎么办呢？ 幸运的是 Go 提供了一个简单的语法去把双向通道转化为单向通道。123456789101112131415161718192021package mainimport &quot;fmt&quot;func greet(roc &lt;-chan string) &#123; fmt.Println(&quot;Hello &quot; + &lt;-roc ,&quot;!&quot;)&#125;func main() &#123; fmt.Println(&quot;Main Start&quot;) c := make(chan string) go greet(c) c &lt;- &quot;Demo&quot; fmt.Println(&quot;Main Stop&quot;)&#125;/*结果Main StartHello Demo !Main Stop*/ 我们修改 greet 协程函数，把参数 c 类型从双向通道改成单向接收通道。现在我们只能从通道中读取数据，通道上的任何写入操作将会发生错误： “invalid operation: roc &lt;- “Temp” (send to receive-only type &lt;-chan string)”. 2.3.7.Selectselect 和 switch 很像，它不需要输入参数，并且仅仅被使用在通道操作上。Select 语句被用来执行多个通道操作的一个和其附带的 case 块代码。 原理 让我们来看下面的例子，讨论下其执行原理1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( &quot;fmt&quot; &quot;time&quot;)var start time.Timefunc init() &#123; start = time.Now()&#125;func service1(c chan string) &#123; time.Sleep(3 * time.Second) c &lt;- &quot;Hello from service 1&quot;&#125;func service2(c chan string) &#123; time.Sleep(5 * time.Second) c &lt;- &quot;Hello from service 2&quot;&#125;func main() &#123; fmt.Println(&quot;main start&quot;, time.Since(start)) chan1 := make(chan string) chan2 := make(chan string) go service1(chan1) go service2(chan2) select &#123; case res := &lt;-chan1: fmt.Println(&quot;Response form service 1&quot;, res, time.Since(start)) case res := &lt;-chan2: fmt.Println(&quot;Response form service 2&quot;, res, time.Since(start)) &#125; fmt.Println(&quot;main stop &quot;,time.Since(start))&#125;/*结果：main start 0sResponse form service 1 Hello from service 1 3.0018445smain stop 3.0019815s*/ 从上面的程序来看，我们知道 select 语句和 switch 很像，不同点是用通道读写操作代替了布尔操作。通道将被阻塞，除非它有默认的 default 块 (之后将介绍)。一旦某个 case 条件执行，它将不阻塞。 所以一个 case 条件什么时候执行呢 ? 如果所有的 case 语句（通道操作）被阻塞，那么 select 语句将阻塞直到这些 case 条件的一个不阻塞（通道操作），case 块执行。如果有多个 case 块（通道操作）都没有阻塞，那么运行时将随机选择一个不阻塞的 case 块立即执行。 为了演示上面的程序，我们开启两个协程并传入对应的通道变量。然后我们写一个带有两个 case 操作的 select 语句。 一个 case 操作从 chan1 读数据，另外一个从 chan2 读数据。这两个通道都是无缓冲的 , 读操作将被阻塞 。所以 select 语句将阻塞。因此 select 将等待，直到有 case 语句不阻塞。 当程序执行到select语句后，主线程将阻塞并开始调度 service1 和service2协程。 service1 休眠 3 秒 后未阻塞的把数据写入通道 chan1 与其类似，service2等待 5 秒 后未阻塞的把数据写入通道chan2 因为 service1 比 service2 早一步执行完毕，case 1 将首先调度执行，其他的 cases 块 (这里指 case 2) 将被忽略。 一旦 case 块执行完毕， main 线程将开始继续执行。 所以并没有输出case2的结果 上述程序真实模拟了一个数百万请求的服务器负载均衡的例子，它从多个有效服务中返回其中一个响应。使用协程，通道和 select 语句，我们可以向多个服务器请求数据并获取其中最快响应的那个。 为了模拟上面哪个 case 块率先返回数据，我们可以直接去掉 Sleep 函数调用。 1234567891011121314151617181920212223242526272829303132333435package mainimport ( &quot;fmt&quot; &quot;time&quot;)var start time.Timefunc init() &#123; start = time.Now()&#125;func service1(c chan string) &#123; c &lt;- &quot;Hello from service 1&quot;&#125;func service2(c chan string) &#123; c &lt;- &quot;Hello from service 2&quot;&#125;func main() &#123; fmt.Println(&quot;main start&quot;, time.Since(start)) chan1 := make(chan string) chan2 := make(chan string) go service1(chan1) go service2(chan2) select &#123; case res := &lt;-chan1: fmt.Println(&quot;Response form service 1&quot;, res, time.Since(start)) case res := &lt;-chan2: fmt.Println(&quot;Response form service 2&quot;, res, time.Since(start)) &#125; fmt.Println(&quot;main stop &quot;,time.Since(start))&#125; 结果一：main start 0sResponse form service 1 Hello from service 1 539.3µsmain stop 539.3µs结果二：main start 0sResponse form service 2 Hello from service 2 0smain stop 0s 结果一共有2个不同的结果 为了证明当所有 case 块都是非阻塞的时候，golang 会随机选择一个代码块执行打印 response，我们使用缓冲通道来改造程序。 1234567891011121314151617181920212223242526272829303132package mainimport ( &quot;fmt&quot; &quot;time&quot;)var start time.Timefunc init() &#123; start = time.Now()&#125;func service1(c chan string) &#123; c &lt;- &quot;Hello from service 1&quot;&#125;func service2(c chan string) &#123; c &lt;- &quot;Hello from service 2&quot;&#125;func main() &#123; fmt.Println(&quot;main start&quot;, time.Since(start)) chan1 := make(chan string,2) chan2 := make(chan string,2) chan1 &lt;- &quot;Value 1&quot; chan1 &lt;- &quot;Value 2&quot; chan2 &lt;- &quot;Value 1&quot; chan2 &lt;- &quot;Value 2&quot; select &#123; case res := &lt;-chan1: fmt.Println(&quot;Response form service 1&quot;, res, time.Since(start)) case res := &lt;-chan2: fmt.Println(&quot;Response form service 2&quot;, res, time.Since(start)) &#125; fmt.Println(&quot;main stop &quot;,time.Since(start))&#125; 上述的程序的结果是有不同的 结果一：main start 0sResponse form service 1 Value 1 496.2µsmain stop 496.2µs结果二：main start 0sResponse form service 2 Value 1 0smain stop 0s 在上面的程序中，两个通道在其缓冲区中都有两个值。因为我们向容量为 2 的缓冲区通道分别发送了两个值，所以这些通道发送操作不会阻塞并且会执行下面的 select 块。 select 块中的所有 case 操作都不会阻塞，因为每个通道中都有两个值，而我们的 case 操作只需要取出其中一个值。因此，go 运行时会随机选择一个 case 操作并执行其中的代码。 2.3.8.default case 块像 switch 一样， select 语句也有 default case 块。default case 块 是非阻塞的，不仅如此， default case 块可以使 select 语句永不阻塞，这意味着， 任何通道的 发送 和 接收 操作 (不管是缓冲或者非缓冲) 都不会阻塞当前线程。 如果有 case块的通道操作是非阻塞，那么 select会执行其case 块。如果没有那么 select将默认执行 default块. 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( &quot;fmt&quot; &quot;time&quot;)var start time.Timefunc init() &#123; start = time.Now()&#125;func service1(c chan string) &#123; c &lt;- &quot;Hello from service 1&quot;&#125;func service2(c chan string) &#123; c &lt;- &quot;Hello from service 2&quot;&#125;func main() &#123; fmt.Println(&quot;main start&quot;, time.Since(start)) chan1 := make(chan string) chan2 := make(chan string) go service1(chan1) go service2(chan2) select &#123; case res := &lt;-chan1: fmt.Println(&quot;Response form service 1&quot;, res, time.Since(start)) case res := &lt;-chan2: fmt.Println(&quot;Response form service 2&quot;, res, time.Since(start)) default: fmt.Println(&quot;No Response received&quot;,time.Since(start)) &#125; fmt.Println(&quot;main stop &quot;,time.Since(start))&#125;/*结果：main start 0sNo Response received 0smain stop 0s*/ 在上面的程序中，因为通道是非缓冲的，case 块的通道操作都是阻塞的，所有 default 块将被执行。 如果上面的 select 语句没有 default 块，select 将阻塞，没有 response 会被打印出来，知道通道变成非阻塞。 如果带有 default, select 将是非阻塞的，调度器将不会从主线程转而调度其他协程。 但是我们可以使用 time.Sleep 改变这一点。 通过这种方式，主线程将把调度权转移到其他协程，在其他协程执行完毕后，调度权从新回到主线程手里。 当主线程重新执行的时候，通道里面已经有值了，case 操作将不会阻塞。 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( &quot;fmt&quot; &quot;time&quot;)var start time.Timefunc init() &#123; start = time.Now()&#125;func service1(c chan string) &#123; fmt.Println(&quot;service1 start&quot;) c &lt;- &quot;Hello from service 1&quot;&#125;func service2(c chan string) &#123; fmt.Println(&quot;service2 start&quot;) c &lt;- &quot;Hello from service 2&quot;&#125;func main() &#123; fmt.Println(&quot;main start&quot;, time.Since(start)) chan1 := make(chan string) chan2 := make(chan string) go service1(chan1) go service2(chan2) time.Sleep(3*time.Second) select &#123; case res := &lt;-chan1: fmt.Println(&quot;Response form service 1&quot;, res, time.Since(start)) case res := &lt;-chan2: fmt.Println(&quot;Response form service 2&quot;, res, time.Since(start)) default: fmt.Println(&quot;No Response received&quot;,time.Since(start)) &#125; fmt.Println(&quot;main stop &quot;,time.Since(start))&#125;/*结果不唯一。main start 0sservice2 startservice1 startResponse form service 1 Hello from service 1 3.0006729smain stop 3.0006729s*/ 2.3.9.空 select和 for&#123;&#125; 这样的空循环很像，空 select&#123;&#125; 语法也是有效的。但是有一点必须要说明。我们知道 select 将被阻塞除非有 case 块没有阻塞。因为 select&#123;&#125; 没有 case 非阻塞语句，主线程将阻塞并可能会导致死锁。 123456789101112131415161718package mainimport &quot;fmt&quot;func service() &#123; fmt.Println(&quot;Hello from service&quot;)&#125;func main() &#123; fmt.Println(&quot;main started&quot;) go service() select &#123;&#125; fmt.Println(&quot;main stop&quot;)&#125;/*结果main startedHello from servicefatal error: all goroutines are asleep - deadlock!goroutine 1 [select (no cases)]:*/ 在上面的程序中我们知道 select 将阻塞 main 线程，调度器将会调度 service 这个协程。在 service 执行完毕后，调度器会再去调度其他可用的协程，但是此时已经没有可用的协程，主线程也正在阻塞，所以最后的结果就是发生死锁. 2.3.10.Deadlockdefault 块在通道操作阻塞的时候是非常有用的，他可以避免死锁。 同时由于 default块的非阻塞特性，Go 可以避免在其他协程阻塞的时候去调度其他协程，从而避免死锁。通道的发送操作也类似，， default 可以在其他协程不能被调度的时候被执行，从而避免死锁。 2.3.11.nil通道2.4.多协程协同工作写两个协程，一个用来计算数字的平方，另一个用来计算数字的立方。1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport &quot;fmt&quot;func square(c chan int) &#123; fmt.Println(&quot;[square] reading&quot;) num := &lt;-c c &lt;- num * num&#125;func cube(c chan int) &#123; fmt.Println(&quot;[cube] reading&quot;) num := &lt;-c c &lt;- num * num * num&#125;func main() &#123; fmt.Println(&quot;[main] main started&quot;) squareChan := make(chan int) cubeChan := make(chan int) go square(squareChan) go cube(cubeChan) testNum := 3 fmt.Println(&quot;[main] send testNum to squareChan&quot;) squareChan &lt;- testNum fmt.Println(&quot;[main] resuming&quot;) fmt.Println(&quot;[main] send testNum to cubeChane&quot;) cubeChan &lt;- testNum fmt.Println(&quot;[main] resuming&quot;) fmt.Println(&quot;[main] reading from channels&quot;) squareVal,cubeVal := &lt;-squareChan, &lt;-cubeChan sum := squareVal + cubeVal fmt.Println(&quot;[main] sum of square and cube of&quot;,testNum,&quot; is&quot;,sum) fmt.Println(&quot;[main] main stop&quot;)&#125;/*结果：[main] main started[main] send testNum to squareChan[cube] reading[square] reading[main] resuming[main] send testNum to cubeChane[main] resuming[main] reading from channels[main] sum of square and cube of 3 is 36[main] main stop*/ 流程： 创建两个函数 square 和 cube 作为协程运行。 两个函数都有一个 int 类型通道参数c，从 c 中读取数据到变量num，最后把计算的数据再写入到通道 c 中。 在主线程中使用 make函数创建两个 int类型通道 squareChan and cubeChan然后分别运行square和cube 协程。因为调度权还在主线程，所以执行testNumb 赋值为 3。 然后我们把数据放入通道 squareChan 。主线程将阻塞直到通道的数据被读取。 一旦通道的数据被读取，主线程将继续执行。 在主线程中我们试图从这两个通道中读取数据，此时线程可能阻塞直到有数据写入到通道。这里我们使用:=语法来接收多个通道的值。 一旦这些协程把数据写入到通道，主线程将阻塞。当数据被写入通道中，主线程将继续执行，最后我们计算出数字的总和并打印到控制台。 2.5.WaitGroup有一种业务场景是你需要知道所有的协程是否已执行完成他们的任务。这个和只需要随机选择一个条件为true 的 select 不同，他需要你满足所有的条件都是 true 才可以激活主线程继续执行。 这里的条件指的是非阻塞的通道操作。 2.5.1.简介WaitGroup 是一个带着计数器的结构体，这个计数器可以追踪到有多少协程创建，有多少协程完成了其工作。当计数器为 0 的时候说明所有协程都完成了其工作。 1234567891011121314151617181920212223242526272829package mainimport ( &quot;fmt&quot; &quot;sync&quot; &quot;time&quot;)func service(wg *sync.WaitGroup, instance int) &#123; time.Sleep(2 * time.Second) fmt.Println(&quot;Service called on instance&quot;,instance) wg.Done() //协程数-1&#125;func main() &#123; fmt.Println(&quot;main started&quot;) var wg sync.WaitGroup for i:=1;i&lt;= 3; i++&#123; wg.Add(1) go service(&amp;wg,i) &#125; wg.Wait()//阻塞 fmt.Println(&quot;main stop&quot;)&#125;/*结果：(结果是不唯一的，一共有3!次可能的结果)main startedService called on instance 2Service called on instance 1Service called on instance 3main stop*/ 在上面的程序中，我们创建了一个sync.WaitGroup 类型的空结构体 (带着 0 值字段) wg 。 WaitGroup 结构体有一些像 noCopy, state1 和 sema 这样的内部字段。 这个结构体也有三个公开方法： Add, Wait 和 Done. Add 方法的参数是一个变量名叫 delta 的int 类型参数，主要用来内部计数。 内部计数器默认值为 0. 它用于记录多少个协程在运行。 当 WaitGroup创建后，计数器值为 0，我们可以通过给 Add方法传 int类型值来增加它的数量。 记住， 当协程建立后，计数器的值不会自动递增 ，因此需要我们手动递增它。 Wait 方法用来阻塞当前协程。一旦计数器为 0, 协程将恢复运行。 因此，我们需要一个方法去降低计数器的值。Done 方法可以降低计数器的值。他不接受任何参数，因此，它每执行一次计数器就减 1。 上面的例子中，我们在创建 wg 变量后，运行了三次 for 循环，每次运行的时候我们创建一个协程并给计数器加 1。 这意味着现在我们有三个协程在等待运行并且 WaitGroup 的计数器值为 3。注意我们传给协程函数的是一个指针，这是因为一旦在协程内部工作完成后，我们需要通过调用Done方法去降低计数器的值。 如果 wg 通过值复制方式传过去， 因为传递的是一个拷贝，主线程中的 wg将不会得到修改。 在 for 循环执行完成后，我们通过调用 wg.Wait()去阻塞当前主线程，并把调度权让给其他协程，直到计数器值为 0 之后，主线程才会被再次调度。 我们在另外三个协程中通过Done方法把计数器值降为 0，此时主线程将再次被调度并开始执行之后的代码。 2.5.2.工作池顾名思义，一个工作池并发执行某项工作的协程集合。 在上面，我们已经用到的多个协程执行一个任务，但是他们并没有执行特定的工作，只是 sleep 了一下。 如果你向协程中传一个通道，他们可以去完成一些工作，变成一个工作池。 所以工作池其实就是维护了多个工作协程，这些协程的功能是可以收到任务，执行任务并返回结果。他们完成任务后我们就可以收到结果。这些协程使用相同的通道来达到自己的目的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445package mainimport ( &quot;fmt&quot; &quot;time&quot;)func sqrWorker(tasks &lt;-chan int, results chan &lt;-int, instance int) &#123; for num := range tasks &#123; time.Sleep(time.Millisecond) //阻塞 fmt.Printf(&quot;[worker %v ] Sending result by worker %v \\n&quot;,instance,instance) results &lt;- num*num &#125;&#125;func main() &#123; fmt.Println(&quot;main started&quot;) tasks := make(chan int,10) results := make(chan int,10) for i:=0;i&lt;3;i++&#123; go sqrWorker(tasks,results,i) &#125; for i := 0; i &lt; 5; i++ &#123; tasks &lt;- i*2 &#125; fmt.Println(&quot;[main] write 5 tasks&quot;) close(tasks) for i := 0; i &lt; 5; i++ &#123; result := &lt;-results fmt.Println(&quot;[main] Result&quot; , i , &quot;:&quot;, result) &#125; fmt.Println(&quot;main stop&quot;)&#125;/*//结果之一[main] write 5 tasks[worker 0 ] Sending result by worker 0 [worker 1 ] Sending result by worker 1 [worker 2 ] Sending result by worker 2 [main] Result 0 : 4[main] Result 1 : 16[main] Result 2 : 0[worker 1 ] Sending result by worker 1 [main] Result 3 : 64[worker 0 ] Sending result by worker 0 [main] Result 4 : 36main stop*/ sqrWorker 是一个带有 tasks 通道，results 通道 和 id 三个参数的协程函数。这个协程函数的任务是把从 tasks 通道接收到的数字的平方发送到 results通道。 在主函数中，我们创建了两个带缓冲区，容量为 10 的通道tasks and result。因此在缓冲区被充满之前，任何操作都是非阻塞的。所以有时候设置一个大点的缓冲区是个好办法。 然后我们循环创建多个 sqrWorker 协程，并传入 tasks 通道， results 通道 和 id 三个参数，用来传递和获取协程执行前后的数据。 接着我们向 tasks 非阻塞通道放入 5 个任务数据。 因为我们已经向任务通道放入的数据，所以我们可以关闭它，虽然这个操作不是必须的，但是如果以后运行中出现错误的话可以防止通道 range 带来的死锁问题。 然后我们开启循环 5 次从 results 通道接收数据，因为目前通道缓冲区没有数据，所以通道读取操作造成主线程阻塞，调度器将调度工作池的协程，直到有数据添加到 results通道。 当前我们有 3 个work 协程在工作，我们使用了 sleep 操作来模拟阻塞操作，所以调度器在某一个阻塞的时候会去调用其他的 work 协程，当某个 work 协程 sleep 完成后会把计算数字的平方的结果数据放入 results 缓冲无阻塞通道。 当 3 个协程依次交替把 task 通道的任务都完成后，for range 循环将完成，并且因为之前我们已经关闭了任务通道，所以协程也不会发生死锁。调度器将继续返回调度主线程。 有时候所有的工作协程可能都在阻塞，此时调度器将去调度主线程，直到 results 通道再次为空。 当所有 work 协程都完成任务退出后，主线程将继续拿到调度权并打印 results 通道剩下的数据，继续之后代码的执行。 2.5.3.Mutex互斥是 Go 中一个简单的概念。在我解释它之前，先要明白什么是竞态条件。 goroutines 都有自己的独立的调用栈，因此他们之间不分享任何数据。但是有一种情况是数据存放在堆上，并且被多个 goroutines 使用。 多个 goroutines 试图去操作一个内存区域的数据会造成意想不到的后果. 12345678910111213141516171819202122232425package mainimport ( &quot;fmt&quot; &quot;sync&quot;)var i intfunc worker(wg *sync.WaitGroup) &#123; i = i+1 wg.Done()&#125;func main() &#123; fmt.Println(&quot;main started&quot;) var wg sync.WaitGroup for i:=0;i&lt;1000;i++&#123; wg.Add(1) go worker(&amp;wg) &#125; wg.Wait() fmt.Println(&quot;main stop&quot;,i)&#125;/*结果是不同的！！main startedmain stop 985*/ i = i + 1 这个计算有 3 步(1) 得到 i 的值(2) 给 i 的值加 1(3) 更新 i 的值 这里发生很多事情，因为go是协程，这三步里面不一定都是同时顺序执行的。有可能A是顺利执行，使得i=2，但是B是读取的是A没更新的之前的i也就是1，所以就是结果会小于等于1000的， 除非一个协程阻塞，否则其他协程是没有机会获得调度的。那么 i = i + 1 也没有阻塞，为什么 Go 的调度器会去调度其他协程呢？ 在任何情况下，都不应该依赖 Go 的调度算法，而应该实现自己的逻辑来同步不同的 goroutine. 实现方法之一就是使用我们上面提到的互斥锁。互斥锁是一个编程概念，它保证了在同一时间只能有一个线程或者协程去操作同一个数据。当一个协程想要操作数据的时候，必须获取该数据的一个锁，操作完成后必须释放锁，如果没有获取到该数据的锁，那么就不能操作这个数据。 在 Go 中，互斥数据结构 ( map) 由 sync 包提供。在 Go 中，多协程去操作一个值都可能会引起竞态条件。我们需要在操作数据之前使用 mutex.Lock() 去锁定它，一旦我们完成操作，比如上面提到的 i = i + 1, 我们就可以使用 mutext.Unlock() 方法解锁。 如果在锁定的时候，有一个协程想要读写 i 的值，那么此协程将阻塞 直到前面的协程完成操作并解锁数据。因此在某一时刻有且仅有一个协程可以操作数据，从而避免竞态条件。记住，任何锁之间的变量在解锁之前对于其他协程都不是可用的。 让我们使用互斥锁修改上面的例子： 123456789101112131415161718192021222324252627package mainimport ( &quot;fmt&quot; &quot;sync&quot;)var i intfunc worker(wg *sync.WaitGroup,m *sync.Mutex) &#123; m.Lock() i = i+1 m.Unlock() wg.Done()&#125;func main() &#123; fmt.Println(&quot;main started&quot;) var wg sync.WaitGroup var m sync.Mutex for i:=0;i&lt;1000;i++&#123; wg.Add(1) go worker(&amp;wg,&amp;m) &#125; wg.Wait() fmt.Println(&quot;main stop&quot;,i)&#125;/*结果main startedmain stop 1000*/ 在上面的程序中，我们创建了一个互斥锁变量 m，并把它的指针传递给所有已创建的协程。在协程内部，当我们要开始操作 i变量的时候，我们先通过 m.Lock()获得锁，操作完成后我们使用 m.Unlock()释放锁。互斥锁可以帮助我们解决竞态条件。 但首要规则是避免 goroutine 之间共享资源。所以官方建议不要共享内存并发，而是通过管道通信的方式并发。 3.结语后部分go并发知识是参考作者summar的go并发以及书上的知识点，非常感谢作者的翻译工作，使得我能更好的理解go的channel并发机制！链接点这里channel 随着业务的不断扩大，并发能更好的发挥服务器的性能。","categories":[{"name":"Go","slug":"Go","permalink":"https://hwame.top/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://hwame.top/tags/Go/"}]},{"title":"Go语言什么时候使用指针","slug":"when-to-use-pointer-in-go","date":"2022-03-23T12:49:57.000Z","updated":"2022-03-23T15:48:45.000Z","comments":true,"path":"20220323/when-to-use-pointer-in-go.html","link":"","permalink":"https://hwame.top/20220323/when-to-use-pointer-in-go.html","excerpt":"","text":"img { display: inline !important; } 文章说明文章作者：鴻塵文章链接：https://hwame.top/20220323/when-to-use-pointer-in-go.html原文链接：https://mp.weixin.qq.com/s/FQ83qRBb985FHB-0ttIYCQ文章说明：文章使用Go程序将微信公众号文章转换为Markdown格式。参考资料： Go语言什么时候该使用指针？指针使用分析与讲解 Go语言什么时候该使用指针 Go语言什么时候该使用指针？指针使用分析与讲解 收录于话题#为什么要学Go语言 47个 什么是指针我们都知道，程序运行时的数据是存放在内存中的，每一个存储在内存中的数据都有一个编号，这个编号就是内存地址。我们可以根据这个内存地址来找到内存中存储的数据，而内存地址可以被赋值给一个指针。我们也可以简单的理解为指针就是内存地址。 指针的声明和定义在Go语言中，获取一个指针，直接使用取地址符&amp;就可以。示例：12345678910func main() &#123; name := &quot;Go语言圈&quot; nameP := &amp;name //取地址 fmt.Println(&quot;name变量值为：&quot;, name) fmt.Println(&quot;name变量的内存地址为：&quot;, nameP)&#125;//运行结果：//name变量值为：Go语言圈//name变量的内存地址为： 0xc00004e240 nameP 指针的类型是 *stringGo语言中，* 类型名表示一个对应的指针类型 从上面表格可以看到： 普通变量 name 的值是Go语言圈，存放在内存地址为 0xc00004e240 的内存中 指针变量 namep 的值是普通变量的内存地址 0xc00004e240 指针变量 nameP 的值存放在 内存地址为 0xc00004e360 的内存中 普通变量存的是数据，指针变量存的是数据的地址 var 关键字声明我们也可以使用 var 关键字声明12var nameP *stringnameP = &amp;name new 函数声明12nameP := new(string)nameP = &amp;name 可以传递类型给这个内置的 new 函数，它会返回对应的指针类型。 指针的操作这里强调一下：指针变量是一个变量，这个变量的值是指针（内存地址）！指针变量是一个变量，这个变量的值是指针（内存地址）！指针变量是一个变量，这个变量的值是指针（内存地址）！获取指针指向的值：只需要在指针变量前加 * 号即可获得指针变量值所对应的数据：123nameV := *namePfmt.Println(&quot;nameP指针指向的值为:&quot;, nameV)//nameP指针指向的值为: Go语言圈 修改指针指向的值：123456789*nameP = &quot;公众号:Go语言圈&quot;//修改指针指向的值fmt.Println(&quot;nameP指针指向的值为:&quot;,*nameP)fmt.Println(&quot;name变量的值为:&quot;,name)//运行结果：//nameP指针指向的值为: 公众号:Go语言圈//name变量的值为: 公众号:Go语言圈 我们发现nameP 指针指向的值被改变了，变量 name 的值也被改变了 因为变量 name 存储数据的内存就是指针 nameP 指向的内存，这块内存被 nameP 修改后，变量 name 的值也被修改了。 通过 var 关键字直接定义的指针变量是不能进行赋值操作的，因为它的值为 nil，也就是还没有指向的内存地址123456789101112131415//错误示例var intP *int*intP = 10//错误，应该先给分配一块内存，内存地址作为变量 intP 的值，这个内存就可以存放 10 了。//应该使用var intP *int//声明int类型的指针变量 intPintP = new(int) // 给指针分配一块内存*intP = 66 fmt.Println(&quot;:::&quot;,intP) //::: 0xc0000ac088fmt.Println(*intP) //66//简短写法var intP := new(int)*intP=66 指针参数当给一个函数使用指针作为参数的时候，就可以在函数中，通过形参改变实参的值：123456789101112func main() &#123; name := &quot;疯子&quot; modify(&amp;name) fmt.Println(&quot;name的值为:&quot;,name)&#125;func modify(name *string) &#123; *name = &quot;wucs&quot;&#125;//运行结果：//name的值为: wucs 指针接收者 如果接收者类型是 map、slice、channel 这类引用类型，不使用指针； 如果需要修改接收者，那么需要使用指针； 如果接收者是比较大的类型，可以考虑使用指针，因为内存拷贝廉价，所以效率高。 普通指针和C语言一样, 允许用一个变量来存放其它变量的地址, 这种专门用于存储其它变量地址的变量, 我们称之为指针变量.和C语言一样, Go语言中的指针无论是什么类型占用内存都一样(32位4个字节, 64位8个字节)12345678910111213141516package mainimport ( &quot;fmt&quot; &quot;unsafe&quot;)func main() &#123; var p1 *int; var p2 *float64; var p3 *bool; fmt.Println(unsafe.Sizeof(p1)) // 8 fmt.Println(unsafe.Sizeof(p2)) // 8 fmt.Println(unsafe.Sizeof(p3)) // 8&#125; 和C语言一样, 只要一个指针变量保存了另一个变量对应的内存地址, 那么就可以通过*来访问指针变量指向的存储空间1234567891011121314151617181920212223package mainimport ( &quot;fmt&quot;)func main() &#123; // 1.定义一个普通变量 var num int = 666 // 2.定义一个指针变量 var p *int = &amp;num fmt.Printf(&quot;%p\\n&quot;, &amp;num) // 0xc042064080 fmt.Printf(&quot;%p\\n&quot;, p) // 0xc042064080 fmt.Printf(&quot;%T\\n&quot;, p) // *int // 3.通过指针变量操作指向的存储空间 *p = 888 // 4.指针变量操作的就是指向变量的存储空间 fmt.Println(num) // 888 fmt.Println(*p) // 888&#125; 指向数组指针在Go语言中通过数组名无法直接获取数组的内存地址123456789package mainimport &quot;fmt&quot;func main() &#123; var arr [3]int = [3]int&#123;1, 3, 5&#125; fmt.Printf(&quot;%p\\n&quot;, arr) // 乱七八糟东西 fmt.Printf(&quot;%p\\n&quot;, &amp;arr) // 0xc0420620a0 fmt.Printf(&quot;%p\\n&quot;, &amp;arr[0]) // 0xc0420620a0&#125; 在Go语言中, 因为只有数据类型一模一样才能赋值, 所以只能通过&amp;数组名赋值给指针变量, 才代表指针变量指向了这个数组123456789101112131415161718192021222324252627282930package mainimport &quot;fmt&quot;func main() &#123; // 1.错误, 在Go语言中必须类型一模一样才能赋值 // arr类型是[3]int, p1的类型是*[3]int var p1 *[3]int fmt.Printf(&quot;%T\\n&quot;, arr) fmt.Printf(&quot;%T\\n&quot;, p1) p1 = arr // 报错 p1[1] = 6 fmt.Println(arr[1]) // 2.正确, &amp;arr的类型是*[3]int, p2的类型也是*[3]int var p2 *[3]int fmt.Printf(&quot;%T\\n&quot;, &amp;arr) fmt.Printf(&quot;%T\\n&quot;, p2) p2 = &amp;arr p2[1] = 6 fmt.Println(arr[1]) // 3.错误, &amp;arr[0]的类型是*int, p3的类型也是*[3]int var p3 *[3]int fmt.Printf(&quot;%T\\n&quot;, &amp;arr[0]) fmt.Printf(&quot;%T\\n&quot;, p3) p3 = &amp;arr[0] // 报错 p3[1] = 6 fmt.Println(arr[1])&#125; 注意点:Go语言中的指针, 不支持C语言中的+1 -1和++ –- 操作123456789101112131415161718192021222324252627282930313233package mainimport &quot;fmt&quot;func main() &#123; var arr [3]int = [3]int&#123;1, 3, 5&#125; var p *[3]int p = &amp;arr fmt.Printf(&quot;%p\\n&quot;, &amp;arr) // 0xc0420620a0 fmt.Printf(&quot;%p\\n&quot;, p) // 0xc0420620a0 fmt.Println(&amp;arr) // &amp;[1 3 5] fmt.Println(p) // &amp;[1 3 5] // 指针指向数组之后操作数组的几种方式 // 1.直接通过数组名操作 arr[1] = 6 fmt.Println(arr[1]) // 2.通过指针间接操作 (*p)[1] = 7 fmt.Println((*p)[1]) fmt.Println(arr[1]) // 3.通过指针间接操作 p[1] = 8 fmt.Println(p[1]) fmt.Println(arr[1]) // 注意点: Go语言中的指针, 不支持+1 -1和++ --操作 *(p + 1) = 9 // 报错 fmt.Println(*p++) // 报错 fmt.Println(arr[1])&#125; 指向切片的指针值得注意点的是切片的本质就是一个指针指向数组, 所以指向切片的指针是一个二级指针12345678910111213141516171819202122232425262728293031323334package mainimport &quot;fmt&quot;func main() &#123; // 1.定义一个切片 var sce[]int = []int&#123;1, 3, 5&#125; // 2.打印切片的地址 // 切片变量中保存的地址, 也就是指向的那个数组的地址 sce = 0xc0420620a0 fmt.Printf(&quot;sce = %p\\n&quot;,sce ) fmt.Println(sce) // [1 3 5] // 切片变量自己的地址, &amp;sce = 0xc04205e3e0 fmt.Printf(&quot;&amp;sce = %p\\n&quot;,&amp;sce ) fmt.Println(&amp;sce) // &amp;[1 3 5] // 3.定义一个指向切片的指针 var p *[]int // 因为必须类型一致才能赋值, 所以将切片变量自己的地址给了指针 p = &amp;sce // 4.打印指针保存的地址 // 直接打印p打印出来的是保存的切片变量的地址 p = 0xc04205e3e0 fmt.Printf(&quot;p = %p\\n&quot;, p) fmt.Println(p) // &amp;[1 3 5] // 打印*p打印出来的是切片变量保存的地址, 也就是数组的地址 *p = 0xc0420620a0 fmt.Printf(&quot;*p = %p\\n&quot;, *p) fmt.Println(*p) // [1 3 5] // 5.修改切片的值 // 通过*p找到切片变量指向的存储空间(数组), 然后修改数组中保存的数据 (*p)[1] = 666 fmt.Println(sce[1])&#125; 指向字典指针与普通指针并无差异123456789package mainimport &quot;fmt&quot;func main() &#123; var dict map[string]string = map[string]string&#123;&quot;name&quot;:&quot;lnj&quot;, &quot;age&quot;:&quot;33&quot;&#125; var p *map[string]string = &amp;dict (*p)[&quot;name&quot;] = &quot;zs&quot; fmt.Println(dict)&#125; 指向结构体指针Go语言中指向结构体的指针和C语言一样结构体和指针创建结构体指针变量有两种方式123456789101112131415161718package mainimport &quot;fmt&quot;type Student struct &#123; name string age int&#125;func main() &#123; // 创建时利用取地址符号获取结构体变量地址 var p1 = &amp;Student&#123;&quot;lnj&quot;, 33&#125; fmt.Println(p1) // &amp;&#123;lnj 33&#125; // 通过new内置函数传入数据类型创建 // 内部会创建一个空的结构体变量, 然后返回这个结构体变量的地址 var p2 = new(Student) fmt.Println(p2) // &amp;&#123; 0&#125;&#125; 利用结构体指针操作结构体属性1234567891011121314151617181920212223package mainimport &quot;fmt&quot;type Student struct &#123; name string age int&#125;func main() &#123; var p = &amp;Student&#123;&#125; // 方式一: 传统方式操作 // 修改结构体中某个属性对应的值 // 注意: 由于.运算符优先级比*高, 所以一定要加上() (*p).name = &quot;lnj&quot; // 获取结构体中某个属性对应的值 fmt.Println((*p).name) // lnj // 方式二: 通过Go语法糖操作 // Go语言作者为了程序员使用起来更加方便, 在操作指向结构体的指针时可以像操作接头体变量一样通过.来操作 // 编译时底层会自动转发为(*p).age方式 p.age = 33 fmt.Println(p.age) // 33&#125; 什么情况下使用指针 不要对 map、slice、channel 这类引用类型使用指针； 如果需要修改方法接收者内部的数据或者状态时，需要使用指针； 如果需要修改参数的值或者内部数据时，也需要使用指针类型的参数； 如果是比较大的结构体，每次参数传递或者调用方法都要内存拷贝，内存占用多，这时候可以考虑使用指针； 像 int、bool 这样的小数据类型没必要使用指针； 如果需要并发安全，则尽可能地不要使用指针，使用指针一定要保证并发安全； 指针最好不要嵌套，也就是不要使用一个指向指针的指针，虽然 Go 语言允许这么做，但是这会使你的代码变得异常复杂。","categories":[{"name":"Go","slug":"Go","permalink":"https://hwame.top/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://hwame.top/tags/Go/"}]},{"title":"Markdown中图片的高级用法","slug":"awesome-images-in-markdown","date":"2022-02-28T15:27:50.000Z","updated":"2022-03-02T15:28:27.000Z","comments":true,"path":"20220228/awesome-images-in-markdown.html","link":"","permalink":"https://hwame.top/20220228/awesome-images-in-markdown.html","excerpt":"","text":"文章说明文章作者：鴻塵文章链接：https://hwame.top/20220228/awesome-images-in-markdown.html原文作者：吾乃木易先生原文链接：https://www.52pojie.cn/thread-1522362-1-1.html参考资料： 庆国诞72周年，分享我帖子中的链接小卡片是怎么做的 ~2.6貌似有问题，style变成前内容了~ 【已更正】 ~由于此前将Hexo默认CSS修改为图片居中了，故本文显示不太顺眼，可移步原文！~ 解决办法：在文章前添加样式即可，!important不会被其他选择器覆盖掉12345&lt;style&gt; img &#123; display: inline !important; &#125;&lt;/style&gt; img { display: inline !important; } 之前我分享精品软件的时候用到了链接小卡片，有坛友问我怎么做，虽然我两三言简要回复过了，但没具体说。值此国诞72周年，特来分享。 前排提醒：需要会写基本的 Markdown 语法（当然，如果只想学会链接小卡片的话会写图片和链接的语法就可以了）。如果不会 Markdown，可以参考论坛里的这篇帖子（点击即可传送）： 1 什么是链接小卡片这玩意儿实际上叫 badge，翻译过来是徽标的意思。大概是因为我每次用这个都是用作链接，而这玩意儿长得有点像小卡片，所以坛友贴心地起名叫“链接小卡片”。 在论坛中发帖使用请确保使用的是 MD 编辑器，具体使用方法见此贴（点击传送）： 2 使用方法链接小卡片本质上是借助 这个网站来实现的图片。所以会用到 Markdown 图片语法，如果想做成链接，还需用到 Markdown 链接语法。 所有参数值未加特殊说明均不可省略！ 由于是通过其他网站实现显示图片，所以要想正常显示，必须确保有网。 前排提醒：本帖不是广告！此网站是开源、非商业、非盈利性网站，没有任何收费的项目！ 2.1 单内容链接小卡片我把只有一个内容项的称为 单内容链接小卡片。比如我的签名的第一个。 2.1.1 语法1![](https://img.shields.io/badge/内容-防伪值?color=颜色值) 2.1.2 示例1![](https://img.shields.io/badge/吾爱破解-吾乃木易先生?color=ff69b4) 效果： 2.1.3 注意事项 使用时替换语法代码部分中的汉字内容即可 颜色值可省略（从 ? 开始省略） 颜色值均指背景颜色，字体颜色会自动调整，无法自定义字体颜色 颜色值若使用 16 进制，不要加 # 号 默认的颜色是： 防伪值只是我是这么叫的，因为它在这里不会显示 只要出现防伪值，防伪值均不可省略，下同 2.2 双内容链接小卡片我把有两个内容项的称为 双内容链接小卡片。 2.2.1 语法1![](https://img.shields.io/badge/前内容-后内容-后内容颜色值) 2.2.2 示例1![](https://img.shields.io/badge/52PoJie-吾爱破解-fff) 效果： 2.2.3 注意事项 所有内容均不可省略，包括颜色值 这里的颜色值只能修改后内容的颜色值 2.3 图标链接小卡片我把带有小图标的称为 图标链接小卡片。比如我签名中后面几个。 图标链接小卡片又分为 内置图标链接小卡片 和 自定义图标链接小卡片。 2.3.1 内置图标链接小卡片内置图标可以直接使用。所有内置图标可以在这里找到（点击传送）： 2.3.1.1 语法12345671. 单内容![](https://img.shields.io/badge/内容-防伪值?color=颜色&amp;logo=内置图标名);2. 双内容![](https://img.shields.io/badge/前内容-后内容-后内容颜色值?logo=内置图标名) 2.3.1.2 示例123451. 单内容![](https://img.shields.io/badge/QQ-吾乃木易先生?color=4ab7f5&amp;logo=tencentqq);2. 双内容![](https://img.shields.io/badge/macOS-10.13+-367aff?logo=apple) 效果： 单内容： 双内容： 2.3.1.3 修改内置图标颜色 部分内置图标默认是白色的，比如上面的示例 部分内置图标默认自带颜色，比如： 还有 哪些默认带颜色，哪些默认不带，需要自己试 内置图标的颜色可以修改 2.3.1.3.1 语法123451. 单内容![](https://img.shields.io/badge/内容-防伪值?color=颜色&amp;logo=内置图标名&amp;logoColor=内置图标颜色值);2. 双内容![](https://img.shields.io/badge/前内容-后内容-后内容颜色值?logo=内置图标名&amp;logoColor=内置图标颜色值) 2.3.1.3.2 示例123451. 单内容![](https://img.shields.io/badge/QQ-吾乃木易先生?color=fff&amp;logo=tencentqq&amp;logoColor=4ab7f5);2. 双内容![](https://img.shields.io/badge/macOS-10.13+-367aff?logo=apple&amp;logoColor=f9d694) 效果： 2.3.2 自定义图标链接小卡片自定义图标需将图片转换成 Base64 编码（这样的工具很多，论坛里也有人发过），同时需要原图片的长和宽均 ≥ 14px。 2.3.2.1 语法123451. 单内容![](https://img.shields.io/badge/内容-防伪值?color=颜色值&amp;logo=data:image/png;base64,一长串Base64编码);2. 双内容![](https://img.shields.io/badge/前内容-后内容-防伪值?color=后内容颜色值&amp;logo=data:image/png;base64,一长串Base64编码) 2.3.2.2 示例我把论坛的 Logo 转换成了 Base64 编码作为示例，不过编码太长了，放进来严重影响阅读，所以就省略不放了。 123451. 单内容![](https://img.shields.io/badge/吾乃木易先生-吾乃木易?color=fff&amp;logo=data:image/png;base64,AAA...A==);2. 双内容![](https://img.shields.io/badge/吾爱破解-吾乃木易先生-吾乃木易?color=fff&amp;logo=data:image/png;base64,AAA...A==) 效果： 单内容： 双内容： 2.4 双内容自定义颜色前面提及双内容链接小卡片的语法和示例中可修改的颜色值都只能修改后内容的颜色。本小节将演示如何分别控制双内容的颜色。 2.4.1 语法1![](https://img.shields.io/badge/后内容-防伪值?label=前内容&amp;colorA=前内容颜色值&amp;colorB=后内容颜色值) 2.4.2 示例1![](https://img.shields.io/badge/macOS-吾乃木易先生?label=AppStore&amp;colorA=fff&amp;colorB=367aff&amp;logo=appstore) 效果： 2.4.3 注意事项 注意图片语法链接中的“前内容”跑到后面去了，“后内容”跑到前面去了，不要搞反了 如果要加上图标，比如上面的示例，直接在图片语法链接末尾加上 &amp;logo=图标名 即可，注意 &amp; 不要忘了 如果还要修改图标颜色，再继续在链接末尾继续加上 &amp;logoColor=图标颜色值 即可 2.5 增加超链接我的软件分享贴的链接小卡片是可以点的，本帖当中的部分也是，这是因为在 Markdown 图片语法外层又套娃了一层超链接语法。 2.5.1 语法1[链接小卡片图片显示](超链接地址) 2.5.2 示例就是把 2.1 ~ 2.4 学到的放在超链接语法的 [] 里就行。 1[![](https://img.shields.io/badge/吾爱破解-吾乃木易先生?color=fff&amp;logo=data:image/png;base64,AAA...A==)](https://www.52pojie.cn/) 效果： 其他的可以自行尝试。 2.6 样式有五种样式可供选择。 2.6.1 默认默认就是这种带立体感的圆角矩形样式。 示例： 1![](https://img.shields.io/badge/style=plastic-吾乃木易先生?label=Git&amp;colorA=fff&amp;colorB=f14d28&amp;logo=git) 效果： 默认实际上就是 &amp;style=plastic。 2.6.2 扁平圆角矩形2.6.2.1 语法1&amp;style=flat 2.6.2.2 示例1![](https://img.shields.io/badge/style=flat-吾乃木易先生?label=Git&amp;colorA=fff&amp;colorB=f14d28&amp;logo=git&amp;style=flat) 效果： 2.6.3 扁平直角矩形2.6.3.1 语法1&amp;style=flat-square 2.6.3.2 示例1![](https://img.shields.io/badge/style=flat--square-吾乃木易先生?label=Git&amp;colorA=fff&amp;colorB=f14d28&amp;logo=git&amp;style=flat-square) 效果： 2.6.4 大扁平圆角矩形 - 字母全大写2.6.4.1 语法1&amp;style=for-the-badge 2.6.4.2 示例1![](https://img.shields.io/badge/style=for--the--badge-吾乃木易先生?label=Git&amp;colorA=fff&amp;colorB=f14d28&amp;logo=git&amp;style=for-the-badge) 效果： 2.6.5 GitHub 交流样式2.6.5.1 语法1&amp;style=social 2.6.5.2 示例1![](https://img.shields.io/badge/style=social-吾乃木易先生?label=Git&amp;colorA=fff&amp;colorB=f14d28&amp;logo=git&amp;style=social) 效果： 2.7 动态内容动态内容即显示的内容为可变的，主要用于 GitHub 等网站的某些数据显示。 这里的动态内容只介绍与 GitHub 相关的一部分，想了解更多可以去官网查询。 以 Linux 之父林纳斯·托瓦斯的 Linux 源代码仓库 torvalds/linux 为示例。 2.7.1 Watch语法： 1![](https://img.shields.io/github/watchers/用户名/仓库名?style=social&amp;label=Watch) 示例： 1![](https://img.shields.io/github/watchers/torvalds/linux?style=social&amp;label=Watch) 效果： 2.7.2 Star语法： 1![](https://img.shields.io/github/stars/用户名/仓库名?style=social) 示例： 1![](https://img.shields.io/github/stars/torvalds/linux?style=social&amp;label=star) 效果： 2.7.3 Fork语法： 1![](https://img.shields.io/github/forks/用户名/仓库名?style=social&amp;label=Fork) 示例： 1![](https://img.shields.io/github/forks/torvalds/linux?style=social&amp;label=Fork) 效果： 其他的可以自行尝试。 3 特殊符号问题有时候需要空格或者其他的特殊符号，直接打在链接里可能会导致结果不符合预期。 解决方法其实很简单，就是把特殊符号转换成 url 编码即可。 3.1 空格示例之前 App Store 那个示例中是没有空格的，现在添加空格（空格的 url 编码是 %20 ）： 1![](https://img.shields.io/badge/macOS-吾乃木易先生?label=App%20Store&amp;colorA=fff&amp;colorB=367aff&amp;logo=appstore) 效果： 3.2 短横 - 符号示例短横符号 - 比较特殊，它没有 url 编码，或者说它的 url 编码就是它本身。 要想在小卡片中显示它也很简单，写两遍就行。 1![](https://img.shields.io/badge/-everything--is--local-吾乃木易先生?label=git&amp;colorA=fff&amp;colorB=f14d28&amp;logo=git) 效果： 4. 写在最后本帖内容的 .md 源文件也一并分享给大家，任何一款 Markdown 编辑器均支持以上所有操作和显示相关内容。 纸上得来终觉浅，绝知此事要躬行。——陆游《冬夜读书示子聿》 看和听再多，也比不上自己动手试一遍。学习这件事儿，眼睛和耳朵告诉脑子会了，也要脑子能指挥手会才行。 祝各位学习愉快，技术大成！祝祖国繁荣昌盛，国泰民安！ 此国旗图案来源于中国政府网的“网络使用的国旗图案标准版本”，使用符合《中华人民共和国国旗法》。","categories":[{"name":"miscellanea","slug":"miscellanea","permalink":"https://hwame.top/categories/miscellanea/"}],"tags":[{"name":"miscellanea","slug":"miscellanea","permalink":"https://hwame.top/tags/miscellanea/"}]},{"title":"Shell正则表达式","slug":"shell-regular-expression","date":"2022-01-16T14:13:05.000Z","updated":"2022-02-22T16:10:38.000Z","comments":true,"path":"20220116/shell-regular-expression.html","link":"","permalink":"https://hwame.top/20220116/shell-regular-expression.html","excerpt":"","text":"文章说明文章作者：鴻塵文章链接：https://hwame.top/20220116/shell-regular-expression.html参考资料： shell-正则表达式 「通配符」和「正则表达式」的区别 正则表达式和通配符的区别 1.定义正则表达式(regular expression)是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串，它描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。 只有掌握了正则表达式，才能全面地掌握 Linux 下的常用文本工具（例如：grep、egrep、GUN sed、 awk 等） 的用法。 2.正则表达式分类 基本的正则表达式（Basic Regular Expression，又叫 Basic RegEx，简称 BREs）； 扩展的正则表达式（Extended Regular Expression，又叫 Extended RegEx，简称 EREs）； Perl 的正则表达式（Perl Regular Expression，又叫 Perl RegEx，简称 PREs）。 3.Linux常用文本工具与正则表达式的关系常握 Linux 下几种常用文本工具的特点，对于我们更好的使用正则表达式是很有帮助的。 表格内容来自参考资料 《shell-正则表达式》，暂未对其验证。 命令 BREs EREs PREs 处理模式 grep 默认 -E参数 -P参数 行 egrep —— 默认 -P参数 行 sed 默认 -r参数 —— 行 awk —— 默认 —— 列 4.正则表达式比较注释见表格下方。 字符 BREs EREs Python PREs 说明 \\ \\ \\ \\ \\ 转义字符 ^ ^ ^ ^ ^ 匹配行首[1] $$` `$$ $$` `$$ $ 匹配行尾[2] ^$ ^$ ^$ ^$ ^$ 匹配空行 \\&lt; \\&lt; \\&lt; —— —— 匹配单词开头[3]，等价于\\b \\&gt; &gt; \\&gt; —— —— 匹配单词结尾，等价于\\b \\&lt;string\\&gt; \\&lt;string\\&gt; \\&lt;string\\&gt; —— —— 匹配单词或特定字符string[4] () \\(\\) () () () 匹配表达式[5] ? \\? ? ? ? 匹配0次或1次[6] ? —— —— —— —— 非贪婪匹配[7] . . . . . 匹配任意单个字符[8] * * * * * 匹配0次或多次 + \\+ + + + 匹配1次或多次 &#123;n&#125; \\&#123;n\\&#125; &#123;n&#125; &#123;n&#125; &#123;n&#125; 匹配n次 &#123;n,&#125; \\&#123;n,\\&#125; &#123;n,&#125; &#123;n,&#125; &#123;n,&#125; 匹配大于等于n次 &#123;n,m&#125; \\&#123;n,m\\&#125; &#123;n,m&#125; &#123;n,m&#125; &#123;n,m&#125; 匹配n~m次[9] x｜y x｜y x｜y x｜y x｜y 匹配x或y[10] [0-9] [0-9] [0-9] [0-9] [0-9] 匹配一个数字字符[11] [xyz] [xyz] [xyz] [xyz] [xyz] 匹配字符集合中的任一字符[12] [^xyz] [^xyz] [^xyz] [^xyz] [^xyz] 匹配字符集合以外的任一字符[13] [A-Za-z] [A-Za-z] [A-Za-z] [A-Za-z] [A-Za-z] 匹配任一字母 [^A-Za-z] [^A-Za-z] [^A-Za-z] [^A-Za-z] [^A-Za-z] 匹配除字母外的任一字符 \\d —— —— \\d \\d 匹配任一数字字符，等价于[0-9] \\D —— —— \\D \\D 匹配任一非数字字符，等价于[^0-9] \\s —— —— \\s \\s 匹配任一空白字符，等价于[\\f\\n\\r\\t\\v] \\S —— —— \\S \\S 匹配任一非空白字符，等价于[^\\f\\n\\r\\t\\v] \\w \\w \\w \\w \\w 匹配任一单词字符，等价于[A-Za-z0-9_] \\W \\W \\W \\W \\W 匹配任一非单词字符，等价于[^A-Za-z0-9_] \\b \\b \\b \\b \\b 匹配单词边界，即单词和空格间的位置 \\B \\B \\B \\B \\B 匹配非单词边界 \\t —— —— \\t \\t 匹配一个横向制表符，等价于\\x09和\\cI \\v —— —— \\v \\v 匹配一个垂直制表符，等价于\\x0b和\\cK \\n —— —— \\n \\n 匹配一个换行符，等价于\\x0a和\\cJ \\f —— —— \\f \\f 匹配一个换页符，等价于\\x0c和\\cL \\r —— —— \\r \\r 匹配一个回车符，等价于\\x0d和\\cM \\\\ \\ \\\\ \\\\ \\\\ 匹配一个转义字符\\本身 \\cx —— —— \\cx 匹配由x指明的控制字符[14] \\xn —— —— \\xn 匹配十六进制n[15] \\num —— \\num \\num 匹配引用 [:alnum:] [:alnum:] [:alnum:] [:alnum:] [:alnum:] 匹配任一字母或数字字符，等价于[A-Za-z0-9] [:alpha:] [:alpha:] [:alpha:] [:alpha:] [:alpha:] 匹配任一字母字符，等价于[A-Za-z] [:digit:] [:digit:] [:digit:] [:digit:] [:digit:] 匹配任一数字，等价于[0-9] [:lower:] [:lower:] [:lower:] [:lower:] [:lower:] 匹配任一小写字母，等价于[a-z] [:upper:] [:upper:] [:upper:] [:upper:] [:upper:] 匹配任一大写字母，等价于[A-Z] [:space:] [:space:] [:space:] [:space:] [:space:] 匹配任一空白字符 [:blank:] [:blank:] [:blank:] [:blank:] [:blank:] 匹配空格和制表符 [:graph:] [:graph:] [:graph:] [:graph:] [:graph:] 匹配任一可见且可打印的字符[16] [:print:] [:print:] [:print:] [:print:] [:print:] 匹配任一可打印字符[17] [:cntrl:] [:cntrl:] [:cntrl:] [:cntrl:] [:cntrl:] 匹配任一控制字符[18] [:punct:] [:punct:] [:punct:] [:punct:] [:punct:] 匹配任一标点符号[19] [:xdigit:] [:xdigit:] [:xdigit:] [:xdigit:] [:xdigit:] 匹配任一十六进制数，即[0-9a-fA-F] 注释：[1] ^string匹配以字符串string开头的行，在awk中则是匹配字符串的开始（因为awk以列为单位）。[2] ^string匹配以字符串string结尾的行，在awk中则是匹配字符串的结束（因为awk以列为单位）。[3] \\&lt;和\\&gt;匹配单词时等价于\\b，\\&lt;string和string\\&gt;分别表示以string开头和结尾的单词。PREs中不支持此方式，但可用\\b的等价写法。[4] \\&lt;string\\&gt;匹配特定单词或字符string，等价于\\bstring\\b。PREs中不支持此方式，但可用\\b的等价写法。[5] ()表示对匹配的表达式分组，可以\\num形式引用。[6] ?表示匹配前面的子表达式0次或1次，等价于\\&#123;0,1\\&#125;，例如where(is)可匹配where及whereis。[7] 若子表达式为 限制符（*、+、?、&#123;n&#125;、&#123;n,&#125;、&#123;n,m&#125;） 时表示非贪婪匹配，本文涉及的正则表达式用法不支持此方式（存疑），但可使用 修饰符U （见下文）。[8] .匹配除换行符之外的任一字符，在awk中能匹配换行符。如果要匹配包括换行符在内的任一字符，则在EREs中可使用(^$)|(.)，在Perl RE中可使用[.\\n]。[9] 最少匹配n次，且最多匹配m次。注意在逗号和两个数之间不能有空格。[10] 由于半角|作为表格单元格分隔符且优先解析，即使写在行内代码中也会被解析成单元格，故此处使用全角｜。[11] 数字需写成递增顺序。[12] 若元字符（例如.、*等）置于方括号中，则将作为普通字符。[13] [^xyz]表示负值字符集合且不包括换行符，在awk中表示匹配 未包含的任一字符＋换行符 。[14] \\cx匹配由x指明的控制字符即Control-x或回车符，x的值必须为A-Z或a-z之一，否则将c视为一个原义的字符c。[15] \\xn匹配十六进制转义值n，十六进制转义值必须为确定的两个数字长。例如：\\x41匹配A（正则表达式中可以使用 ASCII 编码，十六进制41＝十进制65）；而\\x041则等价于\\x04＋1。[16] [:graph:]不包括空格和换行符等。[17] [:print:]不包括控制字符[:cntrl:]、字符串结束符\\0、EOF文件结束符（-1）， 但包括空格符号。[18] 控制字符[:cntrl:]指 ASCII 字符集中的前 32 个字符，即用十进制表示为从 0 到 31，例如换行符、制表符等。[19] 标点符号[:punct:]不包括[:alnum:]、[:cntrl:]、[:space:]等字符集。 5.说明 当使用 BERs（基本正则表达式）时，必须在特殊符号前加上转义字符（\\），以屏蔽掉它们的特殊含义。特殊符号有?、+、|、&#123;、&#125;、(、)。 修饰符用在正则表达式结尾，例如/dog/i中的i就是修饰符，表示匹配时不区分大小写。常见的修饰符如下： g，表示全局匹配（即：一行上的每个出现，而不只是一行上的第一个出现）； s，表示把整个匹配串当作一行处理； m，表示多行匹配； i，表示忽略大小写； x，表示允许注释和空格的出现； U，表示非贪婪匹配。 111","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hwame.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://hwame.top/tags/Linux/"},{"name":"shell","slug":"shell","permalink":"https://hwame.top/tags/shell/"}]},{"title":"如何在安卓手机上安装Linux发行版","slug":"install-linux-on-android-phone","date":"2021-10-09T15:16:37.000Z","updated":"2021-10-15T17:39:10.000Z","comments":true,"path":"20211009/install-linux-on-android-phone.html","link":"","permalink":"https://hwame.top/20211009/install-linux-on-android-phone.html","excerpt":"摘要：废旧的安卓手机root后安装Linux发行版，并在chroot容器中运行。","text":"摘要：废旧的安卓手机root后安装Linux发行版，并在chroot容器中运行。 文章说明文章作者：鴻塵文章链接：https://hwame.top/20211009/install-linux-on-android-phone.html文章说明：root手机上安装Linux系统，我折腾过很长的一段时间，查阅参考了很多文章，由于时间跨度较大，参考资料可能不全。参考资料： Turn Your Old, Cracked Android Phone Into a Backup Server! 安卓手机装centos 当服务器 Linux deploy 超详细入门教程 Linux Deploy 安装centos-altarch 1.前言在已root手机上安装Linux发行版，我曾做过很多尝试，成功失败的都有，但是即使成功也是安装的Debian系的，RedHat系从未成功过。 写这篇文章时看了看电脑里的资料，发现早在2020年的6月就已经开始尝试了，那时候正是暑假没开学疫情在家没事干的时候，恰好手上有一台完全root的安卓手机。但那时候不是刚利用学生身份白嫖了阿里云的1M2H4G服务器吗，虽然说半年之后因为「考试」没过不能续期半年而没法白嫖到一年…… 没有了学生身份之后，购买云服务器的价格是越来越贵了，不管是阿里云还是腾讯云。我寻思着能不能找到什么替代品，这让我想起之前在知乎不经意看到的，可以把Android手机改造成Linux。 ✉本文也是一边摸索一边采坑，才成功安装上不同的Linux发行版，建议同时参考Debian和CentOS的「配置LinuxDeploy」部分。 2.准备工作 root手机，需要获得系统级Root权限。注意，未获取Root权限的手机可通过Termux作为替代软件，从而在手机上安装Linux，但是很多Linux命令将无法使用，不过运行个python命令行还是可以的【未验证，自行尝试】。 需要连接网络，最好与电脑处于同一无线局域网，这样就可以在电脑上通过SecureCRT/XShell之类的软件进行连接； 手机上安装Linux deploy（必需）、BusyBox（必需），JuiceSSH（可选但建议），RootExplorer（可选），各软件作用如下： BusyBox（需要Root权限）：用于扩展Android手机命令，因为在这装Linux之后，很多Linux命令都是没有的； Linux deploy（需要Root权限）：作为装载Linux系统的容器； JuiceSSH：手机终端通过SSH连接Linux。 RootExplorer（需要Root权限）：强大的文件管理器，可操作系统文件、精简系统。 安装BusyBox：打开BusyBox软件，可以看到状态为*not installed，点击右下方INSTALL，按提示赋予ROOT权限即可安装，如图所示： 3.安装Debian系统3.1.配置LinuxDeploy 打开Linux Deploy软件，首页可见简要安装步骤（如上图1）。点击首页右下角的「设置图标」进行如下配置（建议「引导设置」中的配置项「本地化」设置为zh_CN.UTF-8）： 类别 配置项 属性 备注 引导设置 发行版GNU/Linux Debian 引导设置 架构 arm64 安装BusyBox时的architecture，没有就选最接近的 引导设置 发行版GNU/Linux版本 buster 引导设置 源地址 http://ftp.debian.org/debian/ 可更换国内镜像源 引导设置 安装类型 镜像文件 引导设置 安装路径 /storage/emulated/0/linux.img 可命名为debian.img以示区别 引导设置 镜像大小 自动分配 默认为2GB，可修改 引导设置 文件系统 ext4 引导设置 用户名 root 默认android 引导设置 用户密码 **** 初始化 启用 ☑️ 貌似可不选 初始化 初始化系统 sysv 貌似可不选 挂载 启用 ☑️ 貌似可不选 SSH 启用 ☑️ 必选 配置完成后返回首页，点击左上角菜单图标，选择设置（如上图2），配置「环境」项。其中，「ENV目录」默认即可，「PATH变量」设置为「/system/xbin」，然后点击「更新环境」来更新操作环境（如上图3）。 3.2.安装过程 更新完操作环境后，回到Linux Deploy主页，点击右上角选项图标 ，选择「安装」，按提示赋予ROOT权限即可开始安装（如上图1）。首先是系统和分区、软件包的Retrieving和Validating（如上图2），然后是Extracting、Unpacking、Configuring（如上图3），接着下载安装其他必要软件（如下图1、2），最后是Setting up、Creating、Processing，配置好extra/ssh后则部署完成（如下图3）。 至此，Debian安装部署完成，第一次部署需要安装的软件很多，因此输出的日志很多很杂，「&gt;&gt;&gt; deploy」和「&lt;&lt;&lt; deploy」之间的输出即安装部署时的日志，如果失败则可从中检查。初次安装花费5分钟左右的时间，这取决于网速，例如此处运行时间为[09:51:02]～[09:55:07]。第二次再点安装时则只用了10秒，程序做必要的检查、软件的更新：[11:55:29] 0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded，如下图。 3.3.容器的启动与停止安装完成后即可启动、连接、使用了。在Linux Deploy主页下方点击「启动」和「停止」即可完成服务器对应的操作，日志也会同步输出对应「&gt;&gt;&gt; start / &lt;&lt;&lt; start」和「&gt;&gt;&gt; stop / &lt;&lt;&lt; stop」的信息，如图所示。 注意：初次安装完成后，应先点击「停止」进行分区及系统的卸载，然后重新点击「启动」。 3.4.连接使用Linux保持Linux处于 启动 状态，则可以通过SSH软件进行连接，例如Juice SSH、X Shell和Secure CRT等。 例如在同一局域网下，电脑IP为192.168.0.104，手机（Linux主机）IP为192.168.0.107，则可以进行连接，如图是使用命令行进行ssh连接。 【说明：】①貌似连接10分钟无操作则自动断开；②图示ssh命令第一次连接时会提示；③推荐使用专门软件，命令行过于简陋。 4.安装CentOS系统4.1.新建LinuxDeploy配置上面安装的Debian系统是在7月24日完成的，很多「非必要修改」的东西都是保持默认，比如镜像源、安装路径等配置项。 由于要安装CentOS，为了保留Debian和CentOS两者的配置，故新建一个配置文件而不是覆盖修改原来的Debian的配置。 在LinuxDeploy软件首页点击左上角菜单图标 ，选择配置文件，新建一个名称为Centos的配置文件。为了以示区别，将默认名称Linux修改为Debian。 选择Centos配置文件后返回主界面，点击左上角菜单图标 ，选择设置 ，配置「环境」项，与3.1节安装Debian系统时的配置LinuxDeploy相同，不再赘述。 4.2.配置LinuxDeploy打开Linux Deploy，首页可见简要安装步骤。点击右下角的设置图标 进行如下配置： 类别 配置项 属性 备注 引导设置 发行版GNU/Linux Centos 引导设置 架构 aarch64 安装BusyBox时的architecture 引导设置 发行版GNU/Linux版本 7 引导设置 源地址 https://mirrors.bfsu.edu.cn/centos-altarch/ 清华源失败才换此源 引导设置 安装类型 镜像文件 引导设置 安装路径 /storage/emulated/0/centos.img 与debian.img相区别 引导设置 镜像大小 自动分配 默认为2GB，可修改 引导设置 文件系统 ext4 引导设置 用户名 android 默认android 引导设置 用户密码 **** 引导设置 本地化 zh_CN.UTF-8 默认为C SSH 启用 ☑️ 必选 说明： ①镜像源地址是最容易出错的地方，就笔者环境而言：官方源速度慢不稳定，清华源卡会在某一步动不了（原因是否是用户名设置为root还是启用初始化/挂载未知），阿里源没有altarch分支，故选择北京外国语大学镜像站（只有这个才能成功安装CentOS）。 ②因猜测清华源root用户名原因，故将用户名改为android而未直接设置root。待系统安装成功后，可删除android用户。 ③镜像大小为0时即自动分配，默认只有2GB，若修改大小则需重装系统。 4.3.安装CentOS系统在Linux Deploy主页，点击右上角选项图标，选择「安装」，按提示赋予ROOT权限即可开始安装。 首先是bootstrap/rootfs的安装（快），然后是bootstrap/centos的安装（慢），如上图1。经过软件包的Retrieving和Resolving Dependencies（如上图1、2），软件依赖分析完成后将列出待安装软件的信息（包名、架构、版本、仓库、大小），如上图3。 Transaction Summary列出待安装的57个安装包（Package）和87个依赖包（Dependent package），如下图1。随即开始软件包的下载（Downloading）、安装（Installing）和校验（Verifying），安装校验过程可以看到当前进度，如下图1、2。完成后将列出已安装的软件，如下图3。 接下来是一系列配置，关键是extra/ssh的安装和配置（几乎所有的失败都是这里的问题），如下图1。这项安装配置将会额外安装openssh-server，如下图2。安装完成后自动配置好extra/ssh则部署完成，如下图3。 注意到，在上图1中配置完core/locale本地化后界面语言就变成中文了，这得益于「引导设置」中的配置项「本地化」设置为zh_CN.UTF-8。 至此，CentOS安装部署完成，第一次部署需要安装的软件很多，因此输出的日志很多很杂，「&gt;&gt;&gt; deploy」和「&lt;&lt;&lt; deploy」之间的输出即安装部署时的日志，如果失败则可根据日志信息检查。初次安装花费5分钟左右的时间，这取决于网速，例如此处运行时间为[08:44:47]～[08:49:14]。 4.4.启动停止与使用同Debian，不再赘述。 5.附件必不可少的安卓软件： 名称 版本 大小 备注 BusyBox 1.31.1 5.21MB Github下载，1年未更新 Linux deploy 2.6.0 10.1MB Github下载，1年未更新 可选但强烈建议安装的安卓软件： 名称 版本 大小 备注 JuiceSSH 3.2.2 23.6MB JuiceSSH官网下载，最新版于2021-01-30 安装日志文件可作为安装参考、查错依据，若与以下日志不同则可对比来定位问题。 名称 Linux发行版 版本 大小 linux-debian.log Debian buster 41.0KB linux-centos.log CentOS 7 85.6KB","categories":[{"name":"miscellanea","slug":"miscellanea","permalink":"https://hwame.top/categories/miscellanea/"}],"tags":[{"name":"miscellanea","slug":"miscellanea","permalink":"https://hwame.top/tags/miscellanea/"}]},{"title":"让你的Windows更具生产力","slug":"make-your-windows-productive","date":"2021-09-04T15:45:56.000Z","updated":"2021-09-06T15:26:09.000Z","comments":true,"path":"20210904/make-your-windows-productive.html","link":"","permalink":"https://hwame.top/20210904/make-your-windows-productive.html","excerpt":"摘要：通过修改注册表的方式提升Windows使用体验、提高工作效率！","text":"摘要：通过修改注册表的方式提升Windows使用体验、提高工作效率！ 文章说明文章作者：鴻塵文章链接：https://hwame.top/20210904/make-your-windows-productive.html参考资料： 实例讲解映像劫持的使用技巧——通过映像劫持实现Notepad2替换记事本 win10右键菜单添加「用记事本打开文件」 Win10添加右键打开cmd和Powershell窗口 在Win10右键菜单中添加「复制路径」选项 Windows照片查看器-召回大法 1.替换系统记事本众所周知，Windows自带的记事本notepad及其简陋，有时候只想查看一下文件内容但又不想打开IDE，这时候一个简单的带语法高亮的记事本就派上用场了。 通过 映像劫持 实现将Notepad2替换系统自带的记事本。 说明①： Notepad2网上有很多版本，本人自用的【Notepad2】是仅有1.86M的单文件绿色版，所有配置 写死 到文件中，因此没有配置文件、没有主题文件、无法修改配置。说明②： Notepad2有些新的版本自带了「系统集成」的功能，可以一键替换，但我没有找到无需配置文件的单文件版，因此手动修改注册表。说明③： Notepad3支持的语法高亮更多，比如Markdown格式，奈何花里胡哨不在我的审美上。 参考文章： https://my.oschina.net/u/2304110/blog/419536 所谓「映像劫持」，就是Image File Execution Options，是CreateProcess函数中的一个功能，即在可执行程序运行时，Windows会先检测对应IFEO中的Debugger值，如果存在这个参数的话，就运行这个参数中指定的程序。 其实现原理为，修改Image File Execution Options键值后，在有notepad.exe运行请求的时候，就欺骗系统转而运行notepad2.exe，从而实现将原本系统默认的记事本改成了功能更为全面的Notepad2。 这种方式不但不需要修改文件关联，也无需修改系统文件，避免了以往的文件替换法导致的系统更新后就失效的问题。 具体步骤如下： 下载Notepad2.exe单文件，【阿里云盘】，【Github下载】，版权信息如下： 将其放在与原notepad.exe相同的位置，即C:\\Windows\\System32\\Notepad2.exe。尽管这一步非必须，但仍建议这么做。 Win+R运行输入regedit打开注册表，创建如下注册表项：计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\notepad.exe，如果无法修改，需要先右键取得权限。 在notepad.exe注册表项中，右键创建名为Debugger的字符串值（REG_SZ），如图： 将字符串值Debugger的数值数据修改为Notepad2.exe的完整路径，最后以 /z 参数结尾，即&quot;C:\\WINDOWS\\system32\\Notepad2.exe&quot; /z，如图： 至此文本文件用记事本打开即可，还可右键增加「用记事本打开」及图标，见下文。 2.右键用记事本打开上面已经将记事本替换成强大的Notepad2，但是一般情况下只有txt等文本文件才可直接用记事本打开。虽然可以右键选择打开方式，但未免太麻烦；那如果勾选「始终使用此应用打开xxx文件」，又会改变默认的打开方式，不符合我们的预期。例如bat文件双击运行，我们想用记事本打开查看内容就只能右键打开方式了。因此右键菜单增加「用记事本打开」也算是一个比较实用的提高生产力的功能了。 具体步骤如下： Win+R运行输入regedit打开注册表，创建如下注册表项：计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\*\\shell\\notepad，双击默认将数值数据修改为「用记事本打开」，如图： 我们也可以为右键菜单添加一个记事本图标。如上图，在notepad项下新建一个名为Icon的 字符串值 ，将其数值数据修改为Notepad2.exe的文件路径C:\\Windows\\System32\\notepad2.exe。 在notepad项下新建一个名为command的 项 （即子项），双击默认将数值数据修改为「notepad %1」，注意空格，如图： 3.右键打开命令行有时候我们需要在特定目录下打开命令行，通常会在开始菜单或运行中打开，此时路径一般为C:\\Users\\鴻塵或C:\\Windows\\System32，然后一层一层切换过去。 在右键菜单中添加「在此处打开命令行」，可以直接定位到当前文件夹，免去cd之苦。 本文打开命令行仅以普通用户权限，因为我的组策略已修改为「管理权限创建任务」，若有需要以管理员身份打开命令行，请移步参考文章。 具体步骤如下： 右键打开CMD Win+R运行输入regedit打开注册表，创建如下注册表项：计算机\\HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\OpenCmdHere，将「默认」字符串值的数值数据为「在此处打开命令行窗口」。此处项值和数值数据可随意。 在OpenCmdHere项下新建一个名为Icon的 字符串值 ，将其数值数据修改为cmd.exe的文件路径cmd.exe。 在OpenCmdHere项下新建一个名为command的 项 （即子项），双击默认将数值数据修改为「cmd.exe /s /k pushd &quot;%V&quot;」。 此处步骤与上文右键用记事本打开类似，简要截图如下： 右键打开PowerShell Win+R运行输入regedit打开注册表，创建如下注册表项：计算机\\HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\Powershell_Here，「默认」字符串值的数值数据为「在此处打开PowerShell」。此处项值和数值数据可随意。 在Powershell_Here项下新建一个名为Icon的 字符串值 ，将其数值数据修改为powershell.exe的文件路径powershell.exe。 在Powershell_Here项下新建一个名为command的 项 （即子项），双击默认将数值数据修改为「powershell.exe -noexit -command Set-Location &#39;%V&#39;」。 截图略。 说明： 增加图标时没有写文件的完整路径，因为路径已在环境变量中，故上文右键用记事本打开中设置图标同理可简写。 4.右键复制文件路径当我们需要用到某文件的绝对路径时，怎么获取该字符串呢？是先地址栏复制目录再复制文件名，还是文件属性的安全里面去复制对象名称？ 因此在右键菜单添加一个复制文件（夹）路径，也能提高生产力。 但是我不会告诉你，选中文件（夹）后按住Shift右键就有「复制为路径」的选项！所以这里修改注册表其实也是多此一举，但是有多少人知道这种「复制为路径」的方法呢？ 方法1.0来自吾爱破解论坛用户tmdgdx的评论，详见https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1374242&amp;page=1#pid36998334。1234567891011Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\Directory\\shell\\copypath]@=&quot;复制文件夹路径&quot;[HKEY_CLASSES_ROOT\\Directory\\shell\\copypath\\command]@=&quot;mshta vbscript:clipboarddata.setdata(\\&quot;text\\&quot;,\\&quot;%1\\&quot;)(close)&quot;[HKEY_CLASSES_ROOT\\*\\shell\\copypath]@=&quot;复制文件路径&quot;[HKEY_CLASSES_ROOT\\*\\shell\\copypath\\command]@=&quot;mshta vbscript:clipboarddata.setdata(\\&quot;text\\&quot;,\\&quot;%1\\&quot;)(close)&quot; 上述mshta这种方法有两个问题： ①复制exe等格式的文件时会有类似「是否运行xxx」的警告； ②复制链接例如快捷方式会复制源文件路径，而不是快捷方式本身的路径。 推荐使用在Win10右键菜单中添加「复制路径」选项中的方法2.0： 1234567891011Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\Allfilesystemobjects\\shell\\windows.copyaspath]&quot;CanonicalName&quot;=&quot;&#123;707C7BC6-685A-4A4D-A275-3966A5A3EFAA&#125;&quot;&quot;CommandStateHandler&quot;=&quot;&#123;3B1599F9-E00A-4BBF-AD3E-B3F99FA87779&#125;&quot;&quot;CommandStateSync&quot;=&quot;&quot;&quot;Description&quot;=&quot;@shell32.dll,-30336&quot;&quot;Icon&quot;=&quot;imageres.dll,-5302&quot;&quot;InvokeCommandOnSelection&quot;=dword:00000001&quot;MUIVerb&quot;=&quot;@shell32.dll,-30329&quot;&quot;VerbHandler&quot;=&quot;&#123;f3d06e7c-1e45-4a26-847e-f9fcdee59be0&#125;&quot;&quot;VerbName&quot;=&quot;copyaspath&quot; 其中&quot;Icon&quot;=&quot;imageres.dll,-5302&quot;可以改成4，换成文件夹风格图标，如图所示： 5.Windows照片查看器众所周知，Win10自带的「照片」极其难用，甚至可能需要安装第三方替代软件，这让我们不得不感叹还是Win7时代的「Windows照片查看器」最经典。 通过修改注册表的方式恢复「Windows照片查看器」，并且设置为默认。 具体步骤如下： Win+R运行输入regedit打开注册表，定位到如下注册表项：计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows Photo Viewer\\Capabilities\\FileAssociations。 在FileAssociations项下新建一个名为.jpg的 字符串值 ，将其数值数据修改为PhotoViewer.FileAssoc.Tiff。 同样新建其他图片后缀名的字符串值，例如.jpeg、.png、.gif、.bmp、.ico等，数值数据皆为PhotoViewer.FileAssoc.Tiff，添加完成后的注册表如图所示： 双击图片打开时选择「Windows照片查看器」并勾选「始终使用此应用打开.xxx文件」即可设置为默认方式。若已设置其他为默认，右键打开方式选择其他应用，即可设置默认。如图所示： 注意①： 并非所有格式的图片都能用「Windows照片查看器」打开，如.webp、.svg等。注意②： 新建的 字符串值 名称为图片扩展名，且有一个点.。","categories":[{"name":"miscellanea","slug":"miscellanea","permalink":"https://hwame.top/categories/miscellanea/"}],"tags":[{"name":"miscellanea","slug":"miscellanea","permalink":"https://hwame.top/tags/miscellanea/"}]},{"title":"MongoDB聚合示例","slug":"mongodb-aggregation-examples","date":"2021-08-14T15:44:47.000Z","updated":"2021-09-30T16:40:26.000Z","comments":true,"path":"20210814/mongodb-aggregation-examples.html","link":"","permalink":"https://hwame.top/20210814/mongodb-aggregation-examples.html","excerpt":"","text":"文章说明文章作者：鴻塵文章链接：https://hwame.top/20210814/mongodb-aggregation-examples.html参考资料： 聚合示例来源：Practical MongoDB Aggregations（by Paul Done@TheDonester） Ebook源码：Github @pkdone MongoDB在线运行：MongoDB Web Shell 温馨提示：测试数据可直接复制，方便生成数据；运行结果以图片形式展示，可以「点击图片」或「将图片拖曳到新标签页」来查看大图，从而获取更佳的浏览体验。 对MongoDB中聚合操作的理解和熟悉，需要配合大量例子，Practical MongoDB Aggregations Book中提供了很多有助于理解的例子，但原文是英文版的且有一定概率无法访问，故在此记录下学习过程中对原文的翻译。 说明：本文仅作为聚合示例，由于篇幅限制，对于数据库的指定及索引的创建都进行删减，并且也不执行explain。 1.基础(1)TopN查询 您想在由人组成的集合中查询，以找到职业为工程师的三个最年轻的人，按年龄从小到大排序。 此示例是本文中唯一一个可以以完全使用MQL实现的示例，同时也作为MQL和聚合管道之间的一个有用比较。 测试数据如下：12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; &quot;person_id&quot;: &quot;6392529400&quot;, &quot;firstname&quot;: &quot;Elise&quot;, &quot;lastname&quot;: &quot;Smith&quot;, &quot;dateofbirth&quot;: ISODate(&quot;1972-01-13T09:32:07Z&quot;), &quot;vocation&quot;: &quot;ENGINEER&quot;, &quot;address&quot;: &#123; &quot;number&quot;: 5625, &quot;street&quot;: &quot;Tipa Circle&quot;, &quot;city&quot;: &quot;Wojzinmoj&quot;&#125;,&#125;,&#123; &quot;person_id&quot;: &quot;1723338115&quot;, &quot;firstname&quot;: &quot;Olive&quot;, &quot;lastname&quot;: &quot;Ranieri&quot;, &quot;dateofbirth&quot;: ISODate(&quot;1985-05-12T23:14:30Z&quot;), &quot;gender&quot;: &quot;FEMALE&quot;, &quot;vocation&quot;: &quot;ENGINEER&quot;, &quot;address&quot;: &#123; &quot;number&quot;: 9303, &quot;street&quot;: &quot;Mele Circle&quot;, &quot;city&quot;: &quot;Tobihbo&quot;&#125;,&#125;,&#123; &quot;person_id&quot;: &quot;8732762874&quot;, &quot;firstname&quot;: &quot;Toni&quot;, &quot;lastname&quot;: &quot;Jones&quot;, &quot;dateofbirth&quot;: ISODate(&quot;1991-11-23T16:53:56Z&quot;), &quot;vocation&quot;: &quot;POLITICIAN&quot;, &quot;address&quot;: &#123; &quot;number&quot;: 1, &quot;street&quot;: &quot;High Street&quot;, &quot;city&quot;: &quot;Upper Abbeywoodington&quot;&#125;&#125;,&#123; &quot;person_id&quot;: &quot;7363629563&quot;, &quot;firstname&quot;: &quot;Bert&quot;, &quot;lastname&quot;: &quot;Gooding&quot;, &quot;dateofbirth&quot;: ISODate(&quot;1941-04-07T22:11:52Z&quot;), &quot;vocation&quot;: &quot;FLORIST&quot;, &quot;address&quot;: &#123; &quot;number&quot;: 13, &quot;street&quot;: &quot;Upper Bold Road&quot;, &quot;city&quot;: &quot;Redringtonville&quot;&#125;&#125;,&#123; &quot;person_id&quot;: &quot;1029648329&quot;, &quot;firstname&quot;: &quot;Sophie&quot;, &quot;lastname&quot;: &quot;Celements&quot;, &quot;dateofbirth&quot;: ISODate(&quot;1959-07-06T17:35:45Z&quot;), &quot;vocation&quot;: &quot;ENGINEER&quot;, &quot;address&quot;: &#123; &quot;number&quot;: 5, &quot;street&quot;: &quot;Innings Close&quot;, &quot;city&quot;: &quot;Basilbridge&quot;&#125;&#125;,&#123; &quot;person_id&quot;: &quot;7363626383&quot;, &quot;firstname&quot;: &quot;Carl&quot;, &quot;lastname&quot;: &quot;Simmons&quot;, &quot;dateofbirth&quot;: ISODate(&quot;1998-12-26T13:13:55Z&quot;), &quot;vocation&quot;: &quot;ENGINEER&quot;, &quot;address&quot;: &#123; &quot;number&quot;: 187, &quot;street&quot;: &quot;Hillside Road&quot;, &quot;city&quot;: &quot;Kenningford&quot;&#125;&#125; 聚合管道定义如下：123456var pipeline = [ &#123;&quot;$match&quot;: &#123;&quot;vocation&quot;: &quot;ENGINEER&quot;,&#125;&#125;, &#123;&quot;$sort&quot;: &#123;&quot;dateofbirth&quot;: -1,&#125;&#125;, &#123;&quot;$limit&quot;: 3&#125;, &#123;&quot;$unset&quot;: [&quot;_id&quot;, &quot;vocation&quot;, &quot;address&quot;,]&#125;,]; 执行聚合操作后应该返回三个文档，代表三个最年轻的工程师（按年龄从小到大排序），省略每个人的_id或address属性，如图所示： Index Use. A basic aggregation pipeline, where if many records belong to the collection, a compound index for vocation + dateofbirth should exist to enable the database to fully optimise the execution of the pipeline combining the filter of the $match stage with the sort from the sort stage and the limit of the limit stage. Unset Use. An $unset stage is used rather than a $project stage. This enables the pipeline to avoid being verbose. More importantly, it means the pipeline does not have to be modified if a new field appears in documents added in the future (for example, see the gender field that appears in only Olive’s record). MQL Similarity. For reference, the MQL equivalent for you to achieve the same result is shown below (you can try this in the Shell): 12345db.persons.find( &#123;&quot;vocation&quot;: &quot;ENGINEER&quot;&#125;, &#123;&quot;_id&quot;: 0, &quot;vocation&quot;: 0, &quot;address&quot;: 0&#125;, ).sort( &#123;&quot;dateofbirth&quot;: -1&#125; ).limit(3); (2)分组汇总 您想要生成一份报告以显示每个客户在 2020 年购买的商品。 您将按客户对个人订单记录进行分组，捕获每个客户的「首单日期」、「订单数量」、「订单总价」和一个按日期排序的订单项目列表。 测试数据如下，orders集合由3个不同客户在2019-2021年间的9个订单组成： 123456789&#123;&quot;customer_id&quot;: &quot;elise_smith@myemail.com&quot;, &quot;orderdate&quot;: ISODate(&quot;2020-05-30T08:35:52Z&quot;), &quot;value&quot;: NumberDecimal(&quot;231.43&quot;)&#125;,&#123;&quot;customer_id&quot;: &quot;elise_smith@myemail.com&quot;, &quot;orderdate&quot;: ISODate(&quot;2020-01-13T09:32:07Z&quot;), &quot;value&quot;: NumberDecimal(&quot;99.99&quot;)&#125;,&#123;&quot;customer_id&quot;: &quot;oranieri@warmmail.com&quot;, &quot;orderdate&quot;: ISODate(&quot;2020-01-01T08:25:37Z&quot;), &quot;value&quot;: NumberDecimal(&quot;63.13&quot;)&#125;,&#123;&quot;customer_id&quot;: &quot;tj@wheresmyemail.com&quot;, &quot;orderdate&quot;: ISODate(&quot;2019-05-28T19:13:32Z&quot;), &quot;value&quot;: NumberDecimal(&quot;2.01&quot;)&#125;, &#123;&quot;customer_id&quot;: &quot;tj@wheresmyemail.com&quot;, &quot;orderdate&quot;: ISODate(&quot;2020-11-23T22:56:53Z&quot;), &quot;value&quot;: NumberDecimal(&quot;187.99&quot;)&#125;,&#123;&quot;customer_id&quot;: &quot;tj@wheresmyemail.com&quot;, &quot;orderdate&quot;: ISODate(&quot;2020-08-18T23:04:48Z&quot;), &quot;value&quot;: NumberDecimal(&quot;4.59&quot;)&#125;,&#123;&quot;customer_id&quot;: &quot;elise_smith@myemail.com&quot;, &quot;orderdate&quot;: ISODate(&quot;2020-12-26T08:55:46Z&quot;), &quot;value&quot;: NumberDecimal(&quot;48.50&quot;)&#125;,&#123;&quot;customer_id&quot;: &quot;tj@wheresmyemail.com&quot;, &quot;orderdate&quot;: ISODate(&quot;2021-02-29T07:49:32Z&quot;), &quot;value&quot;: NumberDecimal(&quot;1024.89&quot;)&#125;,&#123;&quot;customer_id&quot;: &quot;elise_smith@myemail.com&quot;, &quot;orderdate&quot;: ISODate(&quot;2020-10-03T13:49:44Z&quot;), &quot;value&quot;: NumberDecimal(&quot;102.24&quot;)&#125; 聚合管道定义如下：1234567891011121314151617181920var pipeline = [ &#123;&quot;$match&quot;: &#123; &quot;orderdate&quot;: &#123;&quot;$gte&quot;: ISODate(&quot;2020-01-01T00:00:00Z&quot;), &quot;$lt&quot;: ISODate(&quot;2021-01-01T00:00:00Z&quot;), &#125;, &#125;&#125;, // 按订单日期升序，需要选择下面的「first_purchase_date」 &#123;&quot;$sort&quot;: &#123;&quot;orderdate&quot;: 1, &#125;&#125;, &#123;&quot;$group&quot;: &#123; &quot;_id&quot;: &quot;$customer_id&quot;, &quot;first_purchase_date&quot;: &#123;&quot;$first&quot;: &quot;$orderdate&quot;&#125;, &quot;total_value&quot;: &#123;&quot;$sum&quot;: &quot;$value&quot;&#125;, &quot;total_orders&quot;: &#123;&quot;$sum&quot;: 1&#125;, &quot;orders&quot;: &#123;&quot;$push&quot;: &#123;&quot;orderdate&quot;: &quot;$orderdate&quot;, &quot;value&quot;: &quot;$value&quot;&#125;&#125;, &#125;&#125;, &#123;&quot;$sort&quot;: &#123;&quot;first_purchase_date&quot;: 1, &#125;&#125;, &#123;&quot;$set&quot;: &#123;&quot;customer_id&quot;: &quot;$_id&quot;, &#125;&#125;, &#123;&quot;$unset&quot;: [&quot;_id&quot;, ]&#125;, ]; 执行聚合操作后应该返回代表三个客户的三个文档，文档分别包含了2020年首次购买日期、订单总价值、订单数量，以及订单详情列表。 Note, the order of fields shown for each document may vary. Double Sort Use. It is necessary to perform a $sort on the order date both before and after the $group stage. The $sort before the $group is required because the $group stage uses a $first group accumulator to capture just the first order’s orderdate value for each grouped customer. The $sort after the $group is required because the act of having just grouped on customer ID will mean that the records are no longer sorted by purchase date for the records coming out of the $group stage. Renaming Group. Towards the end of the pipeline, you will see what is a typical pattern for pipelines that use $group, consisting of a combination of $set+$unset stages, to essentially take the group’s key (which is always called _id) and substitute it with a more meaningful name (customer_id). Lossless Decimals. You may notice the pipeline uses a NumberDecimal() function to ensure the order amounts in the inserted records are using a lossless decimal type, IEEE 754 decimal128. In this example, if you use a JSON float or double type instead, the order totals will suffer from a loss of precision. For instance, for the customer elise_smith@myemail.com, if you use a double type, the total_value result will have the value shown in the second line below, rather than the first line: 12345// 使用decimal128类型获得的期望结果total_value: NumberDecimal(&#x27;482.16&#x27;)// 使用float或double类型获得的结果total_value: 482.15999999999997 (3)解包数组及分组 您想要生成零售报告以列出已售出「昂贵产品」（价值超过 15 美元）的总价值和数量。 数据源是一个商店订单列表，其中每个订单都包含一个购买的产品集。 12345678910111213141516171819202122232425262728&#123; &quot;order_id&quot;: 6363763262239, &quot;products&quot;: [ &#123;&quot;prod_id&quot;: &quot;abc12345&quot;, &quot;name&quot;: &quot;Asus Laptop&quot;, &quot;price&quot;: NumberDecimal(&quot;431.43&quot;), &#125;, &#123;&quot;prod_id&quot;: &quot;def45678&quot;, &quot;name&quot;: &quot;Karcher Hose Set&quot;, &quot;price&quot;: NumberDecimal(&quot;22.13&quot;), &#125;, ],&#125;,&#123; &quot;order_id&quot;: 1197372932325, &quot;products&quot;: [ &#123;&quot;prod_id&quot;: &quot;abc12345&quot;, &quot;name&quot;: &quot;Asus Laptop&quot;, &quot;price&quot;: NumberDecimal(&quot;429.99&quot;), &#125;, ],&#125;,&#123; &quot;order_id&quot;: 9812343774839, &quot;products&quot;: [ &#123;&quot;prod_id&quot;: &quot;pqr88223&quot;, &quot;name&quot;: &quot;Morphy Richardds Food Mixer&quot;, &quot;price&quot;: NumberDecimal(&quot;431.43&quot;), &#125;, &#123;&quot;prod_id&quot;: &quot;def45678&quot;, &quot;name&quot;: &quot;Karcher Hose Set&quot;, &quot;price&quot;: NumberDecimal(&quot;21.78&quot;), &#125;, ],&#125;,&#123; &quot;order_id&quot;: 4433997244387, &quot;products&quot;: [ &#123;&quot;prod_id&quot;: &quot;def45678&quot;, &quot;name&quot;: &quot;Karcher Hose Set&quot;, &quot;price&quot;: NumberDecimal(&quot;23.43&quot;), &#125;, &#123;&quot;prod_id&quot;: &quot;jkl77336&quot;, &quot;name&quot;: &quot;Picky Pencil Sharpener&quot;, &quot;price&quot;: NumberDecimal(&quot;0.67&quot;), &#125;, &#123;&quot;prod_id&quot;: &quot;xyz11228&quot;, &quot;name&quot;: &quot;Russell Hobbs Chrome Kettle&quot;, &quot;price&quot;: NumberDecimal(&quot;15.76&quot;), &#125;, ],&#125;, 聚合管道定义如下： 1234567891011121314151617var pipeline = [ // 从每个订单的products中解包每个product，作为一个新的单独记录 &#123;&quot;$unwind&quot;: &#123;&quot;path&quot;: &quot;$products&quot;, &#125;&#125;, &#123;&quot;$match&quot;: &#123;&quot;products.price&quot;: &#123; &quot;$gt&quot;: NumberDecimal(&quot;15.00&quot;), &#125;,&#125;&#125;, // 按产品类型分组，统计每个产品的总价和数量 &#123;&quot;$group&quot;: &#123; &quot;_id&quot;: &quot;$products.prod_id&quot;, &quot;product&quot;: &#123;&quot;$first&quot;: &quot;$products.name&quot;&#125;, &quot;total_value&quot;: &#123;&quot;$sum&quot;: &quot;$products.price&quot;&#125;, &quot;quantity&quot;: &#123;&quot;$sum&quot;: 1&#125;, &#125;&#125;, &#123;&quot;$set&quot;: &#123;&quot;product_id&quot;: &quot;$_id&quot;, &#125;&#125;, &#123;&quot;$unset&quot;: [&quot;_id&quot;,]&#125;,]; 执行聚合操作后应该返回4个文档，代表客户订单中出现次数最多的4个仅有的「昂贵产品」，每个文档包括了产品的总订单价值和数量，如下所示： Note, the order of fields shown for each document may vary. Unwinding Arrays. The $unwind stage is a powerful concept, although often unfamiliar to many developers initially. Distilled down, it does one simple thing: it generates a new record for each element in an array field of every input document. If a source collection has 3 documents and each document contains an array of 4 elements, then performing an $unwind on each record’s array field produces 12 records (3 x 4). Introducing A Partial Match. The current example pipeline scans all documents in the collection and then filters out unpacked products where price &gt; 15.00. If the pipeline executed this filter as the first stage, it would incorrectly produce some result product records with a value of 15 dollars or less. This would be the case for an order composed of both inexpensive and expensive products. However, you can still improve the pipeline by including an additional “partial match” filter at the start of the pipeline for products valued at over 15 dollars. The aggregation could leverage an index (on products.price), resulting in a partial rather than full collection scan. This extra filter stage is beneficial if the input data set is large and many customer orders are for inexpensive items only. This approach is described in the chapter Pipeline Performance Considerations. (4)列表去重 您想在persons集合中查询，其中每个文档都包含其所说的一种或多种语言。 查询结果应该是按字母顺序排序的去重的语言列表，开发人员随后可以使用它来填充用户界面下拉小部件中的值列表。 此示例等效于SQL中的SELECT DISTINCT语句。 123456789&#123;&quot;firstname&quot;: &quot;Elise&quot;, &quot;lastname&quot;: &quot;Smith&quot;, &quot;vocation&quot;: &quot;ENGINEER&quot;, &quot;language&quot;: &quot;English&quot;,&#125;,&#123;&quot;firstname&quot;: &quot;Olive&quot;, &quot;lastname&quot;: &quot;Ranieri&quot;, &quot;vocation&quot;: &quot;ENGINEER&quot;, &quot;language&quot;: [&quot;Italian&quot;, &quot;English&quot;],&#125;,&#123;&quot;firstname&quot;: &quot;Toni&quot;, &quot;lastname&quot;: &quot;Jones&quot;, &quot;vocation&quot;: &quot;POLITICIAN&quot;, &quot;language&quot;: [&quot;English&quot;, &quot;Welsh&quot;],&#125;,&#123;&quot;firstname&quot;: &quot;Bert&quot;, &quot;lastname&quot;: &quot;Gooding&quot;, &quot;vocation&quot;: &quot;FLORIST&quot;, &quot;language&quot;: &quot;English&quot;,&#125;,&#123;&quot;firstname&quot;: &quot;Sophie&quot;, &quot;lastname&quot;: &quot;Celements&quot;, &quot;vocation&quot;: &quot;ENGINEER&quot;, &quot;language&quot;: [&quot;Gaelic&quot;, &quot;English&quot;],&#125;,&#123;&quot;firstname&quot;: &quot;Carl&quot;, &quot;lastname&quot;: &quot;Simmons&quot;, &quot;vocation&quot;: &quot;ENGINEER&quot;, &quot;language&quot;: &quot;English&quot;,&#125;,&#123;&quot;firstname&quot;: &quot;Diego&quot;, &quot;lastname&quot;: &quot;Lopez&quot;, &quot;vocation&quot;: &quot;CHEF&quot;, &quot;language&quot;: &quot;Spanish&quot;,&#125;,&#123;&quot;firstname&quot;: &quot;Helmut&quot;, &quot;lastname&quot;: &quot;Schneider&quot;, &quot;vocation&quot;: &quot;NURSE&quot;, &quot;language&quot;: &quot;German&quot;,&#125;,&#123;&quot;firstname&quot;: &quot;Valerie&quot;, &quot;lastname&quot;: &quot;Dubois&quot;, &quot;vocation&quot;: &quot;SCIENTIST&quot;, &quot;language&quot;: &quot;French&quot;,&#125;, 聚合管道定义如下：123456var pipeline = [ &#123;&quot;$unwind&quot;: &#123;&quot;path&quot;: &quot;$language&quot;&#125;&#125;, // 解包language字段，该字段为数组或单个值 &#123;&quot;$group&quot;: &#123;&quot;_id&quot;: &quot;$language&quot;&#125;&#125;, &#123;&quot;$sort&quot;: &#123;&quot;_id&quot;: 1&#125;&#125;, &#123;&quot;$set&quot;: &#123;&quot;language&quot;: &quot;$_id&quot;, &quot;_id&quot;: &quot;$$REMOVE&quot;&#125;&#125;,]; 执行聚合操作后应该返回按字母序的7个文档，代表不同的7种语言，如下所示： Unwinding Non-Arrays. In some of the example’s documents, the language field is an array, whilst in others, the field is a simple string value. The $unwind stage can seamlessly deal with both field types and does not throw an error if it encounters a non-array value. Instead, if the field is not an array, the stage outputs a single record using the field’s string value in the same way it would if the field was an array containing just one element. If you are sure the field in every document will only ever be a simple field rather than an array, you can omit this first stage ($unwind) from the pipeline. Group ID Provides Unique Values. By grouping on a single field and not accumulating other fields such as total or count, the output of a $group stage is just every unique group’s ID, which in this case is every unique language. Unset Alternative. For the pipeline to be consistent with earlier examples in this book, it could have included an additional $unset stage to exclude the _id field. However, partly to show another way, the example pipeline used here marks the _id field for exclusion in the $set stage by being assigned the $$REMOVE variable. 2.数据联结(1)一对一联结 您想要生成一个报告来列出 2020 年所有的购买情况，显示每个订单的产品名称和类别，而不是产品ID。 为此您需要获取客户「订单集合orders」，并将每个订单记录与「产品集合products」中的对应的产品相联结。 两个集合之间存在「多对一many:1」关系，因此在将订单与产品匹配时会产生「一对一1:1」的联结。联结将根据产品的id在双方之间使用单个字段比较。 数据包括2019-2021年间的产品products和订单orders两个集合，如下所示。 12345678910111213141516171819202122// 集合products&#123; &quot;id&quot;: &quot;a1b2c3d4&quot;, &quot;name&quot;: &quot;Asus Laptop&quot;, &quot;category&quot;: &quot;ELECTRONICS&quot;, &quot;description&quot;: &quot;Good value laptop for students&quot;,&#125;, &#123; &quot;id&quot;: &quot;z9y8x7w6&quot;, &quot;name&quot;: &quot;The Day Of The Triffids&quot;, &quot;category&quot;: &quot;BOOKS&quot;, &quot;description&quot;: &quot;Classic post-apocalyptic novel&quot;,&#125;, &#123; &quot;id&quot;: &quot;ff11gg22hh33&quot;, &quot;name&quot;: &quot;Morphy Richardds Food Mixer&quot;, &quot;category&quot;: &quot;KITCHENWARE&quot;, &quot;description&quot;: &quot;Luxury mixer turning good cakes into great&quot;,&#125;, &#123; &quot;id&quot;: &quot;pqr678st&quot;, &quot;name&quot;: &quot;Karcher Hose Set&quot;, &quot;category&quot;: &quot;GARDEN&quot;, &quot;description&quot;: &quot;Hose + nosels + winder for tidy storage&quot;,&#125; 12345678910111213141516171819202122// 集合orders&#123; &quot;customer_id&quot;: &quot;elise_smith@myemail.com&quot;, &quot;orderdate&quot;: ISODate(&quot;2020-05-30T08:35:52Z&quot;), &quot;product_id&quot;: &quot;a1b2c3d4&quot;, &quot;value&quot;: NumberDecimal(&quot;431.43&quot;),&#125;, &#123; &quot;customer_id&quot;: &quot;tj@wheresmyemail.com&quot;, &quot;orderdate&quot;: ISODate(&quot;2019-05-28T19:13:32Z&quot;), &quot;product_id&quot;: &quot;z9y8x7w6&quot;, &quot;value&quot;: NumberDecimal(&quot;5.01&quot;),&#125;, &#123; &quot;customer_id&quot;: &quot;oranieri@warmmail.com&quot;, &quot;orderdate&quot;: ISODate(&quot;2020-01-01T08:25:37Z&quot;), &quot;product_id&quot;: &quot;ff11gg22hh33&quot;, &quot;value&quot;: NumberDecimal(&quot;63.13&quot;),&#125;, &#123; &quot;customer_id&quot;: &quot;jjones@tepidmail.com&quot;, &quot;orderdate&quot;: ISODate(&quot;2020-12-26T08:55:46Z&quot;), &quot;product_id&quot;: &quot;a1b2c3d4&quot;, &quot;value&quot;: NumberDecimal(&quot;429.65&quot;),&#125;, 聚合管道定义如下： 12345678910111213141516171819202122var pipeline = [ &#123;&quot;$match&quot;: &#123;&quot;orderdate&quot;: &#123; &quot;$gte&quot;: ISODate(&quot;2020-01-01T00:00:00Z&quot;), &quot;$lt&quot;: ISODate(&quot;2021-01-01T00:00:00Z&quot;), &#125; &#125;&#125;, // Join &quot;product_id&quot; in orders collection to &quot;id&quot; in products&quot; collection &#123;&quot;$lookup&quot;: &#123; &quot;from&quot;: &quot;products&quot;, &quot;localField&quot;: &quot;product_id&quot;, &quot;foreignField&quot;: &quot;id&quot;, &quot;as&quot;: &quot;product_mapping&quot;, &#125;&#125;, // For this data model, will always be 1 record in right-side // of join, so take 1st joined array element &#123;&quot;$set&quot;: &#123;&quot;product_mapping&quot;: &#123;&quot;$first&quot;: &quot;$product_mapping&quot;&#125;, &#125;&#125;, // Extract the joined embeded fields into top level fields &#123;&quot;$set&quot;: &#123; &quot;product_name&quot;: &quot;$product_mapping.name&quot;, &quot;product_category&quot;: &quot;$product_mapping.category&quot;, &#125;&#125;, &#123;&quot;$unset&quot;: [&quot;_id&quot;, &quot;product_id&quot;, &quot;product_mapping&quot;, ]&#125;, ]; 执行聚合操作后应该返回代表2020年的3个订单文档，但每个订单的product_id字段替换成了两个新查找的字段product_name和product_category，如下所示。 Single Field Match. The pipeline includes a $lookup join between a single field from each collection. For an illustration of performing a join based on two or more matching fields, see the Multi-Field Join &amp; One-to-Many example. First Element Assumption. In this particular data model example, the join between the two collections is 1:1. Therefore the returned array of joined elements coming out of the $lookup stage always contains precisely one array element. As a result, the pipeline extracts the data from this first array element only, using the $first operator. For an illustration of performing a 1:many join instead, see the Multi-Field Join &amp; One-to-Many example. (2)多字段联结及一对多 您想要生成一份报告，列出2020年每种产品所生成的所有订单。 为此，您需要将商店的「产品集合products」中的每个产品product，与产品对应的订单order（订单位于orders集合）相联结。 基于每侧两个字段的匹配，两个集合之间存在「一对多1:many」的关系。 联结需要使用两个公共字段（product_name和product_variation），而不是像product_id（此数据集中不存在该字段）这样的单个字段。 注意：执行一对多1:many的联结并不强制要求在每一侧通过多个字段进行联结。然而在这个例子中，在一个地方展示这两个方面被认为是有益的。 数据包括2019-2021年间的产品products和订单orders两个集合，如下所示。 1234567891011121314151617181920212223242526272829303132// 集合products&#123; &quot;name&quot;: &quot;Asus Laptop&quot;, &quot;variation&quot;: &quot;Ultra HD&quot;, &quot;category&quot;: &quot;ELECTRONICS&quot;, &quot;description&quot;: &quot;Great for watching movies&quot;,&#125;, &#123; &quot;name&quot;: &quot;Asus Laptop&quot;, &quot;variation&quot;: &quot;Normal Display&quot;, &quot;category&quot;: &quot;ELECTRONICS&quot;, &quot;description&quot;: &quot;Good value laptop for students&quot;,&#125;, &#123; &quot;name&quot;: &quot;The Day Of The Triffids&quot;, &quot;variation&quot;: &quot;1st Edition&quot;, &quot;category&quot;: &quot;BOOKS&quot;, &quot;description&quot;: &quot;Classic post-apocalyptic novel&quot;,&#125;, &#123; &quot;name&quot;: &quot;The Day Of The Triffids&quot;, &quot;variation&quot;: &quot;2nd Edition&quot;, &quot;category&quot;: &quot;BOOKS&quot;, &quot;description&quot;: &quot;Classic post-apocalyptic novel&quot;,&#125;, &#123; &quot;name&quot;: &quot;Morphy Richards Food Mixer&quot;, &quot;variation&quot;: &quot;Deluxe&quot;, &quot;category&quot;: &quot;KITCHENWARE&quot;, &quot;description&quot;: &quot;Luxury mixer turning good cakes into great&quot;,&#125;, &#123; &quot;name&quot;: &quot;Karcher Hose Set&quot;, &quot;variation&quot;: &quot;Full Monty&quot;, &quot;category&quot;: &quot;GARDEN&quot;, &quot;description&quot;: &quot;Hose + nosels + winder for tidy storage&quot;,&#125; 123456789101112131415161718// 集合orders&#123; &quot;customer_id&quot;: &quot;elise_smith@myemail.com&quot;, &quot;orderdate&quot;: ISODate(&quot;2020-05-30T08:35:52Z&quot;), &quot;product_name&quot;: &quot;Asus Laptop&quot;, &quot;product_variation&quot;: &quot;Normal Display&quot;, &quot;value&quot;: NumberDecimal(&quot;431.43&quot;),&#125;, &#123; &quot;customer_id&quot;: &quot;tj@wheresmyemail.com&quot;, &quot;orderdate&quot;: ISODate(&quot;2019-05-28T19:13:32Z&quot;), &quot;product_name&quot;: &quot;The Day Of The Triffids&quot;, &quot;product_variation&quot;: &quot;2nd Edition&quot;, &quot;value&quot;: NumberDecimal(&quot;5.01&quot;),&#125;, &#123; &quot;customer_id&quot;: &quot;oranieri@warmmail.com&quot;, &quot;orderdate&quot;: ISODate(&quot;2020-01-01T08:25:37Z&quot;), &quot;product_name&quot;: &quot;Morphy Richards Food Mixer&quot;, &quot;product_variation&quot;: &quot;Deluxe&quot;, &quot;value&quot;: NumberDecimal(&quot;63.13&quot;),&#125;, &#123; &quot;customer_id&quot;: &quot;jjones@tepidmail.com&quot;, &quot;orderdate&quot;: ISODate(&quot;2020-12-26T08:55:46Z&quot;), &quot;product_name&quot;: &quot;Asus Laptop&quot;, &quot;product_variation&quot;: &quot;Normal Display&quot;, &quot;value&quot;: NumberDecimal(&quot;429.65&quot;),&#125; 聚合管道定义如下： 1234567891011121314151617181920212223242526272829303132var pipeline = [ // 将产品集合中的 2 个字段连接到订单集合中的 2 个字段 &#123;&quot;$lookup&quot;: &#123; &quot;from&quot;: &quot;orders&quot;, &quot;let&quot;: &#123;&quot;prdname&quot;: &quot;$name&quot;, &quot;prdvartn&quot;: &quot;$variation&quot;, &#125;, // Embedded pipeline to control how the join is matched &quot;pipeline&quot;: [ // Join by two fields in each side &#123;&quot;$match&quot;: &#123;&quot;$expr&quot;: &#123;&quot;$and&quot;: [ &#123;&quot;$eq&quot;: [&quot;$product_name&quot;, &quot;$$prdname&quot;]&#125;, &#123;&quot;$eq&quot;: [&quot;$product_variation&quot;, &quot;$$prdvartn&quot;]&#125;, ]&#125;, &#125;, &#125;, // Match only orders made in 2020 &#123;&quot;$match&quot;: &#123;&quot;orderdate&quot;: &#123; &quot;$gte&quot;: ISODate(&quot;2020-01-01T00:00:00Z&quot;), &quot;$lt&quot;: ISODate(&quot;2021-01-01T00:00:00Z&quot;), &#125; &#125;&#125;, // Exclude some unwanted fields from the right side of the join &#123;&quot;$unset&quot;: [&quot;_id&quot;, &quot;product_name&quot;, &quot;product_variation&quot;, ]&#125;, ], as: &quot;orders&quot;, &#125;&#125;, // Only show products that have at least one order &#123;&quot;$match&quot;: &#123;&quot;orders&quot;: &#123;&quot;$ne&quot;: []&#125;,&#125;&#125;, &#123;&quot;$unset&quot;: [&quot;_id&quot;,]&#125;, ]; 执行聚合操作后应该返回2个文档，代表 2020 年有一个或多个订单的两个产品，每个产品对应的订单以数组形式展示，如下所示。 Multiple Join Fields. To perform a join of two or more fields between the two collections, you need to use a let parameter rather than specifying the localField and foreignField parameters used in a single field join. With a let parameter, you bind multiple fields from the first collection into variables ready to be used in the joining process. You use an embedded pipeline inside the $lookup stage to match the bind variables with fields in the second collection’s records. In this instance, because the $expr operator performs an equality comparison specifically (as opposed to a range comparison), the aggregation runtime can employ an appropriate index for this match. Reducing Array Content. The presence of an embedded pipeline in the $lookup stage provides an opportunity to filter out three unwanted fields brought in from the second collection. Instead, you could use an $unset stage later in the top-level pipeline to project out these unwanted array elements. If you need to perform more complex array content filtering rules, you can use the approach described in section 2. Avoid Unwinding &amp; Regrouping Documents Just To Process Array Elements“ of the Pipeline Performance Considerations chapter. 3.数据类型转换(1)强类型转换 一组零售订单retail orders已被某三方机构导入MongoDB集合中，但是所有数据类型都丢失了，因此所有字段值被存储为字符串形式。 您想为所有文档重新建立正确的数据，并将它们复制到一个新的「清理过的」集合中。您可以在聚合管道中包含该类型的转换逻辑，因为您知道每个字段在原始记录中的结构类型。 与本文中的大多数示例不同，聚合管道将其输出写入一个集合，而不是将结果流式地返回给调用的应用程序。 订单集合orders包含三个订单文档，其中每个订单只有字符串形式的文本字段（注意，第二个文档有意缺少further_info子文档中的reported字段），如下所示。 12345678910111213141516&#123; &quot;customer_id&quot;: &quot;elise_smith@myemail.com&quot;, &quot;order_date&quot;: &quot;2020-05-30T08:35:52&quot;, &quot;value&quot;: &quot;231.43&quot;, &quot;further_info&quot;: &#123;&quot;item_qty&quot;: &quot;3&quot;, &quot;reported&quot;: &quot;false&quot;,&#125;,&#125;, &#123; &quot;customer_id&quot;: &quot;oranieri@warmmail.com&quot;, &quot;order_date&quot;: &quot;2020-01-01T08:25:37&quot;, &quot;value&quot;: &quot;63.13&quot;, &quot;further_info&quot;: &#123;&quot;item_qty&quot;: &quot;2&quot;,&#125;,&#125;, &#123; &quot;customer_id&quot;: &quot;tj@wheresmyemail.com&quot;, &quot;order_date&quot;: &quot;2019-05-28T19:13:32&quot;, &quot;value&quot;: &quot;2.01&quot;, &quot;further_info&quot;: &#123;&quot;item_qty&quot;: &quot;1&quot;, &quot;reported&quot;: &quot;true&quot;, &#125;,&#125; 聚合管道定义如下： 123456789101112131415161718var pipeline = [ // 将字符串转换为所需类型 &#123;&quot;$set&quot;: &#123; &quot;order_date&quot;: &#123;&quot;$toDate&quot;: &quot;$order_date&quot;&#125;, &quot;value&quot;: &#123;&quot;$toDecimal&quot;: &quot;$value&quot;&#125;, &quot;further_info.item_qty&quot;: &#123;&quot;$toInt&quot;: &quot;$further_info.item_qty&quot;&#125;, &quot;further_info.reported&quot;: &#123;&quot;$switch&quot;: &#123; &quot;branches&quot;: [ &#123;&quot;case&quot;: &#123;&quot;$eq&quot;: [&#123;&quot;$toLower&quot;: &quot;$further_info.reported&quot;&#125;, &quot;true&quot;]&#125;, &quot;then&quot;: true&#125;, &#123;&quot;case&quot;: &#123;&quot;$eq&quot;: [&#123;&quot;$toLower&quot;: &quot;$further_info.reported&quot;&#125;, &quot;false&quot;]&#125;, &quot;then&quot;: false&#125;, ], &quot;default&quot;: &#123;&quot;$ifNull&quot;: [&quot;$further_info.reported&quot;, &quot;$$REMOVE&quot;]&#125;, &#125;&#125;, &#125;&#125;, // 输出到未分片（unsharded）或分片（sharded）的集合 &#123;&quot;$merge&quot;: &#123;&quot;into&quot;: &quot;orders_typed&quot;, &#125;&#125;, ]; 执行聚合操作后将生成一个新的名为orders_typed的集合，新集合orders_typed应该与原集合orders具有相同数量的文档、相同的字段结构和字段名称，但现在使用了合适的强类型的布尔值、日期、整数和十进制值，集合内容如下所示。 Boolean Conversion. The pipeline’s conversions for integers, decimals, and dates are straightforward using the corresponding expression operators, $toInt, $toDecimal and $toDate. However, the expression operator $toBool is not used for the boolean conversion. This is because $toBool will convert any non-empty string to true regardless of its value. As a result, the pipeline uses a $switch operator to compare the lowercase version of strings with the text &#39;true&#39; and &#39;false&#39;, returning the matching boolean. Preserving Non-Existence. The field further_info.reported is an optional field in this scenario. The field may not always appear in a document, as illustrated by one of the three documents in the example. If a field is not present in a document, this potentially significant fact should never be lost. The pipeline includes additional logic for the further_info.reported field to preserve this information. The pipeline ensures the field is not included in the output document if it didn’t exist in the source document. A $ifNull conditional operator is used, which returns the $$REMOVE marker flag if the field is missing, instructing the aggregation engine to omit it. Output To A Collection. The pipeline uses a $merge stage to instruct the aggregation engine to write the output to a collection rather than returning a stream of results. For this example, the default settings for $merge are sufficient. Each transformed record coming out of the aggregation pipeline becomes a new record in the target collection. The pipeline could have used a $out rather than a $merge stage. However, because $merge supports both unsharded and sharded collections, whereas $out only supports the former, $merge provides a more universally applicable example. If your aggregation needs to create a brand new unsharded collection, $out may be a little faster because the aggregation will completely replace the existing collection if it exists. Using $merge, the system has to perform more checks for every record the aggregation inserts (even though, in this case, it will be to a new collection). Trickier Date Conversions. In this example, the date strings contain all the date parts required by the $toDate operator to perform a conversion correctly. In some situations, this may not be the case, and a date string may be missing some valuable information (e.g. which century a 2-character year string is for, such as the century 19 or 21). To understand how to deal with these cases, see the Convert Incomplete Date Strings example chapter. (2)残缺日期转换 应用程序正在将payment文档提取到 MongoDB 集合中，其中每个文档的payment date字段都包含一个「看起来有点像日期时间」的字符串，例如&quot;01-JAN-20 01.01.01.123000000&quot;。 您希望在聚合时将每个payment date转换为有效的BSON日期类型，但是该字段不包含能准确确定确切日期时间所需的所有信息。因此，您不能直接使用 MongoDB 的日期表达式运算符将文本转换为日期。 这些文本字段中的每一个都缺少以下信息： 明确的世纪：例如是1900s，还是2000s，还是其他； 明确的时区：例如是GMT，是IST，还是PST，还是其他； 三个字母的月份缩写所代表的具体语言：例如「JAN」是法语，还是英语，还是其他。 假设您随后了解到所有付款记录仅发生在21世纪，提取数据时使用的时区是UTC，使用的语言是英语。有了这些信息，您就可以构建一个聚合管道来将这些文本字段转换为日期字段。 缴费集合payments包含12个支付文档，包括了时间乱序的覆盖了2020年所有12个月的数据，如下所示。 123456789101112&#123;&quot;account&quot;: &quot;010101&quot;, &quot;payment_date&quot;: &quot;01-JAN-20 01.01.01.123000000&quot;, &quot;amount&quot;: 1.01&#125;,&#123;&quot;account&quot;: &quot;020202&quot;, &quot;payment_date&quot;: &quot;02-FEB-20 02.02.02.456000000&quot;, &quot;amount&quot;: 2.02&#125;,&#123;&quot;account&quot;: &quot;030303&quot;, &quot;payment_date&quot;: &quot;03-MAR-20 03.03.03.789000000&quot;, &quot;amount&quot;: 3.03&#125;,&#123;&quot;account&quot;: &quot;040404&quot;, &quot;payment_date&quot;: &quot;04-APR-20 04.04.04.012000000&quot;, &quot;amount&quot;: 4.04&#125;,&#123;&quot;account&quot;: &quot;050505&quot;, &quot;payment_date&quot;: &quot;05-MAY-20 05.05.05.345000000&quot;, &quot;amount&quot;: 5.05&#125;,&#123;&quot;account&quot;: &quot;060606&quot;, &quot;payment_date&quot;: &quot;06-JUN-20 06.06.06.678000000&quot;, &quot;amount&quot;: 6.06&#125;,&#123;&quot;account&quot;: &quot;070707&quot;, &quot;payment_date&quot;: &quot;07-JUL-20 07.07.07.901000000&quot;, &quot;amount&quot;: 7.07&#125;,&#123;&quot;account&quot;: &quot;080808&quot;, &quot;payment_date&quot;: &quot;08-AUG-20 08.08.08.234000000&quot;, &quot;amount&quot;: 8.08&#125;,&#123;&quot;account&quot;: &quot;090909&quot;, &quot;payment_date&quot;: &quot;09-SEP-20 09.09.09.567000000&quot;, &quot;amount&quot;: 9.09&#125;,&#123;&quot;account&quot;: &quot;101010&quot;, &quot;payment_date&quot;: &quot;10-OCT-20 10.10.10.890000000&quot;, &quot;amount&quot;: 10.10&#125;,&#123;&quot;account&quot;: &quot;111111&quot;, &quot;payment_date&quot;: &quot;11-NOV-20 11.11.11.111000000&quot;, &quot;amount&quot;: 11.11&#125;,&#123;&quot;account&quot;: &quot;121212&quot;, &quot;payment_date&quot;: &quot;12-DEC-20 12.12.12.999000000&quot;, &quot;amount&quot;: 12.12&#125; 聚合管道定义如下： 1234567891011121314151617181920212223242526272829303132333435363738var pipeline = [ // 将字段从字符串转换为日期类型，填补缺失的空白 &#123;&quot;$set&quot;: &#123; &quot;payment_date&quot;: &#123; &quot;$let&quot;: &#123; &quot;vars&quot;: &#123; &quot;txt&quot;: &quot;$payment_date&quot;, // Assign &quot;payment_date&quot; field to variable &quot;txt&quot;, &quot;month&quot;: &#123;&quot;$substrCP&quot;: [&quot;$payment_date&quot;, 3, 3]&#125;, // Extract month text &#125;, &quot;in&quot;: &#123; &quot;$dateFromString&quot;: &#123;&quot;format&quot;: &quot;%d-%m-%Y %H.%M.%S.%L&quot;, &quot;dateString&quot;: &#123;&quot;$concat&quot;: [ &#123;&quot;$substrCP&quot;: [&quot;$$txt&quot;, 0, 3]&#125;, // Use 1st 3 chars in string &#123;&quot;$switch&quot;: &#123;&quot;branches&quot;: [ // Replace month 3 chars with month number &#123;&quot;case&quot;: &#123;&quot;$eq&quot;: [&quot;$$month&quot;, &quot;JAN&quot;]&#125;, &quot;then&quot;: &quot;01&quot;&#125;, &#123;&quot;case&quot;: &#123;&quot;$eq&quot;: [&quot;$$month&quot;, &quot;FEB&quot;]&#125;, &quot;then&quot;: &quot;02&quot;&#125;, &#123;&quot;case&quot;: &#123;&quot;$eq&quot;: [&quot;$$month&quot;, &quot;MAR&quot;]&#125;, &quot;then&quot;: &quot;03&quot;&#125;, &#123;&quot;case&quot;: &#123;&quot;$eq&quot;: [&quot;$$month&quot;, &quot;APR&quot;]&#125;, &quot;then&quot;: &quot;04&quot;&#125;, &#123;&quot;case&quot;: &#123;&quot;$eq&quot;: [&quot;$$month&quot;, &quot;MAY&quot;]&#125;, &quot;then&quot;: &quot;05&quot;&#125;, &#123;&quot;case&quot;: &#123;&quot;$eq&quot;: [&quot;$$month&quot;, &quot;JUN&quot;]&#125;, &quot;then&quot;: &quot;06&quot;&#125;, &#123;&quot;case&quot;: &#123;&quot;$eq&quot;: [&quot;$$month&quot;, &quot;JUL&quot;]&#125;, &quot;then&quot;: &quot;07&quot;&#125;, &#123;&quot;case&quot;: &#123;&quot;$eq&quot;: [&quot;$$month&quot;, &quot;AUG&quot;]&#125;, &quot;then&quot;: &quot;08&quot;&#125;, &#123;&quot;case&quot;: &#123;&quot;$eq&quot;: [&quot;$$month&quot;, &quot;SEP&quot;]&#125;, &quot;then&quot;: &quot;09&quot;&#125;, &#123;&quot;case&quot;: &#123;&quot;$eq&quot;: [&quot;$$month&quot;, &quot;OCT&quot;]&#125;, &quot;then&quot;: &quot;10&quot;&#125;, &#123;&quot;case&quot;: &#123;&quot;$eq&quot;: [&quot;$$month&quot;, &quot;NOV&quot;]&#125;, &quot;then&quot;: &quot;11&quot;&#125;, &#123;&quot;case&quot;: &#123;&quot;$eq&quot;: [&quot;$$month&quot;, &quot;DEC&quot;]&#125;, &quot;then&quot;: &quot;12&quot;&#125;, ], &quot;default&quot;: &quot;ERROR&quot;&#125;&#125;, &quot;-20&quot;, // Add hyphen + hardcoded century 2 digits &#123;&quot;$substrCP&quot;: [&quot;$$txt&quot;, 7, 15]&#125; // Use remaining 3 millis (ignore last 6 nanosecs) ] &#125;&#125; &#125; &#125; &#125;, &#125;&#125;, &#123;&quot;$unset&quot;: [&quot;_id&quot;, ]&#125;, ]; 执行聚合操作后应该返回对应于原文档的12个文档，但将payment_date从文本值转换为正确的日期类型，如下所示。 Concatenation Explanation. In this pipeline, the text fields (e.g. &#39;12-DEC-20 12.12.12.999000000&#39;) are each converted to date fields (e.g. 2020-12-12T12:12:12.999Z). This is achieved by concatenating together the following four example elements before passing them to the $dateFromString operator to convert to a date type: &#39;12-&#39; (day of the month from the input string + the hyphen suffix already present in the text) &#39;12&#39; (replacing ‘DEC’) &#39;-20&#39; (hard-coded hyphen + hardcoded century) &#39;20 12.12.12.999&#39; (the rest of input string apart from the last 6 nanosecond digits) Further Reading. This example is based on the output of the blog post: Converting Gnarly Date Strings to Proper Date Types Using a MongoDB Aggregation Pipeline. 4.趋势分析(1)特征分类（分面检索） 您希望在零售网站上提供分面检索功能，使客户能够在网页中列出的产品结果中，通过选择指定特征来改善他们的产品搜索。 按不同维度对产品进行分类是有益的，其中每个维度（即「分面facet」）对应于产品记录中的特定字段（例如「产品评级」、「产品价格」）。每个分面都应分解为子范围，以便客户可以为特定分面（例如「评级」）选择特定的子范围（例如4~5星）。 聚合管道将根据每个分面的字段（rating和price）来分析products集合，以确定每个分面的值的分布。 产品集合products包含如下16个文档。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&#123; &quot;name&quot;: &quot;Asus Laptop&quot;, &quot;category&quot;: &quot;ELECTRONICS&quot;, &quot;description&quot;: &quot;Good value laptop for students&quot;, &quot;price&quot;: NumberDecimal(&quot;431.43&quot;), &quot;rating&quot;: NumberDecimal(&quot;4.2&quot;)&#125;, &#123; &quot;name&quot;: &quot;The Day Of The Triffids&quot;, &quot;category&quot;: &quot;BOOKS&quot;, &quot;description&quot;: &quot;Classic post-apocalyptic novel&quot;, &quot;price&quot;: NumberDecimal(&quot;5.01&quot;), &quot;rating&quot;: NumberDecimal(&quot;4.8&quot;)&#125;, &#123; &quot;name&quot;: &quot;Morphy Richardds Food Mixer&quot;, &quot;category&quot;: &quot;KITCHENWARE&quot;, &quot;description&quot;: &quot;Luxury mixer turning good cakes into great&quot;, &quot;price&quot;: NumberDecimal(&quot;63.13&quot;), &quot;rating&quot;: NumberDecimal(&quot;3.8&quot;)&#125;, &#123; &quot;name&quot;: &quot;Karcher Hose Set&quot;, &quot;category&quot;: &quot;GARDEN&quot;, &quot;description&quot;: &quot;Hose + nosels + winder for tidy storage&quot;, &quot;price&quot;: NumberDecimal(&quot;22.13&quot;), &quot;rating&quot;: NumberDecimal(&quot;4.3&quot;)&#125;, &#123; &quot;name&quot;: &quot;Oak Coffee Table&quot;, &quot;category&quot;: &quot;HOME&quot;, &quot;description&quot;: &quot;size is 2m x 0.5m x 0.4m&quot;, &quot;price&quot;: NumberDecimal(&quot;22.13&quot;), &quot;rating&quot;: NumberDecimal(&quot;3.8&quot;)&#125;, &#123; &quot;name&quot;: &quot;Lenovo Laptop&quot;, &quot;category&quot;: &quot;ELECTRONICS&quot;, &quot;description&quot;: &quot;High spec good for gaming&quot;, &quot;price&quot;: NumberDecimal(&quot;1299.99&quot;), &quot;rating&quot;: NumberDecimal(&quot;4.1&quot;)&#125;, &#123; &quot;name&quot;: &quot;One Day in the Life of Ivan Denisovich&quot;, &quot;category&quot;: &quot;BOOKS&quot;, &quot;description&quot;: &quot;Brutal life in a labour camp&quot;, &quot;price&quot;: NumberDecimal(&quot;4.29&quot;), &quot;rating&quot;: NumberDecimal(&quot;4.9&quot;)&#125;, &#123; &quot;name&quot;: &quot;Russell Hobbs Chrome Kettle&quot;, &quot;category&quot;: &quot;KITCHENWARE&quot;, &quot;description&quot;: &quot;Nice looking budget kettle&quot;, &quot;price&quot;: NumberDecimal(&quot;15.76&quot;), &quot;rating&quot;: NumberDecimal(&quot;3.9&quot;)&#125;, &#123; &quot;name&quot;: &quot;Tiffany Gold Chain&quot;, &quot;category&quot;: &quot;JEWELERY&quot;, &quot;description&quot;: &quot;Looks great for any age and gender&quot;, &quot;price&quot;: NumberDecimal(&quot;582.22&quot;), &quot;rating&quot;: NumberDecimal(&quot;4.0&quot;)&#125;, &#123; &quot;name&quot;: &quot;Raleigh Racer 21st Century Classic&quot;, &quot;category&quot;: &quot;BICYCLES&quot;, &quot;description&quot;: &quot;Modern update to a classic 70s bike design&quot;, &quot;price&quot;: NumberDecimal(&quot;523.00&quot;), &quot;rating&quot;: NumberDecimal(&quot;4.5&quot;)&#125;, &#123; &quot;name&quot;: &quot;Diesel Flare Jeans&quot;, &quot;category&quot;: &quot;CLOTHES&quot;, &quot;description&quot;: &quot;Top end casual look&quot;, &quot;price&quot;: NumberDecimal(&quot;129.89&quot;), &quot;rating&quot;: NumberDecimal(&quot;4.3&quot;)&#125;, &#123; &quot;name&quot;: &quot;Jazz Silk Scarf&quot;, &quot;category&quot;: &quot;CLOTHES&quot;, &quot;description&quot;: &quot;Style for the winder months&quot;, &quot;price&quot;: NumberDecimal(&quot;28.39&quot;), &quot;rating&quot;: NumberDecimal(&quot;3.7&quot;)&#125;, &#123; &quot;name&quot;: &quot;Dell XPS 13 Laptop&quot;, &quot;category&quot;: &quot;ELECTRONICS&quot;, &quot;description&quot;: &quot;Developer edition&quot;, &quot;price&quot;: NumberDecimal(&quot;1399.89&quot;), &quot;rating&quot;: NumberDecimal(&quot;4.4&quot;)&#125;, &#123; &quot;name&quot;: &quot;NY Baseball Cap&quot;, &quot;category&quot;: &quot;CLOTHES&quot;, &quot;description&quot;: &quot;Blue &amp; white&quot;, &quot;price&quot;: NumberDecimal(&quot;18.99&quot;), &quot;rating&quot;: NumberDecimal(&quot;4.0&quot;)&#125;, &#123; &quot;name&quot;: &quot;Tots Flower Pots&quot;, &quot;category&quot;: &quot;GARDEN&quot;, &quot;description&quot;: &quot;Set of three&quot;, &quot;price&quot;: NumberDecimal(&quot;9.78&quot;), &quot;rating&quot;: NumberDecimal(&quot;4.1&quot;)&#125;, &#123; &quot;name&quot;: &quot;Picky Pencil Sharpener&quot;, &quot;category&quot;: &quot;Stationery&quot;, &quot;description&quot;: &quot;Ultra budget&quot;, &quot;price&quot;: NumberDecimal(&quot;0.67&quot;), &quot;rating&quot;: NumberDecimal(&quot;1.2&quot;)&#125; 聚合管道定义如下： 123456789101112131415161718192021222324252627282930313233var pipeline = [ // Group products by 2 facets: 1) by price ranges, 2) by rating ranges &#123;&quot;$facet&quot;: &#123; // ①Group by price ranges &quot;by_price&quot;: [ // Group into 3 ranges: inexpensive small price range to expensive large price range &#123;&quot;$bucketAuto&quot;: &#123; &quot;groupBy&quot;: &quot;$price&quot;, &quot;buckets&quot;: 3, &quot;granularity&quot;: &quot;1-2-5&quot;, &quot;output&quot;: &#123;&quot;count&quot;: &#123;&quot;$sum&quot;: 1&#125;, &quot;products&quot;: &#123;&quot;$push&quot;: &quot;$name&quot;&#125;,&#125;, &#125;&#125;, // Tag range info as &quot;price_range&quot; &#123;&quot;$set&quot;: &#123;&quot;price_range&quot;: &quot;$_id&quot;,&#125;&#125;, &#123;&quot;$unset&quot;: [&quot;_id&quot;,]&#125;, ], // ②Group by rating ranges &quot;by_rating&quot;: [ // Group products evenly across 5 rating ranges from low to high &#123;&quot;$bucketAuto&quot;: &#123; &quot;groupBy&quot;: &quot;$rating&quot;, &quot;buckets&quot;: 5, &quot;output&quot;: &#123;&quot;count&quot;: &#123;&quot;$sum&quot;: 1&#125;, &quot;products&quot;: &#123;&quot;$push&quot;: &quot;$name&quot;&#125;,&#125;, &#125;&#125;, &#123;&quot;$set&quot;: &#123;&quot;rating_range&quot;: &quot;$_id&quot;,&#125;&#125;, &#123;&quot;$unset&quot;: [&quot;_id&quot;,]&#125;, ], &#125;&#125;, ]; 执行聚合操作后应该返回一个单独的文档，文档包含 2 个分面（分别关闭by_price和关闭by_rating），每个分面显示「其值的子范围」以及「属于每个子范围的产品」，如下所示。 Multiple Pipelines. The $facet stage doesn’t have to be employed for you to use the $bucketAuto stage. In most faceted search scenarios, you will want to understand a collection by multiple dimensions at once (price &amp; rating in this case). The $facet stage is convenient because it allows you to define various $bucketAuto dimensions in one go in a single pipeline. Otherwise, a client application must invoke an aggregation multiple times, each using a new $bucketAuto stage to process a different field. In fact, each section of a $facet stage is just a regular aggregation [sub-]pipeline, able to contain any type of stage (with a few specific documented exceptions) and may not even contain $bucketAuto or $bucket stages at all. Single Document Result. If the result of a $facet based aggregation is allowed to be multiple documents, this will cause a problem. The results will contain a mix of records originating from different facets but with no way of ascertaining the facet each result record belongs to. Consequently, when using $facet, a single document is always returned, containing top-level fields identifying each facet. Having only a single result record is not usually a problem. A typical requirement for faceted search is to return a small amount of grouped summary data about a collection rather than large amounts of raw data from the collection. Therefore the 16MB document size limit should not be an issue. Spread Of Ranges. In this example, each of the two employed bucketing facets uses a different granularity number scheme for spreading out the sub-ranges of values. You choose a numbering scheme based on what you know about the nature of the facet. For instance, most of the ratings values in the sample collection have scores bunched between late 3s and early 4s. If a numbering scheme is defined to reflect an even spread of ratings, most products will appear in the same sub-range bucket and some sub-ranges would contain no products (e.g. ratings 2 to 3 in this example). This wouldn’t provide website customers with much selectivity on product ratings. (2)最大图网络 基于类似于 Twitter 的社交网络数据库，您的组织希望了解新营销活动的最佳目标。 您想要搜索「社交网络用户」的集合，其中每个用户记录文档都包含一个用户名和该用户的关注者。 您将执行一个聚合管道查询，遍历每个用户记录的followed_by数组，从而确定哪个用户具有最大的 network reach ，即最广的朋友圈。 请注意，为简洁起见，此示例仅使用了一个简单的数据模型。然而这不太可能是一个最佳数据模型，例如拥有很多粉丝的社交网络用户对于$graphLookup的大规模使用，抑或是在分片环境中运行。有关此类问题的更多指导，请参阅Socialite。 用户集合users包含以下10个社交网络用户文档，可考虑加上一个索引db.users.createIndex(&#123;&quot;name&quot;: 1&#125;)来帮助优化 图的遍历 。 12345678910&#123; &quot;name&quot;: &quot;Paul&quot;, &quot;followed_by&quot;: [] &#125;,&#123; &quot;name&quot;: &quot;Toni&quot;, &quot;followed_by&quot;: [&quot;Paul&quot;] &#125;,&#123; &quot;name&quot;: &quot;Janet&quot;, &quot;followed_by&quot;: [&quot;Paul&quot;, &quot;Toni&quot;] &#125;,&#123; &quot;name&quot;: &quot;David&quot;, &quot;followed_by&quot;: [&quot;Janet&quot;, &quot;Paul&quot;, &quot;Toni&quot;] &#125;,&#123; &quot;name&quot;: &quot;Fiona&quot;, &quot;followed_by&quot;: [&quot;David&quot;, &quot;Paul&quot;] &#125;,&#123; &quot;name&quot;: &quot;Bob&quot;, &quot;followed_by&quot;: [&quot;Janet&quot;] &#125;,&#123; &quot;name&quot;: &quot;Carl&quot;, &quot;followed_by&quot;: [&quot;Fiona&quot;] &#125;,&#123; &quot;name&quot;: &quot;Sarah&quot;, &quot;followed_by&quot;: [&quot;Carl&quot;, &quot;Paul&quot;] &#125;,&#123; &quot;name&quot;: &quot;Carol&quot;, &quot;followed_by&quot;: [&quot;Helen&quot;, &quot;Sarah&quot;] &#125;,&#123; &quot;name&quot;: &quot;Helen&quot;, &quot;followed_by&quot;: [&quot;Paul&quot;] &#125;, 聚合管道定义如下：123456789101112131415161718192021222324var pipeline = [ // 对于每个用户，图遍历他们的followed_by数组 &#123;&quot;$graphLookup&quot;: &#123; &quot;from&quot;: &quot;users&quot;, &quot;startWith&quot;: &quot;$followed_by&quot;, &quot;connectFromField&quot;: &quot;followed_by&quot;, &quot;connectToField&quot;: &quot;name&quot;, &quot;depthField&quot;: &quot;depth&quot;, &quot;as&quot;: &quot;extended_network&quot;, &#125;&#125;, &#123;&quot;$set&quot;: &#123; // Count the extended connection reach &quot;network_reach&quot;: &#123;&quot;$size&quot;: &quot;$extended_network&quot;&#125;, // Gather the list of the extended connections&#x27; names &quot;extended_connections&quot;: &#123; &quot;$map&quot;: &#123;&quot;input&quot;: &quot;$extended_network&quot;, &quot;as&quot;: &quot;connection&quot;,&quot;in&quot;: &quot;$$connection.name&quot;&#125; &#125;, &#125;&#125;, &#123;&quot;$unset&quot;: [&quot;_id&quot;, &quot;followed_by&quot;, &quot;extended_network&quot;,]&#125;, &#123;&quot;$sort&quot;: &#123;&quot;network_reach&quot;: -1,&#125;&#125;, ]; 执行聚合操作后应该返回对应原来的10个源社交网络用户的10个文档，每个文档包括用户的 网络到达数network reach count 和 扩展连接名称extended connection names ，按网络覆盖面最广的用户排序，如下所示。 Following Graphs. The $graphLookup stage helps you traverse relationships between records, looking for patterns that aren’t necessarily evident from looking at each record in isolation. In this example, by looking at Paul’s record in isolation, it is evident that Paul has no friends and thus has the lowest network reach. However, it is not obvious that Carol has the greatest network reach just by looking at the number of people Carol is directly followed by, which is two. David, for example, is followed by three people (one more than Carol). However, the executed aggregation pipeline can deduce that Carol has the most extensive network reach. Index Use. The $graphLookup stage can leverage the index on the field name for each of its connectToField hops. (3)增量分析 您有一组累积多年的 商店订单 ，零售渠道在每个交易日不断向orders集合添加新订单记录。 您希望经常生成汇总报告，以便管理层了解业务状态并对不断变化的业务趋势做出反应。多年来，生成所有每日总和和平均值的报告所需的时间越来越长，因为需要处理的数据天数越来越多。 从现在开始，为了解决这个问题，您将只在一天结束时生成当天的摘要分析，并将其存储在不同的集合中，该集合会随着时间的推移积累每日摘要记录。 与本文中的大多数示例不同，聚合管道将其输出写入一个集合，而不是将结果以流的形式传输回调用应用程序。 订单集合orders包含9个文档，分别代表 2021-02-01 的 5 个订单和 2021-02-02 的 4 个订单，如下所示。 123456789&#123;&quot;orderdate&quot;: ISODate(&quot;2021-02-01T08:35:52Z&quot;), &quot;value&quot;: NumberDecimal(&quot;231.43&quot;),&#125;,&#123;&quot;orderdate&quot;: ISODate(&quot;2021-02-01T09:32:07Z&quot;), &quot;value&quot;: NumberDecimal(&quot;99.99&quot;),&#125;,&#123;&quot;orderdate&quot;: ISODate(&quot;2021-02-01T08:25:37Z&quot;), &quot;value&quot;: NumberDecimal(&quot;63.13&quot;),&#125;,&#123;&quot;orderdate&quot;: ISODate(&quot;2021-02-01T19:13:32Z&quot;), &quot;value&quot;: NumberDecimal(&quot;2.01&quot;),&#125;, &#123;&quot;orderdate&quot;: ISODate(&quot;2021-02-01T22:56:53Z&quot;), &quot;value&quot;: NumberDecimal(&quot;187.99&quot;),&#125;,&#123;&quot;orderdate&quot;: ISODate(&quot;2021-02-02T23:04:48Z&quot;), &quot;value&quot;: NumberDecimal(&quot;4.59&quot;),&#125;,&#123;&quot;orderdate&quot;: ISODate(&quot;2021-02-02T08:55:46Z&quot;), &quot;value&quot;: NumberDecimal(&quot;48.50&quot;),&#125;,&#123;&quot;orderdate&quot;: ISODate(&quot;2021-02-02T07:49:32Z&quot;), &quot;value&quot;: NumberDecimal(&quot;1024.89&quot;),&#125;,&#123;&quot;orderdate&quot;: ISODate(&quot;2021-02-02T13:49:44Z&quot;), &quot;value&quot;: NumberDecimal(&quot;102.24&quot;),&#125;, 定义一个函数来创建聚合管道，将「开始日期」和「结束日期」作为函数的参数，以便于在不同的日期多次执行聚合： 1234567891011121314151617181920212223242526272829303132function getDayAggPipeline(startDay, endDay) &#123; return [ &#123;&quot;$match&quot;: &#123; &quot;orderdate&quot;: &#123;&quot;$gte&quot;: ISODate(startDay), &quot;$lt&quot;: ISODate(endDay)&#125; &#125;&#125;, // 将当天的所有订单组合成一个汇总记录 &#123;&quot;$group&quot;: &#123; &quot;_id&quot;: null, &quot;date_parts&quot;: &#123;&quot;$first&quot;: &#123;&quot;$dateToParts&quot;: &#123;&quot;date&quot;: &quot;$orderdate&quot;&#125;&#125;&#125;, &quot;total_value&quot;: &#123;&quot;$sum&quot;: &quot;$value&quot;&#125;, &quot;total_orders&quot;: &#123;&quot;$sum&quot;: 1&#125;, &#125;&#125;, // 从1个订单中获取日期部分（对于UTC而言需要年、月、日） &#123;&quot;$set&quot;: &#123; &quot;day&quot;: &#123;&quot;$dateFromParts&quot;: &#123; &quot;year&quot;: &quot;$date_parts.year&quot;, &quot;month&quot;: &quot;$date_parts.month&quot;, &quot;day&quot;:&quot;$date_parts.day&quot; &#125;&#125;, &#125;&#125;, &#123;&quot;$unset&quot;: [&quot;_id&quot;, &quot;date_parts&quot;, ]&#125;, // 将日期摘要添加到摘要集合中（若已存在则覆盖） &#123;&quot;$merge&quot;: &#123; &quot;into&quot;: &quot;daily_orders_summary&quot;, &quot;on&quot;: &quot;day&quot;, &quot;whenMatched&quot;: &quot;replace&quot;, &quot;whenNotMatched&quot;: &quot;insert&quot; &#125;&#125;, ];&#125; 仅对于 2021-02-01 的订单，调用上述getDayAggPipeline函数构建聚合管道，执行聚合后将结果写入汇总集合daily_orders_summary，查看汇总集合内容应该只有1条记录【仅生成了 2021-02-01 的单个订单摘要，其中包含当天的总价值和订单数量】。 1234// 【第一天】var pipeline = getDayAggPipeline(&quot;2021-02-01T00:00:00Z&quot;, &quot;2021-02-02T00:00:00Z&quot;);db.orders.aggregate(pipeline);db.daily_orders_summary.find() 现在仅在第二天（即仅对于 2021-02-02 的订单），构建管道并执行聚合。从结果中，您可以看到这两天的订单摘要都存在（在第一天的基础上追加了第二天）。 1234// 【第二天】var pipeline = getDayAggPipeline(&quot;2021-02-02T00:00:00Z&quot;, &quot;2021-02-03T00:00:00Z&quot;);db.orders.aggregate(pipeline);db.daily_orders_summary.find() 为了模拟组织偶尔需要追溯更正旧订单，回到第一天并添加新的「高价值」订单。然后仅在第一天（2021-02-01）重新运行聚合，以表明您可以安全正确地重新计算 仅一天 的摘要： 123456789// 回顾性地将订单添加到第一天（2021-02-01）以模拟「漏掉一单」db.orders.insertOne( &#123;&quot;orderdate&quot;: ISODate(&quot;2021-02-01T09:32:07Z&quot;), &quot;value&quot;: NumberDecimal(&quot;11111.11&quot;)&#125; )// 【第一天（新）】重新为第一天构建运行聚合管道，覆盖汇总集合daily_orders_summary中的第一条记录var pipeline = getDayAggPipeline(&quot;2021-02-01T00:00:00Z&quot;, &quot;2021-02-02T00:00:00Z&quot;);db.orders.aggregate(pipeline);db.daily_orders_summary.find() 执行上述三个聚合操作后，汇总集合daily_orders_summary如图所示： 从结果中，您可以看到仍然存在两个订单摘要，两个交易日各一个，但第一天的总价值和订单数量发生了变化。如下图所示，当需要更正某天的订单摘要时，只要重新为那一天构建运行聚合管道即可修正。 Merging Results. The pipeline uses a $merge stage to instruct the aggregation engine to write the output to a collection rather than returning a stream of results. In this example, with the options you provide to $merge, the aggregation inserts a new record in the destination collection if a matching one doesn’t already exist. If a matching record already exists, it replaces the previous version. Incremental Updates. The example illustrates just two days of shop orders, albeit with only a few orders, to keep the example simple. At the end of each new trading day, you run the aggregation pipeline to generate the current day’s summary only. Even after the source collection has increased in size over many years, the time it takes you to bring the summary collection up to date again stays constant. In a real-world scenario, the business might expose a graphical chart showing the changing daily orders trend over the last rolling year. This charting dashboard is not burdened by the cost of periodically regenerating values for all days in the year. There could be hundreds of thousands of orders received per day for real-world retailers, especially large ones. A day’s summary may take many seconds to generate in that situation. Without an incremental analytics approach, if you need to generate a year’s worth of daily summaries every time, it would take hours to refresh the business dashboard. Idempotency. If a retailer is aggregating tens of thousands of orders per day, then during end-of-day processing, it may choose to generate 24 hourly summary records rather than a single daily record. This provides the business with finer granularity to understand trends better. As with any software process, when generating hourly results into the summary collection, there is the risk of not fully completing if a system failure occurs. If an in-flight aggregation terminates abnormally, it may not have written all 24 summary collection records. The failure leaves the summary collection in an indeterminate and incomplete state for one of its days. However, this isn’t a problem because of the way the aggregation pipeline uses the $merge stage. When an aggregation fails to complete, it can just be re-run. When re-run, it will regenerate all the results for the day, replacing existing summary records and filling in the missing ones. The aggregation pipeline is idempotent, and you can run it repeatedly without damaging the summary collection. The overall solution is self-healing and naturally tolerant of inadvertently aborted aggregation jobs. Retrospective Changes. Sometimes, an organisation may need to go back and correct records from the past, as illustrated in this example. For instance, a bank may need to fix a past payment record due to a settlement issue that only comes to light weeks later. With the approach used in this example, it is straightforward to re-execute the aggregation pipeline for a prior date, using the updated historical data. This will correctly update the specific day’s summary data only, to reflect the business’s current state. 5.数据安全(1)严格视图 您有一个 persons 集合，其中不应允许特定客户端应用程序查看敏感信息。因此，您将仅提供一个筛选后的人员数据子集的只读视图。 在实际情况中，您还可以使用 MongoDB 的基于角色的访问控制（Role-Based Access Control，RBAC）来限制客户端应用程序只能访问视图而不是原始集合。 您将使用 adults 视图以两种方式限制客户端应用程序的个人数据： 仅显示 18 岁及以上的人（通过检查每个人的dateofbirth字段）； 从结果中排除每个人的social_security_num字段。 本质上，这是对 MongoDB 中实现「记录级（record-level）」访问控制的一个说明。 persons集合包含5条记录，如下所示。 1234567891011121314151617181920212223242526272829303132333435363738394041&#123; &quot;person_id&quot;: &quot;6392529400&quot;, &quot;firstname&quot;: &quot;Elise&quot;, &quot;lastname&quot;: &quot;Smith&quot;, &quot;dateofbirth&quot;: ISODate(&quot;1972-01-13T09:32:07Z&quot;), &quot;gender&quot;: &quot;FEMALE&quot;, &quot;email&quot;: &quot;elise_smith@myemail.com&quot;, &quot;social_security_num&quot;: &quot;507-28-9805&quot;, &quot;address&quot;: &#123;&quot;number&quot;: 5625, &quot;street&quot;: &quot;Tipa Circle&quot;, &quot;city&quot;: &quot;Wojzinmoj&quot;&#125;,&#125;, &#123; &quot;person_id&quot;: &quot;1723338115&quot;, &quot;firstname&quot;: &quot;Olive&quot;, &quot;lastname&quot;: &quot;Ranieri&quot;, &quot;dateofbirth&quot;: ISODate(&quot;1985-05-12T23:14:30Z&quot;), &quot;gender&quot;: &quot;FEMALE&quot;, &quot;email&quot;: &quot;oranieri@warmmail.com&quot;, &quot;social_security_num&quot;: &quot;618-71-2912&quot;, &quot;address&quot;: &#123;&quot;number&quot;: 9303, &quot;street&quot;: &quot;Mele Circle&quot;, &quot;city&quot;: &quot;Tobihbo&quot;&#125;,&#125;, &#123; &quot;person_id&quot;: &quot;8732762874&quot;, &quot;firstname&quot;: &quot;Toni&quot;, &quot;lastname&quot;: &quot;Jones&quot;, &quot;dateofbirth&quot;: ISODate(&quot;2014-11-23T16:53:56Z&quot;), &quot;gender&quot;: &quot;FEMALE&quot;, &quot;email&quot;: &quot;tj@wheresmyemail.com&quot;, &quot;social_security_num&quot;: &quot;001-10-3488&quot;, &quot;address&quot;: &#123;&quot;number&quot;: 1, &quot;street&quot;: &quot;High Street&quot;, &quot;city&quot;: &quot;Upper Abbeywoodington&quot;&#125;,&#125;, &#123; &quot;person_id&quot;: &quot;7363629563&quot;, &quot;firstname&quot;: &quot;Bert&quot;, &quot;lastname&quot;: &quot;Gooding&quot;, &quot;dateofbirth&quot;: ISODate(&quot;1941-04-07T22:11:52Z&quot;), &quot;gender&quot;: &quot;MALE&quot;, &quot;email&quot;: &quot;bgooding@tepidmail.com&quot;, &quot;social_security_num&quot;: &quot;230-43-7633&quot;, &quot;address&quot;: &#123;&quot;number&quot;: 13, &quot;street&quot;: &quot;Upper Bold Road&quot;, &quot;city&quot;: &quot;Redringtonville&quot;&#125;,&#125;, &#123; &quot;person_id&quot;: &quot;1029648329&quot;, &quot;firstname&quot;: &quot;Sophie&quot;, &quot;lastname&quot;: &quot;Celements&quot;, &quot;dateofbirth&quot;: ISODate(&quot;2013-07-06T17:35:45Z&quot;), &quot;gender&quot;: &quot;FEMALE&quot;, &quot;email&quot;: &quot;sophe@celements.net&quot;, &quot;social_security_num&quot;: &quot;377-30-5364&quot;, &quot;address&quot;: &#123;&quot;number&quot;: 5, &quot;street&quot;: &quot;Innings Close&quot;, &quot;city&quot;: &quot;Basilbridge&quot;&#125;,&#125; 聚合管道定义如下：123456var pipeline = [ &#123;&quot;$match&quot;: &#123;&quot;$expr&quot;:&#123; &quot;$lt&quot;: [&quot;$dateofbirth&quot;, &#123;&quot;$subtract&quot;: [&quot;$$NOW&quot;, 18*365.25*24*60*60*1000]&#125;] &#125;&#125;&#125;, &#123;&quot;$unset&quot;: [&quot;_id&quot;, &quot;social_security_num&quot;]&#125;, ]; 首先，在创建视图之前执行聚合操作（并观察explain），以测试该定义的聚合管道。然后创建新的adults视图，它会在任何人查询视图时自动应用聚合管道。 123db.persons.aggregate(pipeline);db.persons.explain(&quot;executionStats&quot;).aggregate(pipeline);db.createView(&quot;adults&quot;, &quot;persons&quot;, pipeline); 对创建的视图执行常规 MQL 查询，没有任何过滤条件，并观察其explain；或者创建的视图执行 MQL 查询，指定过滤器为仅返回女性成年人，观察explain注意性别过滤器gender是如何影响它的。 1234567// 常规MQL查询db.adults.find();db.adults.explain(&quot;executionStats&quot;).find();// 带性别过滤器的MQL查询db.adults.find(&#123;&quot;gender&quot;: &quot;FEMALE&quot;&#125;);db.adults.explain(&quot;executionStats&quot;).find(&#123;&quot;gender&quot;: &quot;FEMALE&quot;&#125;); 对于aggregate()和find()命令在 视图 上执行的结果应该是一样的，都返回3个文档，表示超过18岁的3个人，但是没有显示他们实际的出生日期，如图所示： 带有&quot;gender&quot;: &quot;FEMALE&quot;过滤器的find()命令在 视图 上运行的结果应该仅有2条 女性 记录，因为男性记录已被排除，如下所示： Expr &amp; Indexes. The “NOW” system variable used here returns the current system date-time. However, you can only access this system variable via an aggregation expression and not directly via the regular MongoDB query syntax used by MQL and $match. You must wrap an expression using $$NOW inside an $expr operator. As described in the section Restrictions When Using Expressions in an earlier chapter, if you use an $expr query operator to perform a range comparison, you can’t make use of an index in versions of MongoDB earlier then 5.0. Therefore, in this example, unless you use MongoDB 5.0, the aggregation will not take advantage of an index on dateofbirth. For a view, because you specify the pipeline earlier than it is ever run, you cannot obtain the current date-time at runtime by other means. View Finds &amp; Indexes. Even for versions of MongoDB before 5.0, the explain plan for the gender query run against the view shows an index has been used (the index defined for the gender field). At runtime, a view is essentially just an aggregation pipeline defined “ahead of time”. When db.adults.find(&#123;&quot;gender&quot;: &quot;FEMALE&quot;&#125;) is executed, the database engine dynamically appends a new $match stage to the end of the pipeline for the gender match. It then optimises the pipeline by moving the new $match stage to the pipeline’s start. Finally, it adds the filter extracted from the new $match stage to the aggregation’s initial query, and hence it can then leverage an index containing the gender field. The following two excerpts, from an explain plan from a MongoDB version before 5.0, illustrate how the filter on gender and the filter on dateofbirth combine at runtime and how the index for gender is used to avoid a full collection scan: 123456789101112&#x27;$cursor&#x27;: &#123; queryPlanner: &#123; plannerVersion: 1, namespace: &#x27;book-restricted-view.persons&#x27;, indexFilterSet: false, parsedQuery: &#123; &#x27;$and&#x27;: [ &#123; gender: &#123; &#x27;$eq&#x27;: &#x27;FEMALE&#x27; &#125; &#125;, &#123; &#x27;$expr&#x27;: &#123; &#x27;$lt&#x27;: [ &#x27;$dateofbirth&#x27;, &#123; &#x27;$subtract&#x27;: [ &#x27;$$NOW&#x27;, &#123; &#x27;$const&#x27;: 568036800000 &#125; ] ... 1234567inputStage: &#123; stage: &#x27;IXSCAN&#x27;, keyPattern: &#123; gender: 1 &#125;, indexName: &#x27;gender_1&#x27;, direction: &#x27;forward&#x27;, indexBounds: &#123; gender: [ &#x27;[&quot;FEMALE&quot;, &quot;FEMALE&quot;]&#x27; ] &#125;&#125; In MongoDB 5.0, the explain plan will show the aggregation runtime executing the pipeline more optimally by entirely using the compound index based on both the fields gender and dateofbirth. Further Reading. The ability for find operations on a view to automatically push filters into the view’s aggregation pipeline, and then be further optimised, is described in the blog post: Is Querying A MongoDB View Optimised? (2)隐藏敏感字段由于使用$rand运算符，要求MongoDB版本最低为 4.4。 您想对 信用卡付款 集合的敏感字段执行不可逆屏蔽，准备将输出数据集提供给第 3 方进行分析，而不会将敏感信息暴露给第 3 方。 您需要对付款字段进行的具体更改是： 部分混淆持卡人姓名； 混淆卡号的前 12 位数字，只保留最后 4 位数字； 通过添加或减去最多 30 天（约 1 个月）的随机金额来调整卡的到期时间； 用一组随机的 3 位数字替换卡的 3 位安全码； 通过添加或减去最多为原始金额 10% 的随机金额来调整交易金额； 将大约 20% 的记录中reported字段的布尔值更改为相反值； 如果嵌套子文档customer_info的category字段为 RESTRICTED ，则排除整个子文档customer_info。 payments集合包含2条信用卡付款记录的文档，其中包含敏感数据，如下所示。 1234567891011121314151617181920212223&#123; &quot;card_name&quot;: &quot;Mrs. Jane A. Doe&quot;, &quot;card_num&quot;: &quot;1234567890123456&quot;, &quot;card_expiry&quot;: ISODate(&quot;2023-08-31T23:59:59Z&quot;), &quot;card_sec_code&quot;: &quot;123&quot;, &quot;card_type&quot;: &quot;CREDIT&quot;, &quot;transaction_id&quot;: &quot;eb1bd77836e8713656d9bf2debba8900&quot;, &quot;transaction_date&quot;: ISODate(&quot;2021-01-13T09:32:07Z&quot;), &quot;transaction_amount&quot;: NumberDecimal(&quot;501.98&quot;), &quot;reported&quot;: false, &quot;customer_info&quot;: &#123;&quot;category&quot;: &quot;RESTRICTED&quot;, &quot;rating&quot;: 89, &quot;risk&quot;: 3,&#125;,&#125;, &#123; &quot;card_name&quot;: &quot;Jim Smith&quot;, &quot;card_num&quot;: &quot;9876543210987654&quot;, &quot;card_expiry&quot;: ISODate(&quot;2022-12-31T23:59:59Z&quot;), &quot;card_sec_code&quot;: &quot;987&quot;, &quot;card_type&quot;: &quot;DEBIT&quot;, &quot;transaction_id&quot;: &quot;634c416a6fbcf060bb0ba90c4ad94f60&quot;, &quot;transaction_date&quot;: ISODate(&quot;2020-11-24T19:25:57Z&quot;), &quot;transaction_amount&quot;: NumberDecimal(&quot;64.01&quot;), &quot;reported&quot;: true, &quot;customer_info&quot;: &#123;&quot;category&quot;: &quot;NORMAL&quot;, &quot;rating&quot;: 78, &quot;risk&quot;: 55,&#125;,&#125; 聚合管道定义如下： 12345678910111213141516171819202122232425var pipeline = [ &#123;&quot;$set&quot;: &#123; &quot;card_name&quot;: &#123;&quot;$regexFind&quot;: &#123;&quot;input&quot;: &quot;$card_name&quot;, &quot;regex&quot;: /(\\S+)$/&#125;&#125;, &quot;card_num&quot;: &#123;&quot;$concat&quot;: [&quot;XXXXXXXXXXXX&quot;, &#123;&quot;$substrCP&quot;: [&quot;$card_num&quot;, 12, 4]&#125;,]&#125;, &quot;card_expiry&quot;: &#123;&quot;$add&quot;: [&quot;$card_expiry&quot;, &#123;&quot;$floor&quot;: &#123;&quot;$multiply&quot;: [&#123;&quot;$subtract&quot;: [&#123;&quot;$rand&quot;: &#123;&#125;&#125;, 0.5]&#125;, 2*30*24*60*60*1000]&#125;&#125;,]&#125;, &quot;card_sec_code&quot;: &#123;&quot;$concat&quot;: [ &#123;&quot;$toString&quot;: &#123;&quot;$floor&quot;: &#123;&quot;$multiply&quot;: [&#123;&quot;$rand&quot;: &#123;&#125;&#125;, 10]&#125;&#125;&#125;, &#123;&quot;$toString&quot;: &#123;&quot;$floor&quot;: &#123;&quot;$multiply&quot;: [&#123;&quot;$rand&quot;: &#123;&#125;&#125;, 10]&#125;&#125;&#125;, &#123;&quot;$toString&quot;: &#123;&quot;$floor&quot;: &#123;&quot;$multiply&quot;: [&#123;&quot;$rand&quot;: &#123;&#125;&#125;, 10]&#125;&#125;&#125;, ]&#125;, &quot;transaction_amount&quot;: &#123;&quot;$add&quot;: [&quot;$transaction_amount&quot;, &#123;&quot;$multiply&quot;: [&#123;&quot;$subtract&quot;: [&#123;&quot;$rand&quot;: &#123;&#125;&#125;, 0.5]&#125;, 0.2, &quot;$transaction_amount&quot;]&#125;,]&#125;, &quot;reported&quot;: &#123;&quot;$cond&quot;: &#123; &quot;if&quot;: &#123;&quot;$lte&quot;: [&#123;&quot;$rand&quot;: &#123;&#125;&#125;, 0.8]&#125;, &quot;then&quot;: &quot;$reported&quot;, &quot;else&quot;: &#123;&quot;$not&quot;: [&quot;$reported&quot;]&#125;, &#125;&#125;, &quot;customer_info&quot;: &#123;&quot;$cond&quot;: &#123; &quot;if&quot;: &#123;&quot;$eq&quot;: [&quot;$customer_info.category&quot;, &quot;RESTRICTED&quot;]&#125;, &quot;then&quot;: &quot;$$REMOVE&quot;, &quot;else&quot;: &quot;$customer_info&quot;, &#125;&#125;, &quot;_id&quot;: &quot;$$REMOVE&quot;, &#125;&#125;, &#123;&quot;$set&quot;: &#123;&quot;card_name&quot;: &#123;&quot;$concat&quot;: [&quot;Mx. Xxx &quot;, &#123;&quot;$ifNull&quot;: [&quot;$card_name.match&quot;, &quot;Anonymous&quot;]&#125;]&#125;,&#125;&#125;,]; 执行聚合操作后应该返回与源文档对应的2个文档，但它们的许多字段都被编辑和混淆了，并且标记为RESTRICTED的customer_info字段被省略了，如下所示。 Targeted Redaction. The pipeline uses a $cond operator to return the $$REMOVE marker variable if the category field is equal to RESTRICTED. This informs the aggregation engine to exclude the whole customer_info sub-document from the stage’s output for the record. Alternatively, the pipeline could have used a $redact stage to achieve the same. However, $redact typically has to perform more processing work due to needing to check every field in the document. Hence, if a pipeline is only to redact out one specific sub-document, use the approach outlined in this example. Regular Expression. For masking the card_name field, a regular expression operator is used to extract the last word of the field’s original value. $regexFind returns metadata into the stage’s output records, indicating if the match succeeded and what the matched value is. Therefore, an additional $set stage is required later in the pipeline to extract the actual matched word from this metadata and prefix it with some hard-coded text. Meaningful Insight. Even though the pipeline is irreversibly obfuscating fields, it doesn’t mean that the masked data is useless for performing analytics to gain insight. The pipeline masks some fields by fluctuating the original values by a small but limited random percentage (e.g. card_expiry, transaction_amount), rather than replacing them with completely random values (e.g. card_sec_code). In such cases, if the input data set is sufficiently large, then minor variances will be equalled out. For the fields that are only varied slightly, users can derive similar trends and patterns from analysing the masked data as they would the original data. Further Reading. This example is based on the output of two blog posts: 1) MongoDB Irreversible Data Masking, and 2) MongoDB Reversible Data Masking. 6.时间序列(1)IOT电力消耗由于使用时间序列集合、$setWindowFields阶段和$integral运算符，要求MongoDB版本最低为 5.0。 您正在监控工业园区两栋建筑中运行的各种空调机组。每 30 分钟，每个机组中的一个设备将该机组当前的功耗读数发送回基地，中央数据库将保留该读数。 您想分析此数据，以查看每个空调机组在过去一小时内针对收到的每个读数所消耗的能量（以千瓦时 (kWh) 为单位）。此外，您还想计算每个建筑物中所有空调机组每小时消耗的总能量。 首先创建一个device_readings集合，包含了两栋不同建筑物一天内的3个小时之间的设备读数，使用「时间序列集合」进行优化处理：123db.createCollection(&quot;device_readings&quot;, &#123;&quot;timeseries&quot;: &#123;&quot;timeField&quot;: &quot;timestamp&quot;, &quot;metaField&quot;: &quot;deviceID&quot;, &quot;granularity&quot;: &quot;minutes&quot;&#125;&#125; );注意，这个命令可以被注释掉，完整的例子仍然有效。device_readings集合的18条数据如下，分别为ABC和XYZ两栋建筑物的111、222和666三台设备在11:29am、11:59am、12:29pm、12:59pm、13:29pm、13:59pm的三个小时6个时段的电表读数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&#123; &quot;buildingID&quot;: &quot;Building-ABC&quot;, &quot;deviceID&quot;: &quot;UltraAirCon-111&quot;, &quot;timestamp&quot;: ISODate(&quot;2021-07-03T11:29:59Z&quot;), &quot;powerKilowatts&quot;: 8, &#125;, &#123; &quot;buildingID&quot;: &quot;Building-ABC&quot;, &quot;deviceID&quot;: &quot;UltraAirCon-222&quot;, &quot;timestamp&quot;: ISODate(&quot;2021-07-03T11:29:59Z&quot;), &quot;powerKilowatts&quot;: 7, &#125;, &#123; &quot;buildingID&quot;: &quot;Building-XYZ&quot;, &quot;deviceID&quot;: &quot;UltraAirCon-666&quot;, &quot;timestamp&quot;: ISODate(&quot;2021-07-03T11:29:59Z&quot;), &quot;powerKilowatts&quot;: 10, &#125;, &#123; &quot;buildingID&quot;: &quot;Building-ABC&quot;, &quot;deviceID&quot;: &quot;UltraAirCon-222&quot;, &quot;timestamp&quot;: ISODate(&quot;2021-07-03T11:59:59Z&quot;), &quot;powerKilowatts&quot;: 9, &#125;, &#123; &quot;buildingID&quot;: &quot;Building-ABC&quot;, &quot;deviceID&quot;: &quot;UltraAirCon-111&quot;, &quot;timestamp&quot;: ISODate(&quot;2021-07-03T11:59:59Z&quot;), &quot;powerKilowatts&quot;: 8, &#125;, &#123; &quot;buildingID&quot;: &quot;Building-XYZ&quot;, &quot;deviceID&quot;: &quot;UltraAirCon-666&quot;, &quot;timestamp&quot;: ISODate(&quot;2021-07-03T11:59:59Z&quot;), &quot;powerKilowatts&quot;: 11, &#125;, &#123; &quot;buildingID&quot;: &quot;Building-ABC&quot;, &quot;deviceID&quot;: &quot;UltraAirCon-222&quot;, &quot;timestamp&quot;: ISODate(&quot;2021-07-03T12:29:59Z&quot;), &quot;powerKilowatts&quot;: 9, &#125;, &#123; &quot;buildingID&quot;: &quot;Building-ABC&quot;, &quot;deviceID&quot;: &quot;UltraAirCon-111&quot;, &quot;timestamp&quot;: ISODate(&quot;2021-07-03T12:29:59Z&quot;), &quot;powerKilowatts&quot;: 9, &#125;, &#123; &quot;buildingID&quot;: &quot;Building-XYZ&quot;, &quot;deviceID&quot;: &quot;UltraAirCon-666&quot;, &quot;timestamp&quot;: ISODate(&quot;2021-07-03T12:29:59Z&quot;), &quot;powerKilowatts&quot;: 10, &#125;, &#123; &quot;buildingID&quot;: &quot;Building-ABC&quot;, &quot;deviceID&quot;: &quot;UltraAirCon-222&quot;, &quot;timestamp&quot;: ISODate(&quot;2021-07-03T12:59:59Z&quot;), &quot;powerKilowatts&quot;: 8, &#125;, &#123; &quot;buildingID&quot;: &quot;Building-ABC&quot;, &quot;deviceID&quot;: &quot;UltraAirCon-111&quot;, &quot;timestamp&quot;: ISODate(&quot;2021-07-03T12:59:59Z&quot;), &quot;powerKilowatts&quot;: 8, &#125;, &#123; &quot;buildingID&quot;: &quot;Building-XYZ&quot;, &quot;deviceID&quot;: &quot;UltraAirCon-666&quot;, &quot;timestamp&quot;: ISODate(&quot;2021-07-03T12:59:59Z&quot;), &quot;powerKilowatts&quot;: 11, &#125;, &#123; &quot;buildingID&quot;: &quot;Building-ABC&quot;, &quot;deviceID&quot;: &quot;UltraAirCon-222&quot;, &quot;timestamp&quot;: ISODate(&quot;2021-07-03T13:29:59Z&quot;), &quot;powerKilowatts&quot;: 9, &#125;, &#123; &quot;buildingID&quot;: &quot;Building-ABC&quot;, &quot;deviceID&quot;: &quot;UltraAirCon-111&quot;, &quot;timestamp&quot;: ISODate(&quot;2021-07-03T13:29:59Z&quot;), &quot;powerKilowatts&quot;: 9, &#125;, &#123; &quot;buildingID&quot;: &quot;Building-XYZ&quot;, &quot;deviceID&quot;: &quot;UltraAirCon-666&quot;, &quot;timestamp&quot;: ISODate(&quot;2021-07-03T13:29:59Z&quot;), &quot;powerKilowatts&quot;: 10, &#125;, &#123; &quot;buildingID&quot;: &quot;Building-ABC&quot;, &quot;deviceID&quot;: &quot;UltraAirCon-222&quot;, &quot;timestamp&quot;: ISODate(&quot;2021-07-03T13:59:59Z&quot;), &quot;powerKilowatts&quot;: 8, &#125;, &#123; &quot;buildingID&quot;: &quot;Building-ABC&quot;, &quot;deviceID&quot;: &quot;UltraAirCon-111&quot;, &quot;timestamp&quot;: ISODate(&quot;2021-07-03T13:59:59Z&quot;), &quot;powerKilowatts&quot;: 8, &#125;, &#123; &quot;buildingID&quot;: &quot;Building-XYZ&quot;, &quot;deviceID&quot;: &quot;UltraAirCon-666&quot;, &quot;timestamp&quot;: ISODate(&quot;2021-07-03T13:59:59Z&quot;), &quot;powerKilowatts&quot;: 11, &#125; 为了计算空调机组在过去一小时内针对收到的每个读数所消耗的能量，定义一个「原始读数」的聚合管道如下： 12345678910var pipelineRawReadings = [ &#123;&quot;$setWindowFields&quot;: &#123; &quot;partitionBy&quot;: &quot;$deviceID&quot;, &quot;sortBy&quot;: &#123;&quot;timestamp&quot;: 1&#125;, &quot;output&quot;: &#123;&quot;consumedKilowattHours&quot;: &#123; &quot;$integral&quot;: &#123;&quot;input&quot;: &quot;$powerKilowatts&quot;, &quot;unit&quot;: &quot;hour&quot;,&#125;, &quot;window&quot;: &#123;&quot;range&quot;: [-1, &quot;current&quot;],&quot;unit&quot;: &quot;hour&quot;,&#125;, &#125;&#125;, &#125;&#125;,]; 为了计算每个建筑物中所有空调机组每小时消耗的总能量，定义一个「建筑物概要」的聚合管道如下： 12345678910111213141516171819202122232425262728var pipelineBuildingsSummary = [ &#123;&quot;$setWindowFields&quot;: &#123; &quot;partitionBy&quot;: &quot;$deviceID&quot;, &quot;sortBy&quot;: &#123;&quot;timestamp&quot;: 1&#125;, &quot;output&quot;: &#123;&quot;consumedKilowattHours&quot;: &#123; &quot;$integral&quot;: &#123;&quot;input&quot;: &quot;$powerKilowatts&quot;, &quot;unit&quot;: &quot;hour&quot;,&#125;, &quot;window&quot;: &#123;&quot;range&quot;: [-1, &quot;current&quot;], &quot;unit&quot;: &quot;hour&quot;,&#125;, &#125;&#125;, &#125;&#125;, &#123;&quot;$sort&quot;: &#123;&quot;deviceID&quot;: 1, &quot;timestamp&quot;: 1&#125;&#125;, &#123;&quot;$group&quot;: &#123; &quot;_id&quot;: &#123; &quot;deviceID&quot;: &quot;$deviceID&quot;, &quot;date&quot;: &#123;&quot;$dateTrunc&quot;: &#123;&quot;date&quot;: &quot;$timestamp&quot;,&quot;unit&quot;: &quot;hour&quot;&#125;&#125;, &#125;, &quot;buildingID&quot;: &#123;&quot;$last&quot;: &quot;$buildingID&quot;&#125;, &quot;consumedKilowattHours&quot;: &#123;&quot;$last&quot;: &quot;$consumedKilowattHours&quot;&#125;, &#125;&#125;, &#123;&quot;$group&quot;: &#123; &quot;_id&quot;: &#123; &quot;buildingID&quot;: &quot;$buildingID&quot;, &quot;dayHour&quot;: &#123;&quot;$dateToString&quot;: &#123;&quot;format&quot;: &quot;%Y-%m-%d %H&quot;, &quot;date&quot;: &quot;$_id.date&quot;&#125;&#125;, &#125;, &quot;consumedKilowattHours&quot;: &#123;&quot;$sum&quot;: &quot;$consumedKilowattHours&quot;&#125;, &#125;&#125;, &#123;&quot;$sort&quot;: &#123;&quot;_id.buildingID&quot;: 1, &quot;_id.dayHour&quot;: 1&#125;&#125;, &#123;&quot;$set&quot;: &#123;&quot;buildingID&quot;: &quot;$_id.buildingID&quot;, &quot;dayHour&quot;: &quot;$_id.dayHour&quot;, &quot;_id&quot;: &quot;$$REMOVE&quot;&#125;&#125;, ]; 执行「原始读数」的聚合管道pipelineRawReadings，来计算空调机组在过去一小时内针对收到的每个读数所消耗的能量，返回的结果如下所示（简洁起见，省略_id字段）： 执行「建筑物概要」的聚合管道pipelineBuildingsSummary，来计算每个建筑物中所有空调机组每小时消耗的总能量，返回的结果如下所示： Integral Trapezoidal Rule. As documented in the MongoDB Manual, $integral “returns an approximation for the mathematical integral value, which is calculated using the trapezoidal rule”. For non-mathematicians, this explanation may be hard to understand. You may find it easier to comprehend the behaviour of the $integral operator by studying the illustration below and the explanation that follows: Essentially the trapezoidal rule determines the area of a region between two points under a graph by matching the region with a trapezoid shape that approximately fits this region and then calculating the area of this trapezoid. You can see a set of points on the illustrated graph with the matched trapezoid shape underneath each pair of points. For this IOT Power Consumption example, the points on the graph represent an air-conditioning unit’s power readings captured every 30 minutes. The Y-axis is the power rate in Kilowatts, and the X-axis is time to indicate when the device captured each reading. Consequently, for this example, the energy consumed by the air-conditioning unit for a given hour’s span is the area of the hour’s specific section under the graph. This section’s area is approximately the area of the two trapezoids shown. Using the $integral operator for the window of time you define in the $setWindowFields stage, you are asking for this approximate area to be calculated, which is the Kilowatt-hours consumed by the air-conditioning unit in one hour. Window Range Definition. For every captured document representing a device reading, this example’s pipeline identifies a window of 1-hour of previous documents relative to this current document. The pipeline uses this set of documents as the input for the $integral operator. It defines this window range in the setting range: [-1, &quot;current&quot;], unit: &quot;hour&quot;. The pipeline assigns the output of the $integral calculation to a new field called consumedKilowattHours. One Hour Range Vs Hours Output. The fact that the $setWindowFields stage in the pipeline defines unit: &quot;hour&quot; in two places may appear redundant at face value. However, this is not the case, and each serves a different purpose. As described in the previous observation, unit: &quot;hour&quot; for the &quot;window&quot; option helps dictate the size of the window of the previous number of documents to analyse. However, unit: &quot;hour&quot; for the $integral operator defines that the output should be in hours (“Kilowatt-hours” in this example), yielding the result consumedKilowattHours: 8.5 for one of the processed device readings. However, if the pipeline defined this $integral parameter to be &quot;unit&quot;: &quot;minute&quot; instead, which is perfectly valid, the output value would be 510 Kilowatt-minutes (i.e. 8.5 x 60 minutes). Optional Time Series Collection. This example uses a time series collection to store sequences of device measurements over time efficiently. Employing a time series collection is optional, as shown in the NOTE Javascript comment in the example code. The aggregation pipeline does not need to be changed and achieves the same output if you use a regular collection instead. However, when dealing with large data sets, the aggregation will complete quicker by employing a time series collection. Index for Partition By &amp; Sort By. In this example, you define the index &#123;deviceID: 1, timestamp: 1&#125; to optimise the use of the combination of the partitionBy and sortBy parameters in the $setWindowFields stage. This means that the aggregation runtime does not have to perform a slow in-memory sort based on these two fields, and it also avoids the pipeline stage memory limit of 100 MB. It is beneficial to use this index regardless of whether you employ a regular collection or adopt a time series collection.","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://hwame.top/categories/MongoDB/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://hwame.top/tags/MongoDB/"}]},{"title":"MongoDB聚合操作","slug":"mongodb-aggregation-operation","date":"2021-08-06T13:37:49.000Z","updated":"2021-08-10T16:15:06.000Z","comments":true,"path":"20210806/mongodb-aggregation-operation.html","link":"","permalink":"https://hwame.top/20210806/mongodb-aggregation-operation.html","excerpt":"摘要：7.26~8.6参加了为期12天的培训，MongoDB最重要的聚合也迟迟未能更新。","text":"摘要：7.26~8.6参加了为期12天的培训，MongoDB最重要的聚合也迟迟未能更新。 文章说明文章作者：鴻塵文章链接：https://hwame.top/20210806/mongodb-aggregation-operation.html参考资料： Aggregation: Version 5.0 latest Practical MongoDB Aggregations（by Paul Done） 聚合操作MongDDB中集合操作（aggregation）处理数据记录并返回计算结果，聚合操作将来自多个文档的值结合在一起，并且可以对分组数据执行各种操作以返回单个结果。 MongoDB提供了三种执行聚合操作的方法：聚合管道【最常用】、map-reduce函数 和 单一用途聚合方法。 聚合操作方法：db.collection.aggregate(pipeline=&lt;arr&gt;, options=[doc])。 pipeline，一系列数据聚合「操作operation」或「阶段stage」，详见聚合管道运算符。 我的理解是，pipeline是由「阶段stage（将operation也称stage更易于理解）」组成的数组，官方文档描述不贴切 / 或者说翻译字面意思过于近似，而且官方文档都在https://docs.mongodb.com/manual/reference/operator/aggregation/*同一路由下，没有区分「aggregation-stage」和「aggregation-operator」。 A sequence of data aggregation oparotions or stages.理解为stage，operation和operator的区别可以意会。 在禁用options参数时，可以将「管道阶段」作为单独的参数而不是数组中的元素。 通常「聚合管道」包括了「聚合管道 阶段stage」 和「聚合管道 操作符operator」。 管道阶段https://docs.mongodb.com/manual/aggregation/#aggregation-pipeline： 最基本的 管道阶段 提供「过滤器（与查询类似）」和「文档转换（修改输出形式）」。 其他 管道操作 提供工具，用于①按字段对文档进行分组和排序，②聚合数组内容或文档数组。 此外， 管道阶段 可以使用「运算符（操作符）operator」执行诸如计算平均值或连接字符串之类的任务。 管道操作符。 Accumulators used in GROUP stage aggregate例子$group当中的{$sum: 1}，按照$group的条件，满足一条就加1。如下例，也就是count是$group中，每种zipcode的数量：123456db.restaurants.aggregate([ &#123;$match: &#123;&quot;borough&quot;: &quot;Queens&quot;, &quot;cuisine&quot;: &quot;Brazilian&quot;&#125;&#125; &#123;$group: &#123;&quot;_id&quot;: &quot;$address.zipcode&quot;, &quot;count&quot;: &#123;$sum: 1&#125;&#125;&#125;]); &#123;$sum: 1&#125;等价于&#123;$count: &#123;&#125;&#125;。 1234567SELECT COUNT(*)FROM (SELECT cust_id, ord_date FROM orders GROUP BY cust_id, ord_date) as DerivedTable","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://hwame.top/categories/MongoDB/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://hwame.top/tags/MongoDB/"}]},{"title":"MongoDB增删改查","slug":"mongodb-crud-operations","date":"2021-07-16T00:37:42.000Z","updated":"2021-07-24T18:02:28.000Z","comments":true,"path":"20210716/mongodb-crud-operations.html","link":"","permalink":"https://hwame.top/20210716/mongodb-crud-operations.html","excerpt":"摘要：MongoDB学习过程中对CRUD用法的记录，毕竟好记性不如烂笔头。","text":"摘要：MongoDB学习过程中对CRUD用法的记录，毕竟好记性不如烂笔头。 文章说明文章作者：鴻塵文章链接：https://hwame.top/20210716/mongodb-crud-operations.html参考资料：MongoDB CRUD Operations: Version 5.0 latest 1.概述1.1.写作的动机由于工作需要，捡起了遗忘多时的MongoDB，项目中使用的是4.2版本，恰好本地电脑上多年前装的也是4.2版本，如今官方文档都已经更新到5.0了。 相比旧版本，5.0增加了一些新功能，比如聚合里的一些stage，4.2版本算是一个比较经典的版本吧（就好比mysql的5.7和8.0）。 决定记录的另一个动机，则是网上的教程不够全面，官方文档也没有中文版的，有些翻译很生硬且不准确： 书栈网 英文版教程MongoDB v4.2 Manual，与官方文档无异。 MongoDB (v3.4) 中文手册翻译不全，很多章节仍然是英文。 MongoDB入门指南和MongoDB学习总结过于简洁、不够全面。 MongoDB数据库最佳实践更侧重于实际应用，适合于进阶实战。 菜鸟教程的MongoDB教程相比上面几个要好得多，但是毕竟偏向入门，很多细节没有展开。 在比较之后遂决定啃最新的5.0官方文档，怎么说呢，任何问题都可以从中找到答案。 MongoDB提供了一个在线版的Mongo shell，默认为latest即v5.0，可以通过参数选择版本，例如https://mws.mongodb.com/?version=4.2。唯一的缺点就是连接维持的时间比较短，一不留神就断开了，重连会丢失之前的数据。 1.2.啃文档的一些感受这篇文章写的是CRUD，是相对比较基础的部分，目前在看管道聚合，准备写下一篇。 在看过几天文档（尤其是管道聚合部分）后有一些感受，主要来自管道聚合，但是估计下一篇内容会很多，这篇内容较少就放在这里吧。主要有以下几点： ①官方文档写的很细，例如Aggregation Pipeline Stages和Aggregation Pipeline Operators都有名为$count的累积器accumulator和管道阶段stage，Aggregation Pipeline Operators里有分别名为$first和$last的同名累积器accumulator和操作符operator。文档不厌其烦地在每个出现的地方都有「消除歧义Disambiguation」的提示，但这也导致了文档比较冗杂。 ②官方文档内容比较混乱，从路由上就可以看出来。比如Aggregation Pipeline Stages和Aggregation Pipeline Operators路由的命名分别为aggregation-pipeline和aggregation，但是这两个对应的类似$xxx的格式却都是https://docs.mongodb.com/manual/reference/operator/aggregation/xxx/，这难免让人摸不着头脑。为何不将路由命名为aggregation-pipeline-stages和aggregation-pipeline-operators，且将对应$xxx放到各自路径下呢？ ③官方文档内容分类不够具体，如果能按分类添加下级路由，那么文档的结构和层次会更清楚了。如下两例： 例如，Aggregation Pipeline Stages可分为「db.collection.aggregate()Stages」、「db.aggregate()Stages」和「Stages Available for Updates」三个部分，完全可以添加三个子路由啊。 还有，Aggregation Pipeline Operators操作表达式分为「算术表达式操作符」、「数组表达式操作符」、「布尔表达式操作符」、「比较表达式操作符」、「条件表达式操作符」、「自定义聚合表达式操作符」、「数据尺寸操作符」、「日期表达式操作符」、「字面表达式操作符」、「杂项操作符」、「对象表达式操作符」、「set表达式操作符」、「字符串表达式操作符」、「文本表达式操作符」、「三角函数表达式操作符」、「类型表达式操作符」、「$group阶段的累积器」、「非$group阶段的累积器」、「变量表达式操作符」和「窗口操作符」。单单是分类就已经有20个之多，内容那就更多了。如果按分类添加20个子路由，文档的结构和层次会更清楚了。 当然，文档很贴心地在Aggregation Pipeline Stages和Aggregation Pipeline Operators最后添加了按字母排序的列表（Alphabetical Listing）以供索引查阅。需要说明的是，各分类并不是互斥的，各类里面有重叠的项，大概这就是官方不予添加子路由的原因吧。 ④相近的概念没有辨析清楚【这里应该与翻译和表达有关，不全是官方的锅】，比如「管道聚合」里的stage和operation是并列的，operator用于stage/operation里，中文里「操作」一词即可作名词也可做动词，翻译阅读起来就会产生歧义，所以我把stage和operation统一当成「阶段」，operator则称为「操作符」或「操作表达式」。从这个层面上说，官方文档的描述还是很准确的，只不过全是长难句一连串的定语有时候都分不清修饰的到底是谁，引起理解上的歧义。 我们常说的CRUD即是「增删改查」，具体说来： C＝Create，增，即创建操作； R＝ Read ，查，即查询操作； U＝Update，改，即更新操作； D＝Delete，删，即删除操作。 2.创建操作创建/插入是针对单个集合而言，「写操作」在单个文档级别上具有「原子性」。如果当前集合不存在，则插入操作将创建该集合。1234# 插入单个文档是「&#123;&#125;」，多个是「[&#123;&#125;, &#123;&#125;, ...]」db.collection.insertOne() # 单个db.collection.insertMany() # 多个db.collection.insert() # 单个或多个与upsert: true 选项 一起使用时也可实现插入: db.collection.update()，db.collection.updateOne()，db.collection.updateMany()； db.collection.findAndModify()，db.collection.findOneAndUpdate()，db.collection.findOneAndReplace()； db.collection.bulkWrite()：Performs multiple write operations with controls for order of execution。 3.查询操作查询操作语法为db.collection.find(query, projection)，其中query指定查询条件，projection指定返回的字段。 以下示例使用inventory集合，包含如下数据：12345&#123; item: &quot;journal&quot;, qty: 25, size: &#123; h: 14, w: 21, uom: &quot;cm&quot; &#125;, status: &quot;A&quot; &#125;&#123; item: &quot;notebook&quot;, qty: 50, size: &#123; h: 8.5, w: 11, uom: &quot;in&quot; &#125;, status: &quot;A&quot; &#125;&#123; item: &quot;paper&quot;, qty: 100, size: &#123; h: 8.5, w: 11, uom: &quot;in&quot; &#125;, status: &quot;D&quot; &#125;&#123; item: &quot;planner&quot;, qty: 75, size: &#123; h: 22.85, w: 30, uom: &quot;cm&quot; &#125;, status: &quot;D&quot; &#125;&#123; item: &quot;postcard&quot;, qty: 45, size: &#123; h: 10, w: 15.25, uom: &quot;cm&quot; &#125;, status: &quot;A&quot; &#125; 选择集合中的所有文档：query=&#123;&#125;或query=（留空不写），相当于SELECT * FROM inventory。 指定相等条件：query=&#123;&lt;field1&gt;: &lt;valve1&gt;, ...&#125;，例如&#123;status: &quot;D&quot;&#125;相当于SELECT * FROM inventory WHERE status = &quot;D&quot;。 使用查询运算符（Query Operators）指定条件：&#123;&lt;field1&gt;: &#123;&lt;operator1&gt;: &lt;value1&gt;&#125;, ...&#125;，例如&#123;status: &#123;$in: [&quot;A&quot;, &quot;D&quot;]&#125;&#125;相当于SELECT * FROM inventory WHERE status in (&quot;A&quot;, &quot;D&quot;)【此处也可用$or，但对同一字段应该用$in而非$or】。 指定AND条件：&#123;&lt;and1&gt;: &lt;value1&gt;, &lt;and2&gt;: &lt;value2&gt;, ...&#125;，例如&#123;status: &quot;A&quot;, qty: &#123;$lt: 30&#125;&#125;相当于SELECT * FRON inventory WHERE status = &quot;A&quot; AND qty &lt; 30。 指定OR条件：&#123;$or: [&lt;query1&gt;, &lt;query2&gt;, ...]&#125;，例如&#123;$or: [&#123;status: “A&quot;&#125;, &#123;qty: &#123;$lt: 30&#125;&#125;]&#125;相当于SELECT * FROM inventory WHERE status = &quot;A&quot; OR qty &lt; 30。 指定AND以及OR条件【即 4＋5 组含】：&lt;and&gt;: &lt;value&gt;, $or: [&lt;query1&gt;, &lt;query2&gt;, ...]，例如&#123;status: &quot;A&quot;, $or: [qty: &#123;$lt: 30&#125;&#125;, &#123;item: /^p/&#125;]&#125;相当于SELECT * FROM inventory WHERE status = &quot;A&quot; AND (qty &lt; 30 OR item LIKE &quot;p%&quot;)【支持正则表达式】。 3.1.查询嵌入/嵌套文档 嵌套文档匹配即&lt;value = document&gt;，格式为：query=&#123;&lt;field1&gt;: &lt;doc1&gt;, ...&#125;，例如&#123;size: &#123;h: 14, w: 21，uom: &quot;cm&quot;&#125;&#125;；注意: 整个嵌入文档的相等匹配需要精确匹配，包括顺序! 嵌套字段匹配即嵌套文挡中字殿的匹配，字段使用点表示法：field.subField。 相等匹配：&#123;&lt;field.subField&gt;: &lt;value&gt;, ...&#125;，例如&#123;&quot;size.uom&quot;: &quot;in&quot;&#125;； 查询运算符：&#123;&lt;field1&gt;: &#123;&lt;operator1&gt;: &lt;value1&gt;&#125;, ...&#125;，例如&#123;&quot;size.h&quot;: &#123;$lt: 15&#125;&#125;，与 3. 相同； 指定AND条件：&#123;&lt;field1.subField1&gt;: &lt;valuel&gt;, ...&#125;，例加&#123;&quot;size.h&quot;: &#123;$lt: 15&#125;, &quot;size.uom&quot;: &quot;in&quot;, states: &quot;D&quot;&#125;，与 4. 相同。 3.2.查询数组 匹配一个数组，即value = array，精确匹配包括顺序。 例如&#123;tags: [&quot;red&quot;, &quot;black&quot;]&#125;只匹配包含2个元素的定序的[&quot;red&quot;, &quot;black&quot;]； 若要匹配无序的包含此2元素的数组（len ≥ 2），则需使用$all运算符：&#123;tags: &#123;$all: [&quot;red&quot;, &quot;black&quot;]&#125;&#125;。 查询一个元素的数组（包含指定元素的数组），即arrField = arrValue。 例如&#123;tags: &quot;red&quot;&#125;匹配&quot;red&quot; in array(tags)； 可以对arrValue指定条件过滤器，即&#123;arrField1: &#123;operator1: value1, ...&#125;&#125;，例如&#123;dim_cm: &#123;$gt: 25&#125;&#125;匹配any(dim_cm[i] &gt; 25)，即dim_cm中存在大于25的元素。 为数组元素指定多个条件（复合条件），使 单个数组元素 满足这些条件或 数组元素的任意组合 满足条件。 在数组元素上使用复合过滤条件查询数组：数组中存在满足条件的元素（这些元素同时存在于该数组即可，无需是同一个元素），例如&#123;dim_cm: &#123;Sgt: 15, slt: 20&#125;&#125;表示dim_cm[i] &gt; 15 AND dim_cm[j] &lt; 20或15 &lt; dim_cm[kJ &lt; 20； 查询满足多个条件的数组元素：一个元素同时满足条件，例如&#123;dim_cm: &#123;$elemMatch: &#123;Sgt: 15, $lt: 20&#125;&#125;&#125;表示15 &lt; dim_cm[i] &lt; 20； 通过数组索引位置查询元素：点表示法（dot notation）可以为指定位置的元素设置条件，索引从0开始【 字段和嵌套字段必须在引号内 】，例如&#123;&quot;dim_cm.1&quot;: &#123;$gt: 25&#125;&#125;表示dim_cm[1] &gt; 25； 按数组长度查询数组：&#123;&quot;tags&quot;: &#123;$size: 3&#125;&#125;表示len(tags) = 3。 3.3.查询嵌套文档数组 嵌套文档数组（Array of Embedded Documents）即以文档为元素的数组，集合inventory文档格式为&#123;item: &quot;xx&quot;, instock: [&#123;warehouse: &quot;A&quot;, qty: 5&#125;, &#123;&#125;...]&#125;。 查询嵌套在数组中的文档：&#123;field: doc&#125;即doc in array(field)（查询数组2：包含指定元素的数组），doc精确匹配包括顺序。例如&#123;&quot;instock&quot;: &#123;warehouse: &quot;A&quot;, qty: 5&#125;&#125;匹配的数组instock包含整个「有序」文档&#123;warehouse: &quot;A&quot;, qty: 5&#125;。 在文档数组中的字段上指定查询条件【点表示法 字段和嵌套字段必须在引号内 】。 对嵌入在文档数组中的字段指定查询条件：例如&#123;&#39;instock.qty&#39;: &#123;$lte: 20&#125;&#125;匹配数组元素instock[i] = doc，doc.qty ≤ 20，不检查doc位置； 使用数组索引查询嵌入文档中的字段: 例如&#123;&#39;instock.0.qty&#39;: &#123;$lte: 20&#125;&#125;匹配数组元素instock[0] = doc，doc.qty ≤ 20，指定doc位置为0，因此结果是上一个的 子集 。 为文档数组指定多个条件，使得数组中的文档或文档组合满足条件。 单个嵌套文档在嵌套字段上满足多个查询条件，例如&#123;&quot;instock&quot;: &#123;$elemMatch: &#123;qty: 5, warehouse: &quot;A&quot;&#125;&#125;&#125;匹配instock[i]=doc，&#123;qty: 5, warehouse: &quot;A&quot;&#125; in doc，此处doc包含这两值即可且无序。再如&#123;&quot;instock&quot;: &#123;$elemMatch: &#123;qty: &#123;$gt: 10, $lte: 20&#125;&#125;&#125;&#125;匹配instock[i]=doc，10 &lt; doc.qty &lt; 20； 元素组合满足条件， 若数组字段上的复合查询条件不使用$elemMatch运算行，则匹配「文档组合满足条件的数组」，注意是 文档组合 满足而非 文档 满足。例如&#123;&quot;instock.qty&quot;: &#123;$gt: 10, $lte: 20&#125;&#125;匹配instock[i].qty &gt; 10，instock[j].qty &lt; 20【上一个是单个文档同时满足，使用了$elemMatch】。类似的，&#123;&quot;instock.qty&quot;: 5, &quot;instock.warehouse&quot;: &quot;A&quot;&#125;将匹配instock[i].qty = 5，instock[j].warehouse = &quot;A&quot;而不要求位于同一文档中。 3.4.从查询返回指定字段 从查询返回指定字段即投影（Projection），查询语法db.inventory.find(query, projection)，其中projection.field = (1=true | 0=false)。查询默认返回所有字段【相当于SELECT *】，使用投影（Projection）来指定或限制返回的字段【相当于SELECT field1, field2...】。 返回匹配文档中的所有字段：不指定projection相当于SELECT *。 仅返回指定字段和_id：projection = &#123;field1: 1, field2: 1&#125;，默认会返回_id字段，相当于SELECT _id, field1, field2。 禁用_id字段，通过 显式地置0 从结果中删除_id字段：projection = &#123;field1: 1, field2: 1, _id: 0&#125;。 返回除排除字段之外的所有字段（补集思想），通过置0来排除字段，返回剩下的字段。 注意： 除了_id字段以外，不能在projection文档中对「包含和排除语句」进行组合，即不能同时出现0和1。 返回/禁用嵌套文档中的特定字段：使用点表示法指定嵌套文档中的特定字段，如projection = &#123;item: 1, status: 1, &quot;size.uom&quot;: 1&#125;、projection = &#123;&quot;size.uom&quot;: 0&#125;。 数组中嵌入文档的投影，使用点表示法在嵌入数组的文档中投影特定字段，例如projection = &#123;item: 1, status: 1, &quot;instock.qty&quot;: 1&#125;的查询结果中instock数组元素（即doc文档）只有qty字段。 在返回的数组中投影指定数组元素：对于包含了数组的字段，投影算子elemMatch`、`$slice`和`用来操作数组。例如projection = &#123;item: 1, status: 1, instock: &#123;$slice: -1&#125;&#125; 表示只取instock数组最后一个元素。 上述3个投影算子是「从返回数组中」投影「指定元素」的 唯一 方法。也就是说，不能使用素引&#123;&quot;instock.0&quot;: 1&#125;，将报错SyntaxError expected property name, got &#39;&#123;&#39;。 3.5.查询空字段或缺失字段MongoDB中的不同查询运算符对null值的处理方式不同。查询语法db.inventory.find(query, projection)，示例集合inventory为：12&#123; _id: 1, item: null&#125;&#123; _id: 2&#125; 相等过滤器：query = &#123;item: null&#125;查询匹配item = null OR !item，结果返回所有的两个文档。 类型检查：query = &#123;item: &#123;$type: 10&#125;&#125;查询匹配item = null即字段item的值为「BSON类型值Null，其类型编号为10」，结果返回_id = 1的文档。 存在检查，$exists检查是否存在指定字段：query = &#123;item: &#123;$exists: false&#125;&#125;查询匹配!item即exists(item) = false，结果返回_id = 2的文档（不包含item字段）。 4.更新操作更新操作用于修改集合中已有的文档，在单个文档级别上具有「原子性」，（与「增」相同）。可以指定条件或过滤器，来进行更新：123db.collection.updateOne(&lt;filter&gt;, &lt;update&gt;, &lt;options&gt;)db.collection.updateMany(&lt;filter&gt;, &lt;update&gt;, &lt;options&gt;)db.collection.replaceOne(&lt;filter&gt;, &lt;update&gt;, &lt;options&gt;)利用更新操作符如$set来修改字段值，「更新方法」的格式：注意：如果字段不存在，某些更新运算符（例如$set）将创建该字段。1234&#123; &lt;update_operator1&gt;: &#123;&lt;field1&gt;: &lt;value1&gt;, ...&#125;, &lt;update_operator2&gt;: &#123;&lt;field2&gt;: &lt;value2&gt;, ...&#125;,&#125; 例1：更新单个文档例如原文档：&#123;item: &quot;paper&quot;, qty: 100, size: &#123;h: 8.5, w: 11, uom: &quot;in&quot;&#125;, status: &quot;D&quot;&#125;；更新后文档：&#123;item: &quot;paper&quot;, qty: 100, size: &#123;h: 8.5, w: 11, uom: &quot;cm&quot;&#125;, status: &quot;P&quot;, lastModified: ISODate(&quot;2021-07-21T02:40:43.515Z&quot;)&#125;。更新操作： 使用$set修改&quot;size.uom&quot; = &quot;cm&quot;和status = &quot;p&quot;； 使用$currentDate将lastModified更新为当前日期，不存在的字段将被创建。 1234567db.inventory.updateOne( &#123;item: &quot;paper&quot;&#125;, &#123; $set: &#123;&quot;size.uom&quot;: &quot;cm&quot;, status: &quot;P&quot;&#125;, $currentDate: &#123;lastModified: true&#125; &#125;) 例2：更新多个文档123456789# 例如原文档&#123;item: &quot;journal&quot;, qty: 25, size: &#123;h: 14, w: 21, uom: &quot;cm&quot;&#125;, status: &quot;A&quot;&#125;,&#123;item: &quot;mousepad&quot;, qty: 25, size: &#123;h: 19, w: 22.85, uom: &quot;cm&quot;&#125;, status: &quot;P&quot;&#125;,&#123;item: &quot;postcard&quot;, qty: 45, size: &#123;h: 10, w: 15.25, uom: &quot;cm&quot;&#125;, status: &quot;A&quot;&#125;# 更新后文档&#123;item: &quot;journal&quot;, qty: 25, size: &#123;h: 14, w: 21, uom: &quot;in&quot;&#125;, status: &quot;P&quot;, lastModified: ISODate(&quot;2021-07-21T02:56:56.020Z&quot;)&#125;,&#123;item: &quot;mousepad&quot;, qty: 25, size: &#123;h: 19, w: 22.85, uom: &quot;in&quot;&#125;, status: &quot;P&quot;, lastModified: ISODate(&quot;2021-07-21T02:56:56.020Z&quot;)&#125;,&#123;item: &quot;postcard&quot;, qty: 45, size: &#123;h: 10, W: 15.25, uom: &quot;in&quot;&#125;, status: &quot;P&quot;, lastModified: ISODate(&quot;2021-07-21T02:56:56.020Z&quot;)&#125; 更新操作: 更新满足qty &lt; 50的所有文档（例1中qty = 100）； 使用$set修改&quot;size.uom&quot; = &quot;in&quot;和status = &quot;p&quot;； 使用$currentDate将lastModified更新为当前日期，不存在的字段将被创建。 1234567db.inventory.updateMany( &#123;&quot;qty&quot;: &#123;$lt: 50&#125;&#125;, &#123; $set: &#123;&quot;size.uom&quot;: &quot;in&quot;, status: &quot;P&quot;&#125;, $currentDate: &#123;LastModified: true&#125; &#125;) 例3:替换单个文档例如文档的更新情况： 原始示例文档：&#123;item: &quot;paper&quot;, qty: 100, size: &#123;h: 8.5, w: 11, uom: &quot;in&quot;&#125;, status: &quot;D&quot;&#125;； 例1修改后文档：&#123;item: &quot;paper&quot;, qty: 100, size: &#123;h: 8.5, w: 11, uom: &quot;cm&quot;&#125;, status: &quot;P&quot;, lastModified: ISODate(&quot;2021-07-21T02:40:43.515Z&quot;)&#125;； 例3修改后文档：&#123;item: &quot;paper&quot;, instock: [&#123;warehouse: &quot;A&quot;, qty: 60&#125;, &#123;warehouse: &quot;B&quot;, qty: 40&#125;]&#125;。 更新操作，直接修改整个item字段为paper的文档：1234db.inventory.replaceOne( &#123;item: &quot;paper&quot;&#125;, &#123;item: &quot;paper&quot;, instock: [&#123;warehouse: &quot;A&quot;, qty: 60&#125;, &#123;warehouse: &quot;B&quot;, qty: 40&#125;]&#125;) 使用聚合管道更新从MongoDB 4.2开始，更新操作可以使用聚合管道（Aggregation Pipeline），聚合管道可以由以下stage组成：$addFields、$set、$project、$unset、$replaceRoot和$repaceWith。 使用聚合管道允许更具表现力的update语句，例如基于当前字段值来表示条件更新，或者使用另一个字段的值更新一个字段。 示例1。db.students.updateOne(&#123;_id: 3&#125;, [&#123;$set: &#123;&quot;test3&quot;: 98，modified: &quot;$$NOW&quot;&#125;&#125;])更新文档_id: 3，其中$setstage将创建不存在的字段test3 = 98，并将字段modified更新为当前时间。该操作使用「聚合变量（aggregation variable）」NOW获取当前时间，使用「双dollar符前缀」并「加引号」来访问变量：&quot;$$NOW&quot;。 示例2。使用聚合管道来标准化文档中的字段，即集合中的文档应具有相同的字段，同时更新modified字段。其中： 带有$mergeObjects表达式的$replaceRootstage用来为quiz1、quiz2、test1和test2字段设置默认值，聚合变量ROOT指的是当前正在修改的文档。当前文档字段将覆盖默认值。 $setstage将modified字段更新为当前时间。123456789101112131415161718db.students2.insertMany([ &#123;&quot;_id&quot;: 1, quiz1: 8, test2: 100, quiz2: 9, modified: new Date(&quot;01/05/2020&quot;)&#125;, &#123;&quot;_id&quot;: 2, quiz2: 5, test1: 80, test2: 89, modified: new Date(&quot;01/05/2020&quot;)&#125;,])db.students2.updateMany(&#123;&#125;, [ &#123;$replaceRoot: &#123;newRoot: &#123;$mergeObjects: [&#123;quiz1: 0, quiz2: 0, test1: 0, test2: 0&#125;, &quot;$$ROOT&quot;]&#125; &#125; &#125;, &#123;$set: &#123;modified: &quot;$$NOW&quot;&#125;&#125; ])# 结果：# &#123;_id: 1, quiz1: 8, quiz2: 9, test1: 0, test2: 100, modified: ISODate(&quot;2021-07-21T04:03:43.185Z&quot;)&#125;,# &#123;_id: 2, quiz1: 0, quiz2: 5, test1: 80, test2: 89, modified: ISODate(&quot;2021-07-21T04:03:43.185Z&quot;)&#125; 示例3。使用聚合管道来计算「平均分数和成绩等级」，同时更新modified字段。其中： 第一个$setstage用来①计算tests数组的平均值（&#123;$avg: &quot;$tests&quot;&#125;）并截断取整（&#123;$trunc: [&lt;number&gt;, 0]&#125;），将取整的值赋给average并创建；②将modified字段更新为当前时间。【$trunc用法】 第二个$setstage根据上一步的average，使用$switch表达式创建grade。【$switch用法】12345678910111213141516171819202122232425db.students3.insert([ &#123;&quot;_id&quot;: 1, &quot;tests&quot;: [95, 92, 98], &quot;modified&quot;: ISODate(&quot;2019-01-01T00:00:00Z&quot;)&#125;, &#123;&quot;_id&quot;: 2, &quot;tests&quot;: [94, 88, 90], &quot;modified&quot;: ISODate(&quot;2019-01-01T00:00:00Z&quot;)&#125;, &#123;&quot;_id&quot;: 3, &quot;tests&quot;: [70, 75, 82], &quot;modified&quot;: ISODate(&quot;2019-01-01T00:00:00Z&quot;)&#125;]);db.students3.updateMany(&#123;&#125;, [ &#123;$set: &#123;average: &#123;$trunc [&#123;$avg: &quot;$tests&quot;&#125;, 0]&#125;, modified: &quot;$$NOW&quot;&#125;&#125;, &#123;$set: &#123;grade: &#123;$switch: &#123; branches: [ &#123;case: &#123;$gte: [&quot;$average&quot;, 90]&#125;, then: &quot;A&quot;&#125;, &#123;case: &#123;$gte: [&quot;$average&quot;, 80]&#125;, then: &quot;B&quot;&#125;, &#123;case: &#123;$gte: [&quot;$average&quot;, 70]&#125;, then: &quot;C&quot;&#125;, &#123;case: &#123;$gte: [&quot;$average&quot;, 60]&#125;, then: &quot;D&quot;&#125; ], default: &quot;F&quot; &#125;&#125;&#125;&#125; ])# 结果：# &#123;&quot;_id&quot;: 1, &quot;tests&quot;: [95, 92, 90], &quot;modified&quot;: ISODate(&quot;2021-07-21T06:06:50.533Z&quot;), &quot;average&quot;: 92, &quot;grade&quot;: &quot;A&quot;&#125;,# &#123;&quot;_id&quot;: 2, &quot;tests&quot;: [94, 88, 90], &quot;modified&quot;: ISODate(&quot;2021-07-21T06:06:50.533Z&quot;), &quot;average&quot;: 90, &quot;grade&quot;: &quot;A&quot;&#125;,# &#123;&quot;_id&quot;: 3, &quot;tests&quot;: [70, 75, 82], &quot;modified&quot;: ISODate(&quot;2021-07-21T06:06:50.533Z&quot;), &quot;average&quot;: 75, &quot;grade&quot;: &quot;C&quot;&#125;, 示例4。使用聚合管道进行array的拼接:12345678910111213141516db.students4.insertMany([ &#123;&quot;_id&quot;: 1, &quot;quizzes&quot;: [4, 6, 7]&#125;, &#123;&quot;_id&quot;: 2, &quot;quizzes&quot;: [5]&#125;, &#123;&quot;_id&quot;: 3, &quot;quizzes&quot;: [10, 10, 10]&#125;])db.students4.updateOne(&#123;_id: 2&#125;, [ &#123;$set: &#123;quizzes: &#123;$concatArrays: [&quot;$quizzes&quot;, [8, 6]]&#125;&#125;&#125; ])# 结果:# &#123;&quot;_id&quot;: 1, &quot;quizzes&quot;: [4, 6, 7]&#125;,# &#123;&quot;_id&quot;: 2, &quot;quizzes&quot;: [5, 8, 6]&#125;,# &#123;&quot;_id&quot;: 3, &quot;quizzes&quot;: [10, 10, 10]&#125; 示例5。使用聚合管道将「摄氏温度」转换为「华氏温度」，其中： 管道包含$addFieldsstage（与$set等价），用以创建新的数组字段tempsF（包含华氏温度的数组）； 该stage使用$map``$add和$multiply表达式来进行温度转换$F=C\\times \\frac{9}{5}+32$。【$map用法，对len(tempsC)无要求】12345678910111213141516171819202122db.temperatures.insertMany([ &#123;&quot;_id&quot;: 1, &quot;date&quot;: ISODate(&quot;2019-06-23&quot;), &quot;tempsC&quot;: [ 4, 12, 17]&#125;, &#123;&quot;_id&quot;: 2, &quot;date&quot;: ISODate(&quot;2019-07-07&quot;), &quot;tempsC&quot;: [14, 24, 11]&#125;, &#123;&quot;_id&quot;: 3, &quot;date&quot;: ISODate(&quot;2019-10-30&quot;), &quot;tempsC&quot;: [18, 6, 8]&#125;])db.temperatures.updateMany(&#123;&#125;, [ &#123;$addFields: &#123;&quot;tempsF&quot;: &#123; $map: &#123; input: &quot;$tempsC&quot;, as: &quot;celsius&quot;, in: &#123;$add: [&#123;$multiply: [&quot;$$celsius&quot;, 9/5]&#125;, 32]&#125; &#125; &#125;&#125;&#125; ])# 结果：# &#123;&quot;_id&quot;: 1, &quot;date&quot;: ISODate(&quot;2019-06-23T00:00:00.000Z&quot;), &quot;tempsC&quot;: [ 4, 12, 17], &quot;tempsF&quot;: [39.2, 53.6, 62.6]&#125;,# &#123;&quot;_id&quot;: 2, &quot;date&quot;: ISODate(&quot;2019-07-07T00:00:00.000Z&quot;), &quot;tempsC&quot;: [14, 24, 11], &quot;tempsF&quot;: [57.2, 75.2, 51.8]&#125;,# &#123;&quot;_id&quot;: 3, &quot;date&quot;: ISODate(&quot;2019-10-30T00:00:00.000Z&quot;), &quot;tempsC&quot;: [18, 6, 8], &quot;tempsF&quot;: [64.4, 42.8, 46.4]&#125; update方法12345678db.collection.updateOne()db.collection.updateMany()db.collection.replaceOne()db.collection.update()db.collection.findOneAndReplace()db.collection.findOneAndUpdate()db.collection.findAndModify()db.collection.bulkWrite() 5.删除操作从集合中删除文档，具有「原子性」，也可指定条件或过滤器：12db.collection.deleteOne(filter)db.collection.deleteMany(filter) 删除所有文档。将过滤器文档置空：db.inventory.deleteMany(&#123;&#125;)。 删除所有符合条件的文档。指定用于标识要删除文档的条件或过滤器，过滤器语法与查询操作相同。在「查询过滤器文档（query filter docuent）」中使用field: value表达式来指定相等匹配条件：&#123;&lt;field1&gt;: &lt;value1&gt;, ...&#125;，同理，将value替换成「查询操作符」来指定匹配条件：&#123;&lt;field1&gt;: &#123;&lt;operator1&gt;: &lt;value1&gt;&#125;, ...&#125;。 只删除一个符合条件的文档。即使多个文档相匹配，也只删除第一个：db.collection.deleteOne(filter)。 删除方法： db.collection.deleteOne()； db.collection.deleteMany()； db.collection.remove()； db.collection.findOneAndDelete()； db.collection.findAndModify()； db.collection.bulkWrite()。","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://hwame.top/categories/MongoDB/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://hwame.top/tags/MongoDB/"}]},{"title":"Python虚拟环境","slug":"python-virtual-environment","date":"2021-06-28T23:54:48.000Z","updated":"2021-07-08T00:04:25.000Z","comments":true,"path":"20210629/python-virtual-environment.html","link":"","permalink":"https://hwame.top/20210629/python-virtual-environment.html","excerpt":"摘要：本文介绍Python中常用虚拟环境的用法。","text":"摘要：本文介绍Python中常用虚拟环境的用法。 文章说明文章作者：鴻塵参考资料： Python中文指南第十二章：虚拟环境 12.1 【虚拟环境】为什么要有虚拟环境？ 12.2 【虚拟环境】方案一：使用 virtualenv 12.3 【虚拟环境】方案二：使用 pipenv 12.4 【虚拟环境】方案三：使用 pipx 12.5 【虚拟环境】方案四：使用 poetry Python标准库venv-创建虚拟环境 Python 虚拟环境的使用-virtualenv/virtualenvwrapper、pycharm使用 Runoob Python tutorial-虚拟环境和包-pyvenv Python为什么要使用虚拟环境-Python虚拟环境的安装和配置-virtualenv 知乎：最全的Python虚拟环境使用方法-virtualenv/conda/pipenv 文章链接：Python虚拟环境文章说明接：这片文章是复制的Python中文指南第十二章：虚拟环境，后面再慢慢整理吧慢慢改吧。 虚拟环境所谓虚拟环境（virtual environment），是指一种采用协作式隔离的运行时环境，允许 Python 用户和应用程序在安装和升级 Python 分发包时不会干扰到同一系统上运行的其他 Python 应用程序的行为。 使用虚拟环境有以下优点： 使不同应用开发环境独立； 环境升级不影响其他应用，也不会影响全局的python环境； 可以防止系统中出现包管理混乱和版本的冲突； 不同环境中Python依赖包相互独立，互不干扰。 管理Python版本和环境的工具有很多，常用的有以下几种： venv：Python自带的模块， virtualenv： virtualenvwrapper： pipenv： pyvenv： 12.1【虚拟环境】为什么要有虚拟环境？虚拟环境的意义，就如同虚拟机 一样，它可以实现不同环境中Python依赖包相互独立，互不干扰。 举个例子吧。 假设我们的电脑里有两个项目，他们都用到同一个第三方包，本来一切都顺利。但是由于某种原因，项目B由于某些原因要使用这个第三方包的一些新特性（新版本才有），而如果就这样贸然升级了，对项目A的影响我们无法评估，这个时候我们就特别需要有一种解决方案可以让项目A和B，处于两个不同的Python环境中。互不影响。 为了方便大家对虚拟环境有个认识，我列举了下其优点： 使不同应用开发环境独立 环境升级不影响其他应用，也不会影响全局的python环境 可以防止系统中出现包管理混乱和版本的冲突 市场上管理 Python 版本和环境的工具有很多，这里列举几个： p：非常简单的交互式 python 版本管理工具。 pyenv：简单的 Python 版本管理工具。 Vex：可以在虚拟环境中执行命令。 virtualenv：创建独立 Python 环境的工具。 virtualenvwrapper：virtualenv 的一组扩展。 工具很多，但个人认为最好用的，当属 virtualenvwrapper，推荐大家也使用。 12.2 【虚拟环境】方案一：使用 virtualenv1. 安装virtualenv由于 virtualenvwrapper 是 virtualenv 的一组扩展，所以如果要使用 virtualenvwrapper，就必须先安装 virtualenv。 基本使用 由于virtualenv创建虚拟环境是在当前环境下创建的。所以我们要准备一个专门存放虚拟环境的目录。（以下操作在Linux在完成，windows相对简单，请自行完成，有不明白的请微信与我联系。） 创建 123456789101112131415## 准备目录并进入$ mkdir -p /home/wangbm/Envs$ cd !$## 创建虚拟环境（按默认的Python版本）## 执行完，当前目录下会有一个my_env01的目录$ virtualenv my_env01## 你也可以指定版本$ virtualenv -p /usr/bin/python2.7 my_env01$ virtualenv -p /usr/bin/python3.6 my_env02## 你肯定觉得每次都要指定版本，相当麻烦吧？## 在Linux下，你可以把这个选项写进入环境变量中$ echo &quot;export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python2.7&quot; &gt;&gt; ~/.bashrc 进入/退出 1234567$ cd /home/wangbm/Envs## 进入$ source my_env01/bin/activate## 退出$ deactivate 删除删除虚拟环境，只需删除对应的文件夹就行了。并不会影响全局的Python和其他环境。 12$ cd /home/wangbm/Envs$ rm -rf my_env01 注意：创建的虚拟环境，不会包含原生全局环境的第三方包，其会保证新建虚拟环境的干净。 如果你需要和全局环境使用相同的第三方包。可以使用如下方法： 12345## 导出依赖包$ pip freeze &gt; requirements.txt## 安装依赖包$ pip install -r requirements.txt 2. 使用 virtualenvwrappervirtualenv 虽然已经相当好用了，可是功能还是不够完善。 你可能也发现了，要进入虚拟环境，必须得牢记之前设置的虚拟环境目录，如果你每次按规矩来，都将环境安装在固定目录下也没啥事。但是很多情况下，人是会懒惰的，到时可能会有很多个虚拟环境散落在系统各处，你将有可能忘记它们的名字或者位置。 还有一点，virtualenv 切换环境需要两步，退出 -&gt; 进入。不够简便。 为了解决这两个问题，virtualenvwrapper就诞生了。 安装 12345## 安装 - Linuxpip install virtualenvwrapper## 安装 - Windowspip install virtualenvwrapper-win 配置先find一下virtualenvwrapper.sh文件的位置 12find / -name virtualenvwrapper.sh## /usr/bin/virtualenvwrapper.sh 若是 windows 则使用everything 查找 virtualenvwrapper.bat 脚本 1D:\\Program Files (x86)\\Python38-32\\Scripts\\virtualenvwrapper.bat 在~/.bashrc 文件新增配置 1234export WORKON_HOME=$HOME/.virtualenvsexport PROJECT_HOME=$HOME/workspaceexport VIRTUALENVWRAPPER_SCRIPT=/usr/bin/virtualenvwrapper.shsource /usr/bin/virtualenvwrapper.sh 若是 windows 则新增环境变量：WORKON_HOME 基本语法： mkvirtualenv [-a project_path] [-i package] [-r requirements_file] [virtualenv options] ENVNAME 常用方法 123456789101112131415161718## 创建$ mkvirtualenv my_env01## 进入$ workon my_env01## 退出$ deactivate## 列出所有的虚拟环境，两种方法$ workon$ lsvirtualenv## 在虚拟环境内直接切换到其他环境$ workon my_env02## 删除虚拟环境$ rmvirtualenv my_env01 其他命令 1234567891011121314151617181920## 列出帮助文档$ virtualenvwrapper## 拷贝虚拟环境$ cpvirtualenv ENVNAME [TARGETENVNAME]## 在所有的虚拟环境上执行命令$ allvirtualenv pip install -U pip## 删除当前环境的所有第三方包$ wipeenv## 进入到当前虚拟环境的目录$ cdsitepackages## 进入到当前虚拟环境的site-packages目录$ cdvirtualenv## 显示 site-packages 目录中的内容$ lssitepackages 更多内容，可查看 官方文档https://virtualenvwrapper.readthedocs.io/en/latest/command_ref.html 3. 实战演示以上内容，是一份使用指南。接下来，一起来看看，如何在项目中使用虚拟环境。 如何使用在我们的开发中使用我们的虚拟环境呢 通常我们使用的场景有如下几种 交互式中 PyCharm中 工程中 接下来，我将一一展示。 3.1 交互式中先对比下，全局环境和虚拟环境的区别，全局环境中有requests包，而虚拟环境中并未安装。当我们敲入 workon my_env01，前面有my_env01的标识，说明我们已经处在虚拟环境中。后面所有的操作，都将在虚拟环境下执行。 3.2 工程项目中我们的工程项目，都有一个入口文件，仔细观察，其首行可以指定Python解释器。 倘若我们要在虚拟环境中运行这个项目，只要更改这个文件头部即可。 现在我还是以，import requests 为例，来说明，是否是在虚拟环境下运行的，如果是，则和上面一样，会报错。 文件内容： 1234#!/root/.virtualenvs/my_env01/bin/pythonimport requestsprint &quot;ok&quot; 运行前，注意添加执行权限。 1$ chmod +x ming.py 好了。来执行一下 1$ ./ming.py 发现和预期一样，真的报错了。说明我们指定的虚拟环境有效果。 3.3 PyCharm中点击 File - Settings - Project - Interpreter点击小齿轮。如图点击添加，按提示添加一个虚拟环境。然后点 OK 就可以使用这个虚拟环境，之后的项目都会在这个虚拟环境下运行。 12.3 【虚拟环境】方案二：使用 pipenv以前一直使用pip+virtualenv+virtualwrapper管理模块和环境， 但是virtualwrapper在windows上使用不太方便，而且包和环境分开管理确实经常不记得哪个是哪个了。 为什么 会推荐 pipenv 呢？ 它是 virtualenv 和 pip 的合体，可以合起来使用； 使用Pipfile 和 Pipfile.lock替代requirements.txt 可以使用 pipenv graph很方便的看出包的依赖关系。 通过加载.env文件简化开发工作流程 1. 安装pipenv如果你的电脑上没有安装 pipenv，可以使用如下方法安装 12345## mac$ brew install pipenv## windows$ pip install [--user] pipenv 如果你的电脑是 windows 的。 需要将如标示路径，加入到 环境变量 PATH 中。 然后需要重启一下，CMD 终端才能够刷新环境变量。 2. 创建虚拟环境DjangoWebBlog 是我们的项目目录，进入这个目录下创建虚拟环境 1234$ mkdir DjangoWebBlog &amp;&amp; cd DjangoWebBlog## 在当前目录下创建一个虚拟环境（默认的Python版本）$ pipenv install 你也可以指定版本创建 12345$ pipenv --two # 相当于 pipenv --python /usr/bin/python2$ pipenv --three # 相当于 pipenv --python /usr/bin/python3$ pipenv --python 3.7 # 也可以指定具体的版本pipenv install --python 2 这边以安装 python2 版本的虚拟环境为例说明。 如果你原项目使用的是 requirements.txt 这个管理包的方式，这时候执行 pipenv --tow 创建一个虚拟环境后，会找到 requirements.txt ，并根据这里面的依赖包生成 Pipfile文件。 3. 查询虚拟环境12345678## 返回项目的路径$ pipenv --where## 返回虚拟环境路径$ pipenv --venv## 返回该虚拟环境的解释器$ pipenv --py 演示如下： 4. 操作虚拟环境123456789## 进入这个虚拟环境$ pipenv shell## 退出这个虚拟环境$ exit$ deactivate## 移除当前目录的虚拟环境$ pipenv --rm 执行 pipenv shell 就可以进入这个虚拟环境，在头部会有虚拟环境的标识名称。有这个标识，说明已经进入虚拟环境。 1234## 在当前虚拟环境中运行$ pipenv run python # 进入交互式,跟直接执行 python 一样$ pipenv run python 文件名 # 运行文件$ pipenv run pip ... # 运行pip 5. 虚拟环境包管理1234567891011121314151617181920212223## 安装一个本地包（setup.py）到虚拟环境（Pipfile）$ pipenv install -e .## 安装、卸载模块$ pipenv install requests$ pipenv uninstall requests$ pipenv uninstall --all # 卸载全部包$ pipenv install -r path/to/requirements.txt ## 安装所有依赖$ pipenv install --dev## 更新包$ pipenv update # 更新所有包$ pipenv update --outdated # 打印所有要更新的包$ pipenv update &lt;包名&gt; # 更新指定的包## 将Pipfile和Pipfile.lock文件里面的包导出为requirements.txt文件$ pipenv run pip freeze # 相当于pipenv run pip freeze &gt;requirements.txt$ pipenv lock -r &gt; requirements.txt $ pipenv lock -r --dev # 若只想导出开发用的包 6. 其他命令12345678## 创建一个包含预发布的锁文件:$ pipenv lock --pre## 打印所有包的依赖关系图$ pipenv graph## 检查安全漏洞$ pipenv check 打印该虚拟环境下所有包的依赖关系图 有的python第三方包旧版本会有安全漏洞，使用 pipenv check 可以检查安全漏洞。 12.4 【虚拟环境】方案三：使用 pipx1. 什么是 pipxpipx 是一款用于帮助你安装和运行那些用 python 编写的终端程序，它类似于 macOS 上的 brew，Ubuntu 上的 apt，CentOS 上的 yum。 pipx 依赖 pip 和 venv，它只能在 python 3.6+ 的 Python 版本中才能使用。 默认情况下，pipx 和 pip 一样会从 pypi 上安装包，同时 pipx 也能像 pip 一样从本地、git仓库、wheel 文件中安装包。 为了避免你在安装 python app时，由于多版本而导致冲突，通常我们会使用 venv 或者 virtualenv 新建一个虚拟环境，然后将 app 安装到虚拟环境中。 后续你对这个 app 的管理操作，都得先进入这个虚拟环境。 发现没有？好像有点麻烦。 pipx 的存在使这个流程变得更加舒畅，使用 pipx 你可以无需关注虚拟环境的存在，并在你的机器上安装多个版本的 python app。 2. 安装使用安装 pipx 123$ python3 -m pip install --user pipx$ python3 -m userpath append ~/.local/binSuccess! 使用 Pipx 需要注意两个路径 二进制文件的保存位置：默认是 ~/.local/bin，可使用环境变量 PIPX_BIN_DIR 进行更改，或者执行如下命令(python3 -m userpath append $&#123;you_path&#125;) 虚拟环境的保存位置：默认是 ~/.local/pipx，可使用环境变量 PIPX_HOME 进行更改 在我安装好 pipx ，准备使用的时候，发现全局找不到 pipx 这个命令。 按照如上图所示，难道使用全路径执行命令？ 不，怎么都觉得不太对劲。。 想要解决这个问题，其实很简单，有两种方法（两种都可以，我演示使用的第一种方法）： 添加个软链接指向刚刚那个全路径就好啦 将这个路径添加到 PATH 中 /Users/MING/Library/Python/3.9/bin/ 1$ ln -s /Users/MING//Library/Python/3.9/bin/pipx /usr/local/bin/pipx 软链接建好后，就可以直接使用 pipx 的命令啦。 刚刚我使用 pipx 安装了 youtube-dl 后，其实并没有将这个 youtube-dl 安装到系统全局的 Python 环境中。 还记得最开始，我强调过两个非常重要的路径吗？ 现在来看一下，这个路径下面都有哪些东西？ 从截图上可以看出 pipx 在 ~/.local/pipx/venvs 目录下新建了个名叫 youtube-dl 的虚拟机环境 并将 youtube-dl 安装到这个虚拟机环境中 然后在 ~/.local/bin 的目录下新建一个软链接，指向这个虚拟环境中 这样 youtube-dl 就变成全局的工具啦。 为了避免你新安装的 youtube-dl 与全局的冲突，你也可以指定 pipx 的命令来运行 youtube-dl 1$ pipx run youtube-dl --no-check-certificate https://www.bilibili.com/video/BV1jK4y1h7uA 运行效果如下： pip run 也可以直接执行在线的 python 脚本 12$ pipx run https://gist.githubusercontent.com/cs01/fa721a17a326e551ede048c5088f9e0f/raw/6bdfbb6e9c1132b1c38fdd2f195d4a24c540c324/pipx-demo.pypipx is working! 3. 查看包查看已安装过的包 1$ pipx list 4. 安装包下载最新版本的 python 包，并安装到新建的虚拟环境中 1$ pipx install &lt;PACKAGE&gt; 4. 运行APPpipx run 后面可接一个包的 url 链接，会将这个包下载下来并运行，也可以接已安装过的应用名来直接运行它 1$ pipx run &lt;PACKAGE_URL/APP&gt; 如果一个 app 有多个版本，那么可以通过 spec 指定版本号 1$ pipx run --spec PACKAGE==1.0.0 app 更神奇的是，pipx 支持指定 git 代码仓库直接运行 12345678910$ pipx run --spec git+https://github.com/psf/black.git black## 指定分支$ pipx run --spec git+https://github.com/psf/black.git@branch black ## 指定某个git hash$ pipx run --spec git+https://github.com/psf/black.git@ce14fa8b497bae2b50ec48b3bd7022573a59cdb1 black ## 指定某个发行版本$ pipx run --spec https://github.com/psf/black/archive/18.9b0.zip black # install a release 5. 升级包升级某个包 1$ pipx upgrade &lt;pkg&gt; 升级全部包 1$ pipx upgrade-all 6. 卸载包卸载某个包 1$ pipx uninstall &lt;pkg&gt; 卸载全部包 1$ pipx uninstall-all 重装全部包 1$ pipx reinstall-all 7. 使用 pip每执行一次 pipx install 就会新建一个虚拟环境，那我们有没有办法管理这些虚拟机环境呢？ 比如我想看这个虚拟环境里安装了哪些包？ 使用如下命令就可以像使用 pip 一样，来管理 pipx 的虚拟环境 1$ pipx runpip &lt;env_name&gt; &lt;args&gt; 效果如下 8. 其他执行 pipx completions 可以启用 pipx 的补全说明。 对于不同的终端开启方式不一样，我使用的是 zsh，方法是 123$ autoload -U bashcompinit$ bashcompinit$ eval &quot;$(register-python-argcomplete pipx)&quot; 我安装好后，可以使用 tab 键进行命令补全。 执行 pipx ensurepath 可以确保 ~/.local/bin 这个重要的目录，已经放入到 $PATH 的变量中。 9. pipx vs pippipx 只是解决 pip 的一个痛点，因此他的适用场景比较单一，它只适用于安装和运行那些有提供命令行入口的app。 pip 适用于大多数的 Python 版本，而 pipx 需要 Python 3.6+ 才可以使用 pipx 依赖 pip 和 venv，可以使用 pip 安装pipx ，反过来则不行。 pip 和 pipx 默认都是从 pypi 上安装包 pipx 在安装和管理 cli 应用程序时，比 pip 更灵活，它可以在允许在隔离环境中安装和运行 Python 应用 10. 参考文章 https://github.com/pipxproject/pipx https://pipxproject.github.io/pipx/comparisons/ 12.5 【虚拟环境】方案四：使用 poetry1. 安装 poetrypoetry提供多种安装方式，个人推荐从以下2种方式中选择： 方式一：（推荐）使用在线脚本进行安装，是最为推荐的安装方式 1$ curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python 方式二：（pip） 官方不建议这么做，因为有可能会造成依赖冲突，可以考虑用 pipx 或 pipsi 1$ pip install --user poetry 安装后，可以使用如下命令检测是否可用 12$ poetry --versionPoetry version 1.1.4 2. 创建项目如果你是在一个已有的项目里使用 Poetry，你只需要执行 poetry init 命令来创建一个 pyproject.toml 文件： 1$ poetry init 而如果是新建 一个项目，可以使用这个命令 1$ poetry new demo-priject 运行完后，在当前目录下就会多一个 demo-project 的目录，这个目录下的文件结构如下 123456789$ tree demo-prijectdemo-priject├── README.rst├── demo_priject│ └── __init__.py├── pyproject.toml└── tests ├── __init__.py └── test_demo_priject.py 如果要把项目代码放入到 src 目录下，在创建项目时，可以加上 --src 参数。 3. 创建虚拟环境使用 poetry install 命令创建虚拟环境（确保当前目录有 pyproject.toml 文件）： 1$ poetry install 这个命令会读取 pyproject.toml 中的所有依赖（包括开发依赖）并安装，如果不想安装开发依赖，可以附加 —no-dev 选项。如果项目根目录有 poetry.lock 文件，会安装这个文件中列出的锁定版本的依赖。如果执行 add/remove 命令的时候没有检测到虚拟环境，也会为当前目录自动创建虚拟环境。 4. 使用虚拟环境创建虚拟环境后，如果想要在虚拟环境下执行命令，比如去执行脚本，去使用 pip list 等等。 可以在项目目录下，使用如下命令 1$ poetry run &lt;commands&gt; 比如我查看该虚拟环境中安装了哪些包 1$ poetry run pip list 再比如我想在该虚拟环境下执行 app.py 1$ poetry run python app.py 每次在虚拟环境下做点啥事，命令前面都要加上 poetry run，有点太麻烦了。 这时可以使用下面这条命令，直接激活当前的虚拟环境 1$ poetry shell 5. 包的管理安装包 1$ poetry add &lt;pkg&gt; 添加 —dev 参数可以指定为开发依赖 1$ poetry add pytest --dev 查看所有安装的依赖包 1$ poetry show 加上 --tree 可以查看他们的依赖关系 1$ poetry show --tree 加上 --outdated 可以查看可以更新的依赖 1$ poetry show --outdated 如果要更新依赖可以执行这个命令 12345## 更新全部$ poetry update## 更新某个依赖$ poetry update foo 想卸载某个包，用这个命令 1$ poetry remove foo 6. 常用配置Poetry 的配置存储在单独的文件中，比 Pipenv 设置环境变量的方式要方便一点。配置通过 poetry config 命令设置，比如下面的命令可以写入 PyPI 的账号密码信息： 1$ poetry config http-basic.pypi username password 下面的命令设置在项目内创建虚拟环境文件夹： 1$ poetry config settings.virtualenvs.in-project true 另一个常用的配置是设置 PyPI 镜像源，以使用豆瓣提供的 PyPI 镜像源为例，你需要在 pyproject.toml 文件里加入这部分内容： 123[[tool.poetry.source]]name = &quot;douban&quot;url = &quot;https://pypi.doubanio.com/simple/&quot; 不过经过测试 Poetry 会使用 pip.ini 设置的 PyPI 镜像，而且豆瓣的源好像很久没更新了（创建虚拟环境安装的默认依赖里 importlib-metadata==0.20 找不到），这篇文章列出了一些其他国内的 PyPI 源。 7. 参考文章 相比 Pipenv，Poetry 是一个更好的选择 12.6 【虚拟环境】方案五：使用 venv在前面介绍的几种方法中，都需要借助第三方模块来完成虚拟环境的管理。 但其实在 Python 3 中就自带了一个专门用门管理虚拟环境的模块，它叫 venv。 1. 创建虚拟环境venv 后可以接一个目录（如果此目录不存在，会自动创建）用于创建你的虚拟环境，他可以是绝对路径，也可以是相对路径。 123456## mac or linux$ python3 -m venv [venv_dir]## windows: 一定要指定 --without-pip ## 最后再手动执行命令安装 python -m ensurepip$ python3 -m venv --without-pip [venv_dir] 使用 venv 创建虚拟环境的速度非常快，大概只需要两三秒的样子。 创建完成后，在你所指定的目录下会有一个 pyvenv.cfg 的配置文件，它记录着虚拟环境的基本信息，包括你使用的 Python 的家目录，还有当前虚拟环境的 Python 版本，是否开启使用系统的 site-packages 模块，如果开启了，那么当你就可以直接使用系统中已经装过的第三方模块，但是你在虚拟环境下装的模块就不能被其他地方的程序使用。 123home = /usr/local/bininclude-system-site-packages = falseversion = 3.9.1 如果你的环境中有 Python 3.8 也有 Python 3.9 ，那该怎么办呢？ 只要你在创建时，用你预期版本的 Python 去执行就好啦 12$ python3.8 -m venv [venv_dir]$ python3.9 -m venv [venv_dir] 可如果你的环境中有两个 Python 3.9 呢？你想使用不在 PATH 的中的 Python 去创建，就要用绝对路径去创建了。 1$ /usr/local/bin/python3 -m venv [venv_dir] 2. 进入创建环境进入虚拟环境的方法，对比之前介绍的方案，venv 的方法就相当原始了。 如果你使用 Windows ，那么在 cmd 下进行 Scripts 目录，执行 activate.bat 12345## cmd.exe$ .\\Scripts\\activate.bat## PowserShell$ .\\Scripts\\Activate.ps1 如果你使用PowserShell激活虚拟环境出现如下错误，那要先执行这个命令：Set-ExecutionPolicy RemoteSigned，再按 Y 而如果你使用的 Mac 或者 Linux，那么直接执行下面命令就行 1$ source bin/activate 执行完后，若在你的命令行下有 demo 字样（之所以是 demo ，因为我们创建时的目录名就是 demo），说明你已经处于虚拟环境下。 由于虚拟环境是全新的干净环境，此时你使用 pip list ，会看到啥包都没有，只有最基本的 pip 和 setuptools 。 3. 退出虚拟环境退出虚拟环境，无论是 Windows 、 Mac 、 还是 Linux ，方法都是同一条命令。退出后，你的虚拟环境名称（如上面的 demo ）也会消失。 1$ deactivate 4. 总结一下venv 是 Python3 中自带的虚拟环境管理工具，不需要额外安装，功能简单，用法也简单。但是它不能像 poetry 和 pipenv 用于项目的管理，因此 venv 建议只做了解，在一些简单的场景中可以使用，如果是复杂的项目中，可以直接上 poetry 和 pipenv。","categories":[{"name":"python","slug":"python","permalink":"https://hwame.top/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://hwame.top/tags/python/"}]},{"title":"Windows命令行中正确显示颜色","slug":"ansi-color-in-windows-cmd","date":"2021-06-18T12:03:20.000Z","updated":"2021-06-27T10:33:59.000Z","comments":true,"path":"20210618/ansi-color-in-windows-cmd.html","link":"","permalink":"https://hwame.top/20210618/ansi-color-in-windows-cmd.html","excerpt":"摘要：win10的cmd对颜色的显示不太友好，在捯饬的过程中差点把电脑搞崩。","text":"摘要：win10的cmd对颜色的显示不太友好，在捯饬的过程中差点把电脑搞崩。 文章说明文章作者：鴻塵参考资料： 解决CMD命令行窗口不显示颜色问题python cmd命令提示符文本颜色输出 Github ANSICON CMD窗口无法显示带颜色文字输出 特殊命令之REG命令 转义序列Escape Sequences及Linux echo命令多种颜色显示 Linux终端和win32控制台文本颜色输出 控制台输出颜色控制（Console 模式下的颜色显示） 命令行里输出带颜色的字体 Windows cmd(DOS)命令窗口中echo命令ANSI转义显示彩色字或背景 文章链接：Windows命令行中正确显示颜色 1.背景 为了搞好这个问题，差点把电脑给搞崩了，在这里特意记录下来，算是留给自己的一个教训。 临近毕业，这两天什么事情都没有，就等着参加毕业典礼然后跑路。就想着写点东西吧，hexo部署的时候无法正常显示颜色。如图（注意最后一行）： 其实呢，这个问题早就出现了，见Hexo博客搭建(1)——建站及部署之部署Hexo，只不过一直没管它，现在闲下来了就想拯救一下处女座强迫症。 不仅如此，cmd中只能识别^[[35m 文字 ^[[0m而不能识别\\33[35m 文字 \\33[0m，也就是说无法正确转义\\033。 需要注意的是，^[是一个字符，且只能在命令行下通过组合键Ctrl + [输入（还有其他方式输入，见后文）。 鉴于以上问题，在经过较长时间的折腾后，找到了一个可用的方法：ANSICON。 2.解决方案2.1.colorama在Python中显示颜色主要参考「解决CMD命令行窗口不显示颜色问题python」，用到的库为colorama，代码如下：1234from colorama import init init(autoreset=True) print(&quot;\\033[35m 紫色 \\033[0m&quot;) #紫色 上述方法通过颜色代码实现颜色的显示，也可以使用Fore设置颜色：123456from colorama import init, Foreinit(autoreset=True)print(Fore.YELLOW + &quot;黄色&quot;)print(&quot;普通文字&quot;) print(Fore.MAGENTA + &quot;洋红色&quot;)colorama方法只适用于python程序在终端上打印彩色文字，并不能解决其他程序的输出。 2.2.ANSICON鉴于上述问题，在查找了海量资料后，参考「cmd命令提示符文本颜色输出」，最终找到了ANSICON。ANSICON基本上可以完美解决遇到的关于cmd颜色的所有问题，这是它的自我介绍： ANSICON provides ANSI escape sequences for Windows console programs. It provides much the same functionality as ANSI.SYS does for MS-DOS. 在64位Windows上，ANSICON包含了主程序ansicon.exe和扩展ANSI64.dll，在cmd中运行该程序即可开启一个子shell，在子shell中即可正常显示颜色，不会出现图一的问题。 ANSICON帮助信息如下：1234567891011121314151617181920212223242526ANSICON by Jason Hood &lt;jadoxa@yahoo.com.au&gt;.Version 1.89 (29 April, 2019). Freeware.http://ansicon.adoxa.vze.com/Process ANSI escape sequences in Windows console programs.ansicon [-lLEVEL] [-i] [-I] [-u] [-U] [-m[ATTR]] [-p[u]] [-e|E STRING | -t|T [FILE...] | PROGRAM [ARGS]] -l set the logging level (1=process, 2=module, 3=function, +4=output, +8=append, +16=imports, +32=files) for PROGRAM -i install - add ANSICON to CMD&#x27;s AutoRun entry (also implies -p) -u uninstall - remove ANSICON from the AutoRun entry -I -U use local machine instead of current user -m use grey on black (&quot;monochrome&quot;) or ATTR as default color -p hook into the parent process -pu unhook from the parent process -e echo STRING -E echo STRING, don&#x27;t append newline -t display files (&quot;-&quot; for stdin), combined as a single stream -T display files, name first, blank line before and after PROGRAM run the specified program nothing run a new command processor, or display stdin if redirectedATTR is one or two hexadecimal digits; please use &quot;COLOR /?&quot; for details.It may start with &#x27;-&#x27; to reverse foreground and background (but not for -p). 由上可知，直接运行该程序将不带任何参数，开启一个新的命令行进程，这也是后来悲催的直接原因。现在看来，貌似只需要加上-i选项将其添加到cmd的AutoRun即可。 3.采坑之路3.1.问题产生到目前为止，好像一切正常，文章开始说的「差点把电脑搞崩」又是怎么回事呢？ 因为担心会出现其他问题，所以并没有安装ANSICON，开启子shell好像也没有什么问题，无非就是每次都要手动输入命令/path/to/ansicon.exe。这也不是什么问题，只要把ansicon.exe文件路径加入到环境变量中即可。为了省事我直接把ansicon.exe和ANSI64.dll复制到C:/Windows/System32/目录下，这样一来在任何命令行下都可以直接运行ansicon命令了。 当需要正常显示颜色时，输入ansicon即可，如图所示：上图中，直接打印颜色将显示乱码，在ansicon的子shell中则可以正常显示，输入exit才可退出shell。此时再打印颜色仍会乱码，因为只有在ansicon的shell中才可以正常显示。 在查资料的时候，偶然看到了一篇文章：CMD窗口无法显示带颜色文字输出。文章中提到，利用注册表的AutoRun字符串值可以实现在打开CMD窗口时自动执行命令。于是，我就设想修改注册表，在每次打开CMD的时候让他自动执行ansicon命令，那么就不需要手动输入了。 说干就干，Win + R打开运行，输入regedit打开注册表编辑器，定位到计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Command Processor下，新建字符串值AutoRun，双击该值，在数值数据中填写ansicon，一气呵成。 此时我已经迫不及待地要测试了，然而，当我打开cmd的时候，窗口中却疯狂打印Microsoft Windows [版本 10.0.18363.1556](c) 2019 Microsoft Corporation。保留所有权利。，此时我已经感觉不妙。好在它只开了一个窗口（注意，这是一个伏笔……），我不得不一直按Ctrl + C让它停下来，甚至直接叉掉这个窗口。 我又查了半天，一直都以为是注册表修改方式不对，又不知道在哪里看到了cmd /k xxx这样的一个命令，就是这个命令让我的电脑直接崩溃。该命令会打开一个新窗口来执行xxx命令。于是抱着试一试的心态我把上面注册表的数值数据改成了cmd /k ansicon，当我打开CMD窗口的一瞬间，电脑内存急剧增加，无限开启新窗口并执行ansicon命令。 自此走上了修电脑的艰难之路。 3.2.艰难解决由于电脑内存卡爆，无法进行任何操作，就算想删除注册表值也没办法，因为鼠标键盘根本动不了。无奈之下，准备重启电脑，跟它抢速度，在内存爆满之前把注册表改回来。事实证明我还是太天真了，电脑一开机他就开始了，根本不给时间你去做其他操作，如图： 到这里已经没有任何办法了，系统还原也不行，因为我很早就删除了系统还原点（只为节省那么一丢丢内存…），现在只能重装系统了，甚至连U盘启动盘都做好了。重装系统倒是无所谓，但是电脑里有很多重要的文件、配置、安装的软件等。我真的不想重装系统，但是没办法啊！ 上图是准备重装系统之前拍的照，为的是留一个桌面布局，可以看到右侧命令行窗口边缘厚厚的一层黑边，都不知道开了多少个窗口了。 从U盘重装系统还要设置一下BIOS，开启UEFI什么的。然而哪有那么顺利，就在我失败了无数次一心想要操作系统的时候，他却提示各种错误，要么是某个地方设置不对、要么是某个选项没有开启。在反复的重启和设置中，突然发现了一个修复的选项。在这种连系统都不让我重装的情况下，无疑给了我一丝希望。 然而，新的问题又出现了，所有的修复选项都试过了还是没用，这让我整个人都不好了，一度濒临崩溃。 世事总是这样，在你最绝望的时候才会显现一丝曙光。 在某一个修复选项中，可以打开命令行窗口，目测盘符X应该是U盘吧，Source目录就是启动盘的位置。如图所示： 但是一个命令行能干什么呢？这里的命令行是有管理员权限的，最直接的想法就是在这里删除注册表值，然后重启就完美了。搜了一下，发现还真有操作注册表的命令REG，还有对应的QUREY、ADD、DELETE等选项，此处参考了特殊命令之REG命令。这令我大喜过望，感觉胜利就在眼前。然而，当我查询HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Command Processor下的值时，却没有AutoRun这一项（如上图），只有如下几项：1234CompletionChar REG_DWORD 0x9DefaultColor REG_DWORD 0x0EnableExtensions REG_DWORD 0x1PathCompletionChar REG_DWORD 0x9通过对比3.1节《问题产生》的图二和上图，唯独少了AutoRun这一项。这另外百思不得其解的同时，也是十分郁闷。我测试过REG ADD和REG DELETE，好像都成功了，为何这里就查询不到呢？看来这个方法又行不通了。 就在我一筹莫展的时候，突然灵机一动，产生问题的根本原因在于无限启动新窗口从而运行ansicon命令，那我可以人为破坏掉他的运行环境啊。于是我在命令行里试着删除文件C:\\Windows\\System32\\ANSI64.dll，结果成功了。 赶紧重启电脑，尽管仍然会无限开启新窗口，但果然没那么卡了，因为ansicon命令无法正常运行。于是可以打开注册表编辑器，删除掉罪魁祸首AutoRun，再重启电脑就恢复正常了。 至此，历经千辛万苦，电脑总算是修好了，可算是不需要重装系统了。 4.附录4.1.ANSI颜色序列格式 本段来自转义序列Escape Sequences及Linux echo命令多种颜色显示。在计算机界，ANSI转义编码（escape code）或者转义序列（escape sequences）是带内信号（元数据和控制信号，译者注）控制视频文字终端的格式、颜色、其他输出选项的一种方法。为了编码这些格式信息，它把某种字节序列嵌入到文本中，该序列必须特别的解释，且不应该作为字符的本义。尽管硬件字符终端在21世纪已经变得很愈来愈少见，这种标准依然具有实用价值，是因为大多数终端仿真器至少还能解释在输出文本中的一些ANSI转义序列。但微软的win32控制台组件就是一个明显的例外。 上文中的「\\033[35m」和「\\033[0m」就是ANSI转义序列（ANSI escape code/sequence），转义序列使用ESC控制字符开始，ESC键位于键盘左上角，其对应的ASCII码为\\033（八进制）、\\27（十进制）和\\0x1b（十六进制）。 通用的控制文本颜色的转义序列格式为CSI n1[;n2[;...]] m，其中CSI全称为「控制序列引导器（Control Sequence Introducer/Initiator）」，即上述\\033、\\x1b和\\e等；n1、n2等表示SGR参数，多个SGR参数可以组合使用，见下表。 通常，我们只需要用到表中部分属性，更详细的属性值可参考命令行里输出带颜色的字体。 一般格式：CSI[显示方式;前景色;背景色m 文字 CSI[0m。 注：经测试，在Linux下\\033、\\x1b和\\e可用，\\33、\\0x1b和\\27不可用。注：在Windows下只有\\033、\\33、\\x1b、^[可用（不一定准确），\\e不可用。 编码 说明 备注 0 关闭所有格式，还原为初始状态 终端默认设置 1 粗体/高亮显示 无 2 模糊/弱化 不是所有的终端仿真器都支持，只有少数仿真器支持 3 斜体 不是所有的终端仿真器都支持，只有少数仿真器支持 4 下划线（单线） 无 5 闪烁（慢） 无 6 闪烁（快） 不是所有的终端仿真器都支持，只有少数仿真器支持 7 交换背景色与前景色（反显） 无 8 隐藏（伸手不见五指，啥也看不见） 不是所有的终端仿真器都支持，只有少数仿真器支持 22 设置一般密度 无 24 关闭下划线 无 25 关闭闪烁 无 27 关闭反向图像，即关闭7 无 30-37 前景色，即30+x，x表示不同的颜色（参见下面的「颜色表」） 无 38 在缺省的前景颜色上设置下划线 无 39 在缺省的前景颜色上关闭下划线 无 40-47 背景色，即40+x，x表示不同的颜色（参见下面的「颜色表」） 无 49 设置缺省黑色背景 无 颜色值x 前景色编码 背景色编码 颜色 效果 0 30 40 黑色 黑色 1 31 41 红色 红色 2 32 42 绿色 绿色 3 33 43 黄色 黄色 4 34 44 蓝色 蓝色 5 35 45 紫色 紫色 6 36 46 青色 青色 7 37 47 白色 白色 4.2.设置颜色一般格式：CSI [ 显示方式; 前景色; 背景色 m 文字部分 CSI [ 0 m。 CSI 显示方式 前景色 背景色 \\033 \\x1b \\eESC（^[） 0-9等 30-37 40-47 需要说明的是，在同一处的CSI最好保持一致，「显示方式」、「前景色」和「背景色」的顺序不重要。 关于Windows下CMD中ESC（^[）的输入方式，参考《Windows cmd(DOS)命令窗口中echo命令ANSI转义显示彩色字或背景》： Windows下CMD中^[是ANSI的ESC一个字符（注意^和[是一个字符，就好比我们Ctrl + C时显示的^C一样），并不是我们看到的键盘上左上角那个ESC按键。其ASCII码值的十进制是27， 八进制是33（一般写为\\033)，十六进制是1b（一般写为\\x1b）。其输入方法有以下几种： 方法一（只能在CMD窗口中输入）：在CMD窗口中按Ctrl + [组合键即可，这种方法最简单。 方法二（只能在CMD窗口中输入）：在CMD窗口中按Alt + 2 + 7组合键即可，注意必须是小键盘上的数字键2和7，先按住Alt不放再按2和7最后放开Alt。如果没有数字小键盘，则不能用这种方式。 方法三（编辑器中先输入再替换）：略。垃圾软件不配。","categories":[{"name":"miscellanea","slug":"miscellanea","permalink":"https://hwame.top/categories/miscellanea/"}],"tags":[{"name":"miscellanea","slug":"miscellanea","permalink":"https://hwame.top/tags/miscellanea/"}]},{"title":"如何将嵌套列表展开为一维","slug":"flatten-a-nested-list","date":"2021-06-10T11:56:05.000Z","updated":"2021-06-20T10:43:21.000Z","comments":true,"path":"20210610/flatten-a-nested-list.html","link":"","permalink":"https://hwame.top/20210610/flatten-a-nested-list.html","excerpt":"","text":"文章说明文章作者：鴻塵参考资料： How to make a flat list out of a list of lists? Right Foot In: More on python flatten（有缘人才能打开） Flatten an irregular list of lists How Not to Flatten a List of Lists in Python 文章链接：https://hwame.top/20210610/flatten-a-nested-list.html 1.引言闲来无事逛Stack Overflow，发现了一个挺有意思的问题：How to make a flat list out of a list of lists?。 123# 怎样快速优雅地将src转换成dst？src = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]dst = [1, 2, 3, 4, 5, 6, 7, 8, 9] 乍一看，对于所给的二维数组，for循环是最容易想到的思路，但是有没有some cool “one-liner”的办法呢？顺着这个问题往下看，还挺有意思。 说明：此处仅讨论各方法的正确性，至于性能和效率可自行测试。 2.解决方案2.1.方法一：functools.reduce该问题的提出者Emma提供了一个思路，利用标准库函数reduce：1234from functools import reducesrc = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]#reduce(lambda x, y: x.extend(y), src)reduce(lambda x, y: x + y, src)这个方法是可行的，但为何不能用x.extend(y)呢？原因是列表的extend方法不返回值（返回None），故在下一轮次的reduce过程中会导致None.extend，从而raise AttributeError: &#39;NoneType&#39; object has no attribute &#39;extend&#39;。而列表加法则会返回「extended」列表。 如果非要用extend呢？既然返回None，我们是否可以人为给返回赋值？LBarret给出了一个方案：reduce(lambda x, y : x.extend(y) or x, src, [])，或者省略initial参数：reduce(lambda x, y : x.extend(y) or x, src)。其中x.extend(y) or x实现了x + y并返回x，因为bool(x.extend(y)) = False。 Greg Hewgill提到，extend()方法会修改列表x，而不是返回一个functools.reduce()所期望的「有用的」值，因此x + y优于x.extend(y)。 需要指出的是，这种reduce方法只能解决二维数组，多层嵌套或非列表元素将抛错，例如：12345678src1 = [[1], [], [2, 3, 4], 5] # 含有非列表元素5src2 = [[1], [], [2, 3], [[4], [5, 6]]] # 多层嵌套reduce(lambda x, y: x + y, src1)# TypeError: can only concatenate list (not &quot;int&quot;) to listreduce(lambda x, y: x + y, src2)# [1, 2, 3, [4], [5, 6]]# 只能展开一层，若再reduce一次则含非列表元素 2.2.方法二：列表生成式列表生成式也是很容易想到的办法，因为它本质上就是for循环：123456789101112# 列表生成式dst = [item for sublist in src for item in sublist]# for循环等价写法dst = []for sublist in src: for item in sublist: dst.append(item)# lambda表达式flatten = lambda t: [item for sublist in t for item in sublist]dst = flatten(src)两层for循环写成列表生成式不太直观，借用John Mee的例子会更容易理解和应用：[leaf for tree in forest for leaf in tree]。表达式中「叶 → 树 → 林」的关系很清晰地表现了内外循环的层级。 当然也有不同的观点，例如Eric Duminil和Davos。尽管John Mee的写法与for循环相同，但顺序杂乱不易理解（直观仅限于leaf、tree和forest），Davos更推荐使用leaf for leaf in tree for tree in forest这种「递进式写法」。 2.3.方法三：itertools.chainitertools.chain先将二维数组解包为一维然后连接为迭代器，再转化为列表；itertools.chain.from_iterable则无需先解包：12345import itertoolssrc = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]dst = list(itertools.chain(*src))dst = list(itertools.chain.from_iterable(src))借用该回答下Tim Dierks的评论，*将列表解包为多个参数传递给chain，导致将顶级列表（最外层）扩展为参数，再将这些可迭代对象连接在一起而不会进入更深层级。在这种情况下，列表生成式将比链式用法的可读性更好。 2.4.方法四：sum这种方法既不直观也不高效，但是很有趣，计算机科学中的monoids定义如下： Monoids in computer science【来自维基百科】 在计算机科学中，许多抽象数据类型（Abstract Data Types，ADT）都具有monoid结构。在一个常见的模式中，monoid的一系列元素被「折叠)」或「累积」以产生最终值。例如，许多迭代算法需要在每次迭代时更新某种「运行总数」；这种模式可以通过monoid运算优雅地表达。或者，monoid运算的关联性确保可以通过使用前缀和或类似算法来并行化运算，以便有效地利用多个内核或处理器。给定一系列「$M$类型」且具有「标识元素$\\varepsilon$」和「关联操作$\\bullet$」的值，折叠操作定义如下： \\displaystyle \\mathrm {fold:} M^{*}\\rightarrow M=\\ell \\mapsto {\\begin{cases}\\varepsilon &{\\mbox{if }}\\ell =\\mathrm {nil} \\\\m\\bullet \\mathrm {fold}\\,\\ell '&{\\mbox{if }}\\ell =\\mathrm {cons} \\,m\\,\\ell '\\end{cases}}此外，如果给定其元素的序列化，任何数据结构都可以以类似的方式「折叠」。例如，「折叠」二叉树的结果可能会因遍历方式（前序遍历pre-order与后序遍历post-order）的不同而不同。 代码如下：12src = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]dst = sum(src, [])这只是对第一个参数中传递的iterable元素进行求和，而将第二个元素视为总和的初始值。sum函数的声明为sum(iterable, start=0, /)，在上例中如果不传仅限位置参数start，将取默认值0，在这种情况下将抛出TypeError：不能将整数和列表相加。 毫无疑问，这种方法是所有答案中最「简洁」、最「聪明」的，答案评论区争论的焦点之一就是低效，原因是列表连接时产生了大量不必要的复制，时间复杂度高达$O(n^2)$。当然，这并非本文重点，有兴趣可移步Mathieu Larose的文章：How Not to Flatten a List of Lists in Python。 同时，该方法仅用于二维嵌套列表，对于更深层级的嵌套，则需寻求其他方法。 2.5.方法五：现有的轮子有这么句话，Do not reinvent the wheel!，即不要重复造轮子。Max Malysh可谓是贯彻了这一理念，很多第三方库甚至是python自带的库或函数，都提供了相应的方法：123456789101112131415161718192021222324src = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]# Djangofrom django.contrib.admin.utils import flattendst = flatten(src)# Pandasfrom pandas.core.common import flattendst = list(flatten(src))# Numpyfrom numpy import concatenatedst = list(concatenate(src))# Matplotlibfrom matplotlib.cbook import flattendst = list(flatten(src))# Unipathfrom unipath.path import flattendst = list(flatten(src))# Setuptoolsfrom setuptools.namespaces import flattendst = list(flatten(src))pandas提供的flatten函数不仅能解决多层嵌套，还能连接整数和列表，这或许是终极答案了。 关于造轮子的说法，使用别人造好了的轮子固然可以提高效率，但是自己造轮子难道不是一种更好的学习方式吗？正如Nathan Chappell所言： All these great libraries reinvented the wheel, why shouldn’t I? 2.6.方法六：operatoroperator模块中提供了很多方法，例如concat、add等，需要配合functools.reduce一起使用：123456from functools import reduceimport operatorsrc = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]reduce(operator.concat, src)reduce(operator.add, src) 2.6.方法七：mapDaniel Braun给出的map方法，个人认为不是很好（可能这也是vote数比较少的原因吧）：123456def flatten(src): dst = [] tmp = list(map(dst.extend, src)) return dstflatten([[1, 2, 3], [4, 5, 6], [7], [8, 9]]) 3.其他问题上述各种方法都有一定的局限性，最大的问题就是对于数据类型的制约以及嵌套深度的限制，pylang给出了一种适用于数字、字符串、嵌套列表及其复合体的通用方法，该方法参考了Cristian的在Flatten an irregular list of lists的回答：12345678910111213from typing import Iterable def flatten(items): for x in items: if isinstance(x, Iterable) and not isinstance(x, (str, bytes)): yield from flatten(x) # *注：上句可展开为 # for sub_x in flatten(x): # yield sub_x else: yield xlist(flatten([[1, 2, 3], [4, 5, 6], [7], [8, 9]])) # 简单情况list(flatten([[1, [2]], (3, 4, &#123;5, 6&#125;, 7), 8, &quot;9&quot;])) # 复杂情况","categories":[{"name":"python","slug":"python","permalink":"https://hwame.top/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://hwame.top/tags/python/"}]},{"title":"命令行帮助文档语法格式详解","slug":"command-line-description","date":"2021-01-12T12:40:13.000Z","updated":"2021-04-15T06:43:04.000Z","comments":true,"path":"20210112/command-line-description.html","link":"","permalink":"https://hwame.top/20210112/command-line-description.html","excerpt":"摘要：了解命令行帮助文档的语法格式有助于正确使用其命令，但是命令选项参数难懂难记，因此做以记录。","text":"摘要：了解命令行帮助文档的语法格式有助于正确使用其命令，但是命令选项参数难懂难记，因此做以记录。 文章说明文章作者：鴻塵参考内容： DOCOPT: Command-line interface description language Linux命令行帮助文档命令语法公式格式详解和Git命令语法格式解读 文章链接：https://hwame.top/20210112/command-line-description.html 1.背景在终端下查看某个命令的用法时，通常会出现一大堆的选项 和参数，了解掌握其语法格式就无需某度某歌了，工作效率也会upup。 本文主要翻译自DOCOPT: Command-line interface description language，并参考Linux命令行帮助文档命令语法公式格式详解和Git命令语法格式解读。 2.文档翻译2.1.命令行界面描述语言（概述）docopt可用于为命令行应用定义接口，并且自动生成解析器。 docopt基于已使用数十年的惯例，用于描述程序接口的帮助信息（help messages）和手册页（man pages）。docopt中正式的接口描述如下例所示： 上图中的例子描述了可执行程序naval_fate（海军命运）的调用接口，可由命令（commands）、选项（options）和位置参数（positional arguments）三者的不同组合来使用： 命令（commands）：ship，new，move等。 选项（options）：-h，--help，--speed=&lt;kn&gt;等。 位置参数（positional arguments）：&lt;name&gt;，&lt;x&gt;，&lt;y&gt;等。 该示例使用方括号[]、圆括号()、管道符|和省略号...分别描述可选、必需、互斥和重复的元素。这些元素组成了有效的使用模式（usage patterns），每个使用模式都以程序的名称naval_fate开始。 使用模式下方为带有描述的选项列表，它们描述了一个选项是否有 短格式（例如-h）或长格式（例如-–help） 、是否有一个参数（例如–speed=&lt;kn&gt;），以及该参数是否有默认值（例如[default: 10]）。 一个「docopt实现」将提取所有上述信息并生成命令行参数解析器，当使用-h或-–help选项调用程序时，界面描述的文本将作为帮助消息显示。 2.2.使用模式（usage patterns）位于关键字usage:（不分大小写）和明显空行 之间的文本将被解释为使用模式列表，关键字usage:后的第一个单词将被解释为程序名称。下面是一个无需命令行参数程序的最小示例：1Usage: my_program程序可以有多个使用模式，以各种元素列出来描述该使用模式：123456Usage: my_program command --option &lt;argument&gt; my_program [&lt;optional-argument&gt;] my_program --another-option=&lt;with-argument&gt; my_program (--either-that-option | &lt;--or-this-argument&gt;) my_program &lt;repeating-argument&gt; &lt;repeating-argument&gt; ...每个元素和结构将在下文介绍，用word表示一个由「空格」、「字符串[]()|」之一或「...」分隔的序列。 ①参数&lt;argument&gt; ARGUMENT以&lt;开头且&gt;结尾的单词和大写单词将被解释为位置参数（positional arguments）：1Usage: my_program &lt;host&gt; &lt;port&gt; ②选项-o --option以单连字符-或双连字符--开头的单词 将被分别解释为短格式选项（一个字母的「单词」）和长格式选项，除了-和--本身之外【特殊含义详见下文选项参数分隔符和处理标准输入】。 短格式选项可以堆叠，这意味着-abc和-a -b -c是等价的； 长格式选项可以有位于空格或等号＝之后的指定的参数，即--input=ARG与--input ARG等价； 短格式选项可以有位于可选的空格之后的指定的参数，即-f FILE与-fFILE等价； 注1：--input ARG【而非--input=ARG】这种写法语义模棱两可，因为不知道ARG到底是选项参数还是位置参数。在使用模式中，只有提供了「选项描述」时才会被解释为带参数的选项，否则将会被解释为一个选项和独立的位置参数。注2：同样会引起歧义的是-f FILE和-fFILE，因为后者不知道是多个堆叠的短格式选项（-f -F -I -L -E）还是带参数的单个选项（-f为选项，FILE为对应参数）。只有提供了选项描述时，后者这种写法才会被解释为带参数的单个选项。 ③命令command所有不遵循上述①②约定（即参数&lt;argument&gt;和选项--option）的「单词」，都将被解释为命令或子命令。 ④可选元素[optional elements]包含在方括号[]中的元素（选项、参数、命令）被标为「可选」。元素是否包含在相同或不同的括号内并不重要，例如下面两种写法是等价的：123Usage: my_program [command --option &lt;argument&gt;]Usage: my_program [command] [--option] [&lt;argument&gt;] ⑤必选元素(required elements)如果不在方括号[]里，那么默认情况下所有元素都是必选的。但是有时候需要用圆括号()将必选元素显式地标出，例如需要对互斥元素（见下节互斥元素）分组的时候：1Usage: my_program (--either-this &lt;and-that&gt; | &lt;or-this&gt;)另一种用法是，当你需要制定如果有一个元素存在，那么就需要另一个元素，则可以这样实现：1Usage: my_program [(&lt;one-argument&gt; &lt;another-argument&gt;)]在这种情况下，有效的程序调用要么没有参数，要么就有两个参数。 ⑥互斥元素element | another互斥元素以管道符|进行分隔：1Usage: my_program go (--up | --down | --left | --right)在各个互斥情况下，当有一个为必选时使用圆括号()对元素进行分组，当没有必选时使用方括号[]对元素进行分组：1Usage: my_program go [--up | --down | --left | --right]注意：指定多个使用模式的运行恰如管道符|，这就是说以下两者写法是等价的：1234Usage: my_program run [--fast] my_program jump [--high]Usage: my_program (run [--fast] | jump [--high]) ⑦重复元素element...使用省略号...表示左边的一个或一组参数可被重复一次或多次：12Usage: my_program open &lt;file&gt;... my_program move (&lt;from&gt; &lt;to&gt;)...可以灵活地指定必需参数的数量，例如：123456789101112# 零个或多个必选参数（3种冗余的方法）：Usage: my_program [&lt;file&gt;...] my_program [&lt;file&gt;]... my_program [&lt;file&gt; [&lt;file&gt; ...]]# 一个或多个必选参数：Usage: my_program &lt;file&gt;...# 两个或多个必选参数：Usage: my_program &lt;file&gt; &lt;file&gt;...# 诸如此类... ⑧选项简写[options]「[options]」是一种选项的简写方式，该方式可以避免在使用模式中列出所有的选项（从带有描述的选项列表中）。例如以下两种写法是等价的：12345678910111213# 简写Usage: my_program [options] &lt;path&gt;--all List everything.--long Long output.--human-readable Display in human-readable format.# 非简写Usage: my_program [--all --long --human-readable] &lt;path&gt;--all List everything.--long Long output.--human-readable Display in human-readable format.如果有很多选项，并且它们都适用于其中一种使用模式，那么这种简写将很有用。或者，如果同时具有短格式和长格式两种版本的选项（详见选项描述部分），则可以在一个使用模式中列出其中之一：12345Usage: my_program [-alh] &lt;path&gt;-a, --all List everything.-l, --long Long output.-h, --human-readable Display in human-readable format.关于如何书写「选项描述」将在下文介绍。 ⑨选项参数分隔符[--]双连字符--在不属于选项的一部分时，按照惯例通常用于分隔选项和位置参数，以便处理诸如将文件名误认为是选项的情况。为了支持该约定，只需在使用模式的位置参数前加上[--]即可：1Usage: my_program [options] [--] &lt;file&gt;...除此之外，--只是一个普通的命令，因此可应用于任何前述操作，譬如去掉方括号[]使其成为必选。 ⑩处理标准输入[-]单连字符-在不属于选项的一部分时，按照惯例通常表示程序用于处理标准输入stdin而非文件。如果要遵循该约定，只需将[-]添加到使用模式中。-自身仅仅是一个普通命令，可赋予任何意义。 2.3.选项描述选项描述是位于使用模式下面的一系列选项。如果使用模式不存在歧义（详见上文选项option），则可以选择指定它们。 一个选项描述允许指定： 某些短格式和长格式选项为同义词； 一个选项有一个参数； 选项的参数提供默认值。 这些规则遵循：以不计空格的以-或--开头的每一行都将视为选项描述。例如：1234Options: --verbose # GOOD，以「--」开头 -o FILE # GOOD，以「-」开头Other: --bad # BAD，不以「-」开头 若要明确指定一个选项带有一个参数，则需： 在空格或等号=后放一个描述该参数的词，如下所示。 选项参数遵循尖括号&lt;argument&gt;或全大写ARGUMENT的约定。 如果有必要，可以使用逗号,分隔选项。 尽管下例中的两行都是有效的，但是建议坚持使用单一风格而不要混着用：【注：根据下文分析中的规范书写命令第4点，推荐使用全大写而非尖括号】 12-o FILE --output=FILE # 有等号、全大写、无逗号（推荐）-i &lt;file&gt;, --input &lt;file&gt; # 无等号、尖括号、有逗号（不推荐） 用（至少）两个空格来分隔选项和它们的非正式描述【如果只用一个空格，可能会将描述的首个词当做选项的参数】：12345--verbose MORE text. # BAD，将被视为选项verbose有一个参数MORE， # 故需使用两个空格-q Quit. # GOOD，8空格-o FILE Output file. # GOOD，3空格--stdout Use stdout. # GOOD，2空格如果要为带有参数的选项设置默认值，则使用[default: the-default-value]的形式将其放到选项描述中：123--coefficient=K The K coefficient [default: 2.95]--output=FILE Output file [default: test.txt]--directory=DIR Some directory [default: ./] 2.4.其他 在浏览器中体验docopt：Try docopt。 docopt可用于多种编程语言，其官方实现列在GitHub上的docopt组织中。 3.注意事项 为了和docopt文档原有结构保持一致，本文第二章文档翻译没有在对应位置添加注释，故此列出各个注意事项。 (1)关于「命令」在本文中使用模式格式为my_program command --option &lt;argument&gt;，各元素依次称为程序、命令、选项和参数；而一般Linux命令中将这里的程序也称为命令，在这种条件下my_program command --option &lt;argument&gt;中各元素依次称为命令、子命令、选项和参数，例如yum install package_name -y。注意：「子命令」不一定总有，例如du -h ./。 由于Linux中都是称cd、ls等为「命令」，因此个人倾向于「命令 子命令」的说法，而非「程序 命令」。 (2)关于「参数」docopt文档对某些名词和概念没有具体解释，容易让人误解，尤其是翻译的时候名词的形容词化。 parameter和argument的区别：The term parameter is used to describe the names for values that are expected to be supplied.The term argument is used for the values provided for each parameter. parameter指函数定义中的形式参数（Formal Parameter）。argument指函数调用时的实际参数（Actual Argument）。 在本文中只有实际参数（因为只需调用程序嘛），但参数又分为位置参数和选项参数： 位置参数是指包含于尖括号&lt;&gt;中的单词和大写单词； 选项参数是指紧跟在选项后的参数，用于指定选项的操作对象，如-o argument或--option=argument中的「argument」即选项参数。 (3)关于「选项」及歧义「选项」主要用于改变命令执行动作的类型。一般而言，短格式选项是长格式选项的缩写，也就是一个短格式选项会有对应的长格式选项。当然也有例外，比如ls命令的短格式选项-l就没有对应的长格式选项。 上文选项option一节注解中提到的歧义问题： 长格式选项--input ARG中的ARG是选项参数还是位置参数？ 短格式选项-f FILE中的FILE是选项参数还是位置参数？ 短格式选项-fFILE是由-f -F -I -L -E堆叠的多个选项还是带参数FILE的单个选项-f？ 为了避免引起上述歧义，最好规范书写命令，如下所示： 1.书写带参数的短格式选项命令时，最好写成带空格的形式-f FILE； 2.书写带参数的长格式选项命令时，最好写成带等号的形式--input=ARG； 3.事实上，带空格的形式-f FILE仍然存在歧义【FILE是选项参数还是位置参数】，这是不可避免的，唯有开发者在帮助文档中用-f FILE和-f &lt;FILE&gt;分别表示选项参数和位置参数，才能使使用者更明确。 4.尽管文档中参数argument将&lt;argument&gt;和ARGUMENT统称为「位置参数」，但如果将其分别表示位置参数和选项参数则可消除该歧义。 (4)关于「可选元素」由于可选元素是否包含在相同或不同的括号内并不重要，因此my_program [command --option &lt;argument&gt;]中的3个元素共有8种组合而不是2种：12345678910111213# 错误的「所有可能性」：my_programmy_program command --option argument# 正确的「所有可能性」：my_programmy_program commandmy_program --optionmy_program argumentmy_program command --optionmy_program command argumentmy_program --option argumentmy_program command --option argument如果将其改写为它的等价形式my_program [command] [--option] [&lt;argument&gt;]则很容易理解，难的是理解两者为何等价。 (5)关于「连字符」双连字符和单连字符除去上文特殊含义外「仅仅是一个普通命令，可赋予任何意义」。 文档没有对这句话进行解释，我的理解是my_program command也可以写作my_program --或者my_program -，如果该命令是可选的，那么my_program [--]岂不是又会有到底是选项参数分隔符还是命令的歧义了。 所以说，最好还是将它们限制在选项参数分隔符和处理标准输入的特定含义吧。 (6)关于「约定惯例」约定或惯例（convention）只是为了方便彼此交流和理解而形成的规定，并不是一项带强制性的标准，因此并非所有帮助信息都遵循了这些规定，所以更多时候需要结合具体情况来推断。 以下列举几个例子：①vim命令。包括「命令的简要描述」、「使用模式」和「选项描述」三个部分，如图（截图不完整）。 图中将「选项」写作「Arguments」，需要根据该帮助信息来推断各元素的含义。其中，紫色框中以单连字符-表示从标准输入stdin读取文本，双连字符--表示后面的参数为文件。 同理，在cat命令中单连字符-含义与此相同，如图所示（截图为cat --help的部分内容）： 双连字符--在rm命令中还可以标识以单连字符-开头的文件，例如删除当前文件夹下名为-foo的文件，可以使用rm -- -foo或rm ./-foo，如图所示（截图为rm --help的部分内容）： ②chmod命令。包括「使用模式」、「命令描述」、「选项描述」以及「补充信息」四个部分，如图所示。 注意chmod命令第一种使用模式中MODE[,MODE]...的重复元素写法。 ③who命令包括「使用模式」、「命令描述」、「选项描述」以及「补充信息」四个部分，如图所示。 注意who命令使用模式中[FILE | ARG1 ARG2]的FILE和ARG1 ARG2这对互斥元素实际上包含了两种使用模式，这在后面的「补充信息」中也有说明即：12Usage: who [option]... [FILE]Usage: who [option]... [(ARG1 ARG2)] 同时，上文关于「选项」及歧义中指出：一般而言，短格式选项是长格式选项的缩写，也就是一个短格式选项会有对应的长格式选项。从上面的例子可以看出，一个选项可以只有短格式选项（如-m），可以只有长格式选项（如--version），也可以同时都有（如-a，--all）。 注意：尽管大多数命令都有选项描述，因此上述提到的歧义都将解释为带参数的单个选项。但是也有一些命令没有选项描述，例如ssh命令。 在这种情况下，诸如-b bind_address中的address将被解释为独立的位置参数【而不是-b的选项参数】。然而此处这两种理解的运行效果没有分别，因此尽管在理论上会存在歧义，但实际上开发者会避免掉歧义情况的出现。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hwame.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://hwame.top/tags/Linux/"}]},{"title":"Linux中易混淆的概念","slug":"confusing-concepts-in-linux","date":"2020-11-29T05:52:55.000Z","updated":"2020-11-30T00:00:56.000Z","comments":true,"path":"20201129/confusing-concepts-in-linux.html","link":"","permalink":"https://hwame.top/20201129/confusing-concepts-in-linux.html","excerpt":"","text":"文章说明文章作者：鴻塵文章说明：学习Linux shell过程中的记录，参考书籍主要有《Linux命令行与shell脚本编程大全（第3版）》，《鸟哥的Linux私房菜（第三版）》系列和《快乐的 Linux 命令行》，参考资料主要有Linux命令大全等。文章链接：https://hwame.top/20201129/confusing-concepts-in-linux.html 1.单引号、双引号和反引号①echo命令可用单引号或双引号来划定文本字符串。如果在字符串中用到了它们，你需要在文本中使用其中一种引号，而用另外一种来将字符串划定起来。 单引号字符串的限制： 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的； 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。 双引号的优点： 双引号里可以有变量 双引号里可以出现转义字符 ②反引号ˋ用于从命令输出中提取信息，将命令输出赋给变量，另一种格式是$()，例如： 注意：赋值等号和命令替换字符之间没有空格。12testing=`date`testing=$(date) 2.各种括号的作用 本部分各种括号的作用内容参考：shell中各种括号的作用()、(())、[]、[[]]、{} 2.1.小括号/圆括号 单小括号() ①命令组。括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被脚本余下的部分使用。括号中多个命令之间用分号隔开，最后一个命令可以没有分号，各命令和括号之间不必有空格。 ②命令替换。等同于cmd，shell扫描一遍命令行，发现了$( cmd )结构，便将$( cmd )中的cmd执行一次，得到其标准输出，再将此输出放到原来命令。有些shell不支持，如tcsh。 ③初始化数组。如：array=(a b c d)。 双小括号(( )) ①整数扩展。这种扩展计算是整数型的计算，不支持浮点型。((exp))结构扩展并计算一个算术表达式的值，如果表达式的结果为0，那么返回的退出状态码为1（或者是「假」），而一个非零值的表达式所返回的退出状态码将为0（或者是「真」）。若是逻辑判断，表达式exp为真则为1，假则为0。 ②C语言运算规则。只要括号中的运算符、表达式符合C语言运算规则，都可用在$(( exp ))中，甚至是三目运算符。作不同进位(如二进制、八进制、十六进制)运算时，输出结果全都自动转化成了十进制。如：echo $(( 16#5f ))结果为95(16进位转十进制)。 ③单纯用 (( )) 也可重定义变量值，比如a=5; (( a++ ))可将$a重定义为6。 ④常用于算术运算比较，双括号中的变量可以不使用$符号前缀。括号内支持多个表达式用逗号分开。 只要括号中的表达式符合C语言运算规则，比如可以直接使用for (( i = 0; i &lt; 5; i++ ))，如果不使用双括号，则为for i in ˋseq 0 4ˋ或者for i in &#123;0..4&#125;。再如可以直接使用if (($i&lt;5))，如果不使用双括号，则为if [ $i -lt 5 ]。 2.2.中括号/方括号 单中括号[] ①bash的内部命令，[和test是等同的。如果我们不用绝对路径指明，通常我们用的都是bash自带的命令。if/test结构中的左中括号是调用test的命令标识，右中括号是关闭条件判断的。这个命令把它的参数作为比较表达式或者作为文件测试，并且根据比较的结果来返回一个退出状态码。if/test结构中并不是必须右中括号，但是新版的Bash中要求必须这样。 ②test和[]中可用的比较运算符只有==和!=，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用-eq、-gt这种形式。无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，例如：[ ab \\&lt; bc ]，结果为真，也就是返回状态为0。[ ]中的逻辑与和逻辑或使用-a和-o表示。 ③字符范围。用作正则表达式的一部分，描述一个匹配的字符范围，作为test用途的中括号内不能使用正则。 ④在一个array结构的上下文中，中括号用来引用数组中每个元素的编号。 双中括号[[ ]] ①[[是bash程序语言的关键字，并不是一个命令，[[ ]]结构比[ ]结构更加通用。在[[和]]之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。 ②支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如[[ hello == hell? ]]，结果为真。[[ ]]中匹配字符串或通配符，不需要引号。 ③使用[[ ... ]]条件判断结构而非[ ... ]，能够防止脚本中的许多逻辑错误。比如，&amp;&amp;、||、&lt;和&gt;操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话会报错。比如可以直接使用if [[ $a != 1 &amp;&amp; $a != 2 ]]，如果不使用双括号则为if [ $a -ne 1] &amp;&amp; [ $a != 2 ]或者if [ $a -ne 1 -a $a != 2 ]。 ④bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。 2.3.大括号/花括号⑴常规用法 大括号拓展。通配（globbing）将对大括号中的文件名做扩展。在大括号中，不允许有空白，除非这个空白被引用或转义。 第一种：对大括号中的以逗号分割的文件列表进行拓展。如touch &#123;a,b&#125;.txt结果为a.txt b.txt。 第二种：对大括号中以点点..分割的顺序文件列表起拓展作用，如：touch &#123;a..d&#125;.txt结果为a.txt b.txt c.txt d.txt。 注：在参考文章关于大括号拓展举例中，ls &#123;ex[1-3],ex4&#125;.sh可以扩展，但touch &#123;ex[1-3],ex4&#125;.sh只创建了两个文件。 代码块，又被称为内部组，这个结构事实上创建了一个匿名函数。与小括号中的命令不同，大括号内的命令不会新开一个子shell运行，即脚本余下部分仍可使用括号内变量。括号内的命令间用分号隔开，最后一个也必须有分号。&#123;&#125;的第一个命令和左括号之间必须要有一个空格。 ⑵几种特殊的替换结构 ①$&#123;var:-string&#125;：若变量var为空，则用在命令行中用string来替换$&#123;var:-string&#125;；变量var不为空时，则用变量var的值来替换$&#123;var:-string&#125;。 ②$&#123;var:=string&#125;：替换规则和①相同，所不同之处是$&#123;var:=string&#125;若var为空时，用string替换$&#123;var:=string&#125;的同时还把string赋给变量var。$&#123;var:=string&#125;很常用的一种用法是，判断某个变量是否赋值，没有的话则给它赋上一个默认值。 ②$&#123;var:+string&#125;的替换规则和上面①②相反，即只有当var不是空的时候才替换成string，若var为空时则不替换或者说是替换成变量var即空值。 ③$&#123;var:?string&#125;替换规则为：若变量var不为空，则用变量var的值来替换$&#123;var:?string&#125;；若变量var为空，则把string输出到标准错误中，并从脚本中退出。我们可利用此特性来检查是否设置了变量的值。 补充扩展：在上面的替换结构中string不一定是常值的，可用另外一个变量的值或是一种命令的输出。 ⑶四种模式匹配替换结构 模式匹配记忆方法： #是去掉左边(在键盘上#在$之左边) %是去掉右边(在键盘上%在$之右边) #和%中的单一符号是最小匹配，两个相同符号是最大匹配 第一种模式：$&#123;variable%pattern&#125;。shell在variable中查找，看它是否以给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最短的匹配模式； 第二种模式：$&#123;variable%%pattern&#125;。shell在variable中查找，看它是否以给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式； 第三种模式：$&#123;variable#pattern&#125;。shell在variable中查找，看它是否以给的模式pattern开始，如果是，就从命令行把variable中的内容去掉左边最短的匹配模式； 第四种模式：$&#123;variable##pattern&#125;。shell在variable中查找，看它是否以给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉左边最长的匹配模式。 这四种模式中都不会改变variable的值，其中，只有在pattern中使用了*匹配符号时，%和%%、#和##才有区别。结构中的pattern支持通配符，*表示零个或多个任意字符，?表示仅与一个任意字符匹配，[...]表示匹配中括号里面的字符，[!...]表示不匹配中括号里面的字符 。 ⑷字符串提取和替换 第一种模式：$&#123;var:num&#125;。shell在var中提取第num个字符到末尾的所有字符。若num为正数，从左边0处开始；若num为负数，从右边开始提取字串，但必须在冒号后面加空格或一个数字或整个num加上括号，如$&#123;var: -2&#125;、$&#123;var:1-3&#125;或$&#123;var:(-2)&#125;。 第二种模式：$&#123;var:num1:num2&#125;。num1是位置，num2是长度。表示从$var字符串的第$num1个位置开始提取长度为$num2的子串。不能为负数。 第三种模式：$&#123;var/pattern/pattern&#125;。将var字符串的第一个匹配的pattern替换为另一个pattern。 第四种模式：$&#123;var//pattern/pattern&#125;。将var字符串中的所有能匹配的pattern替换为另一个pattern。 2.4.符号$后的括号 （1）$&#123;a&#125;：变量a的值，在不引起歧义的情况下可以省略大括号。 （2）$(cmd)：命令替换，和cmd效果相同，结果为cmd命令的输出，不过某些Shell版本不支持$()形式的命令替换，如tcsh。 （3）$((expression))：效果和expr expression相同，计算数学表达式expression的数值，其中expression只要符合C语言的运算规则即可，甚至三目运算符和逻辑表达式都可以计算。 2.5.使用括号将多条命令执行 （1）单小括号：(cmd1; cmd2; cmd3)。新开一个子shell顺序执行命令cmd1, cmd2, cmd3，各命令之间用分号隔开，最后一个命令后可以没有分号。 （2）单大括号：&#123; cmd1; cmd2; cmd3;&#125;。在当前shell顺序执行命令cmd1, cmd2, cmd3，各命令之间用分号隔开，最后一个命令后必须有分号，第一条命令和左括号之间必须用空格隔开。 注意：对&#123;&#125;和()而言，括号中的重定向符只影响该条命令， 而括号外的重定向符影响到括号中的所有命令。 3.重定向和管道 输出重定向（&gt;）：将命令的输出发送到一个文件中，其中单大于号（&gt;）会覆盖文件内容，双大于号（&gt;&gt;）用以向文件追加数据。 输入重定向（&lt;）：将文件的内容重定向到命令，与输出重定向正好相反。 内联输入重定向（&lt;&lt;）：输入重定向的另一种方法，这种方法无需使用文件进行重定向，只需要在命令行中指定用于输入重定向的数据就可以了。必须指定一个文本标记来划分输入数据的开始和结尾。任何字符串都可作为文本标记，但在数据的开始和结尾文本标记必须一致。 记忆方法：在命令行上，命令总是在左侧，而重定向符号「指向」数据流动的方向。小于号说明数据正在从输入文件流向命令。 管道（|）：将一个命令的输出作为另一个命令的输入（虽然可以用重定向来实现，但是有些笨拙）。 注意： ①不要以为由管道串起的两个命令会依次执行。 Linux系统实际上会同时运行这两个命令，在系统内部将它们连接起来。在第一个命令产生输出的同时，输出会被立即送给第二个命令。数据传输不会用到任何中间文件或缓冲区。 ②可以在一条命令中使用任意多条管道。 4.退出状态码shell中运行的每个命令都使用退出状态码（exit status）告诉shell它已经运行完毕。 按照惯例，一个成功结束的命令的退出状态码是0。如果一个命令结束时有错误，退出状态码就是一个正数值。 退出状态码是一个0～255的整数值，在命令结束运行时由命令传给shell，可以使用变量$?捕获这个值（上个已执行命令的退出状态码）并在脚本中使用。自定义退出状态码（exit n）时，若n超出0~255区间则对256取余。 状态码 描述 0 命令成功结束 1 一般性未知错误 2 不适合的shell命令 126 命令不可执行 127 没找到命令 128 无效的退出参数 128+x 与Linux信号x相关的严重错误 130 通过Ctrl+C终止的命令 255 正常范围之外的退出状态码 5.待续","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hwame.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://hwame.top/tags/Linux/"},{"name":"shell","slug":"shell","permalink":"https://hwame.top/tags/shell/"}]},{"title":"Linux世界的规则","slug":"rules-of-linux","date":"2020-11-29T05:51:52.000Z","updated":"2020-12-03T13:05:34.000Z","comments":true,"path":"20201129/rules-of-linux.html","link":"","permalink":"https://hwame.top/20201129/rules-of-linux.html","excerpt":"","text":"文章说明文章作者：鴻塵文章说明：学习Linux过程中的记录，参考书籍主要有《Linux命令行与shell脚本编程大全（第3版）》，《鸟哥的Linux私房菜（第三版）》系列和《快乐的 Linux 命令行》，参考资料主要有Linux命令大全等。文章链接：https://hwame.top/20201129/rules-of-linux.html 1.常见Linux目录名称 目录 用途 / 虚拟目录的根目录，万物起源。通常不会在这里存储文件 /bin 二进制目录，存放许多用户级的GNU工具 /boot 启动目录，包含Linux内核，存放启动文件/boot/grub/grub.conf or menu.lst，被用来配置启动加载程序/boot/vmlinuz，Linux 内核 /dev 设备目录，Linux在这里创建设备节点 /etc 系统配置文件目录，也包含一系列的shell脚本/etc/crontab，定义自动运行的任务/etc/fstab，包含存储设备的列表，以及与他们相关的挂载点/etc/passwd，包含用户帐号列表 /home 主目录，Linux在这 里创建用户目录 /lib 库目录，存放系统和应用程序的库文件 /media 媒体目录，可移动媒体设备的常用挂载点 /mnt 挂载目录，另一个可移动媒体设备的常用挂载点 /opt 可选目录，常用于存放第三方软件包和数据文件 /proc 进程目录，存放现有硬件及当前进程的相关信息 /root root用户的主目录 /sbin 系统二进制目录，存放许多GNU管理员级工具 /run 运行目录，存放系统运作时的运行时数据 /srv 服务目录，存放本地服务的相关文件 /sys 系统目录，存放系统硬件信息的相关文件 /tmp 临时目录，可以在该目录中创建和删除临时工作文件 /usr 用户二进制目录，大量用户级的GNU工具和数据文件都存储在这里，它可能是Linux系统中最大的一个/usr/bin，包含系统安装的可执行程序，通常会包含许多程序/usr/lib，包含由/usr/bin目录中的程序所用的共享库/usr/local，非系统发行版自带却打算让系统使用的程序的安装目录/usr/sbin，包含许多系统管理程序/usr/share，包含许多由/usr/bin目录中的程序使用的共享数据，其中包括像默认的配置文件、图标、桌面背景、音频文件等等/usr/share/doc，大多数安装在系统中的软件包会包含一些文档 /var 可变目录，用以存放经常变化的文件，比如日志文件 2.通配符2.1.通配符 通配符 意义 * 匹配任意多个字符（包括零个或一个） ? 匹配任意一个字符（不包括零个） [characters] 匹配任意一个属于字符集中的字符 [!characters] 匹配任意一个不是字符集中的字符 [[:class:]] 匹配任意一个属于指定字符类中的字符 注意：不同于正则表达式中的.，此处的.仍表示其自身。 参考「通配符」和「正则表达式」的区别：通配符是系统级的，多用于文件名上，如find、ls、cp等；正则表达式则需要相关工具的支持，如egrep、awk、vi、perl等，多用于针对文件内容的文本过滤工具，如awk、sed等。 2.2.常用的字符类 通配符 意义 [:alnum:] 匹配任意一个字母或数字 [:alpha:] 匹配任意一个字母 [:digit:] 匹配任意一个数字 [:lower:] 匹配任意一个小写字母 [:upper:] 匹配任意一个大写字母 2.3.通配符范例 模式 匹配对象 * 所有文件 g* 文件名以g开头的文件 b*.txt 以b开头，中间任意多个（$\\ge 0$）字符，并以.txt结尾的文件 Data??? 以Data开头，其后紧接着 3 个字符的文件 [abc]* 文件名以a或b或c开头的文件 BACK.[0-9][0-9] 以BACK.开头并紧接2个数字的文件 [[:upper:]]* 以大写字母开头的文件 [![:digit:]]* 不以数字开头的文件 *[[:lower:]123] 以小写字母、1、2、3四种之一结尾的文件 3.命令表示法很多时候我们需要参考某个命令的用法，例如用command --help或man command查看帮助文档，但是选项参数太多，语法规则不知道意义，以下是简单介绍各符号的意义： 符号 意义 [] 表示可选的项目 &lt;&gt; 位置参数 () 必需 丨 表示互斥选项 ... 表示参数可重复 详细说明请参考： Linux命令行帮助文档命令语法公式格式详解和Git命令语法格式解读 DOCOPT: Command-line interface description language 命令行帮助文档语法格式详解 4.文件描述符与重定向Linux中万物皆文件，用文件描述符（file descriptor）来标识每个文件对象。每个进程一次最多可以有九个文件描述符。出于特殊目的，bash shell保留了前三个文件描述符： 文件描述符 缩写 描述 0 STDIN 标准输入 1 STDOUT 标准输出 2 STDERR 标准错误 默认情况下，STDERR文件描述符会和STDOUT文件描述符指向同样的地方（尽管分配给它们的文件描述符值不同）。也就是说，默认情况下，错误消息也会输出到显示器输出中。但STDERR并不会随着STDOUT的重定向而发生改变，例如将STDOUT重定向到某文件但是STDERR依然会打印到屏幕。 只重定向错误：只重定向错误消息需要将该文件描述符值放在重定向符号前，该值必须紧紧地放在重定向符号前，否则不会工作：command 2&gt; error.txt。注意，shell会只重定向错误消息，正常输出仍会显示在屏幕上。 重定向错误和数据：如果想重定向错误和正常输出，必须用两个重定向符号。需要在符号前面放上待重定向数据所对应的文件描述符，然后指向用于保存数据的输出文件：command 2&gt; error.txt 1&gt; output.txt。可以用这种方法将脚本的正常输出和脚本生成的错误消息分离开来。如果想将错误和正常输出重定向到同一个输出文件，则需使用特殊的重定向符号&amp;&gt;，即command &amp;&gt; allinfo.txt。注意，当使用&amp;&gt;符时命令生成的所有输出都会发送到同一位置，包括数据和错误，但是错误消息具有更高的优先级。 在脚本中重定向输出：包括「临时重定向行输出」和「永久重定向脚本中的所有命令」。 ①使用输出重定向符来将输出信息重定向到STDERR文件描述符，在重定向到文件描述符时必须在文件描述符数字之前加一个&amp;：command &gt;&amp;2。因为Linux默认会将STDERR导向STDOUT，因此直接运行没有区别，必须使用./mz.sh 2&gt; stderr.txt才能将脚本中所有导向STDERR的文本重定向到txt文件。见下例：123456#!/bin/bashecho &quot;This is an error&quot; &gt;&amp;2echo &quot;This is normal output&quot;# 执行将输出两句：./mz.sh# 执行将输出一句：./mz.sh 2&gt; stderr.txt ②如果脚本中有大量数据需要重定向，那么每句都重定向会很烦琐，因此可以用exec命令告诉shell在脚本执行期间重定向某个特定文件描述符，见下例：12345678#!/bin/bashexec 2&gt;testerrorecho &quot;This is the start of the script&quot;echo &quot;now redirecting all output to another location&quot;exec 1&gt;testoutecho &quot;This output should go to the testout file&quot;echo &quot;but this should go to the testerror file&quot; &gt;&amp;2 运行该脚本，四个echo语句中的一二句会打印到屏幕，第三句重定向到testout，第四句重定向到testerror。注意：一旦重定向了STDOUT或STDERR，就很难再将它们重定向回原来的位置。如果你需要在重定向中来回切换的话，见下文。 在脚本中重定向输入：exec命令允许你将STDIN重定向到Linux系统上的文件中：exec 0&lt; stdin.txt。这个命令会告诉shell它应该从文件stdin.txt中获得输入，而不是STDIN。这个重定向只要在脚本需要输入时就会作用。见下例：read命令读取用户在键盘上输入的数据。将STDIN重定向到文件后，当read命令试图从STDIN读入数据时，它会到文件去取数据，而不是键盘。12345678#!/bin/bashexec 0&lt; testfilecount=1while read linedo echo &quot;Line #$count: $line&quot; count=$[ $count + 1 ]done 在shell中最多可以有9个打开的文件描述符。其他6个从3~8的文件描述符均可用作输入或输出重定向。你可以将这些文件描述符中的任意一个分配给文件，然后在脚本中使用它们。你可以分配另外一个文件描述符给标准文件描述符，反之亦然。这意味着你可以将STDOUT的原来位置重定向到另一个文件描述符，然后再利用该文件描述符重定向回STDOUT。见下例：12345678#!/bin/bashexec 3&gt;&amp;1exec 1&gt;testoutecho &quot;This should store in the output file&quot;echo &quot;along with this line.&quot;exec 1&gt;&amp;3echo &quot;Now things should be back to normal&quot;首先，脚本将文件描述符3重定向到文件描述符1(STDOUT)的当前位置，这意味着任何发送给文件描述符3的输出都将出现在显示器上。第二个exec命令将STDOUT重定向到文件， shell现在会将发送给STDOUT的输出直接重定向到输出文件中。但是，文件描述符3仍然指向STDOUT原来的位置，也就是显示器。如果此时将输出数据发送给文件描述符3，它仍然会出现在显示器上，尽管STDOUT已经被重定向了。在向STDOUT（现在指向一个文件）发送一些输出之后，脚本将STDOUT重定向到文件描述符3的当前位置（现在仍然是显示器）。这意味着现在STDOUT又指向了它原来的位置：显示器。这个方法可能有点叫人困惑，但这是一种在脚本中临时重定向输出，然后恢复默认输出设置的常用方法。 同样，在重定向到文件之前，先将STDIN文件描述符保存到另外一个文件描述符，然后在读取完文件之后再将STDIN恢复到它原来的位置。见下例：1234567891011121314#!/bin/bashexec 6&lt;&amp;0exec 0&lt; testfilecount=1while read line; do echo &quot;Line #$count: $line&quot; count=$[ $count + 1 ]doneexec 0&lt;&amp;6read -p &quot;Are you done now? &quot; answercase $answer in Y|y) echo &quot;Goodbye&quot;;; N|n) echo &quot;Sorry, this is the end.&quot;;;esac文件描述符6用来保存STDIN的位置，然后脚本将STDIN重定向到一个文件testfile。read命令的所有输入都来自重定向后的STDIN（也就是输入文件）。在读取了所有行之后，脚本会将STDIN重定向到文件描述符6，从而将STDIN恢复到原先的位置。该脚本用了另外一个read命令来测试STDIN是否恢复正常了，这次它会等待键盘的输入。 5.待续","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hwame.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://hwame.top/tags/Linux/"},{"name":"shell","slug":"shell","permalink":"https://hwame.top/tags/shell/"}]},{"title":"Linux下shell脚本编程学习","slug":"learning-linux-shell-script","date":"2020-11-27T06:19:03.000Z","updated":"2020-12-09T11:14:50.000Z","comments":true,"path":"20201127/learning-linux-shell-script.html","link":"","permalink":"https://hwame.top/20201127/learning-linux-shell-script.html","excerpt":"摘要：从11月27日到12月9日，大概花了一个星期的时间，终于啃完了621页的《Linux命令行与shell脚本编程大全》。","text":"摘要：从11月27日到12月9日，大概花了一个星期的时间，终于啃完了621页的《Linux命令行与shell脚本编程大全》。 文章说明文章作者：鴻塵文章说明：学习shell过程中的记录，参考书籍主要有《Linux命令行与shell脚本编程大全（第3版）》，《鸟哥的Linux私房菜（第三版）》系列和《快乐的 Linux 命令行》，参考资料主要有Linux命令大全等。文章链接：https://hwame.top/20201127/learning-linux-shell-script.html 1.构建基本脚本1.1.创建shell脚本文件创建shell脚本文件时，必须在文件的第一行指定要使用的shell。其格式为：1#!/bin/bash在指定了shell之后，就可以在文件的每一行中输入命令，然后加一个回车符。 在通常的shell脚本中，井号（#）用作注释行。shell不会解释以#开头的行（除了以#!开头的第一行）。 1.2.运行脚本①作为可执行程序首先需要具有执行权限：chmod +x ./myfile，然后在脚本所在目录输入./myfile执行脚本。注意：若直接输入myfile则会报错「命令未找到」，因为shell会通过PATH环境变量来查找命令，所以可以采取两种方法： 将shell脚本文件所处的目录添加到PATH环境变量中； 用绝对或相对文件路径来引用shell脚本文件，如上使用相对路径。 ②作为解释器参数直接运行解释器，其参数就是shell脚本的文件名。例如/bin/sh myfile。注意，Linux下的可执行文件不需要拓展名，只需要拥有执行权限即可，因此文件名为myfile或myfile.sh都行。 2.使用结构化命令2.1.使用if-then语句最基本的结构化命令就是if-then语句。if-then语句有如下格式：1234if commandthen commandsfi注意：在其他编程语言中，if语句之后的对象是一个等式，这个等式的求值结果为TRUE或FALSE，条件为真时才执行then部分。bash shell的if语句会运行if后面的那个命令，如果该命令的退出状态码是0（即该命令成功运行），位于then部分的命令就会被执行。如果该命令的退出状态码是其他值，then部分的命令就不会被执行。注意：再说一遍，command一定会执行！注意：if-then语句的另一种形式如下，通过把分号放在待求值的命令尾部，就可以将then语句放在同一行上了，这样看起来更像其他编程语言中的if-then语句。123if command; then commandsfi 2.2.使用if-then-else语句当if语句中的命令返回退出状态码0时，then部分中的命令会被执行，这跟普通的if-then语句一样。当if语句中的命令返回非零退出状态码时，bash shell会执行else部分中的命令。123456if commandthen commands1else commands2fi 2.3.使用嵌套的if语句有时你需要检查脚本代码中的多种条件。对此，可以使用嵌套的if-then语句。书写多个if-then语句会使代码不易阅读，很难理清逻辑流程，因此可以使用else部分的另一种形式：elif。 这样就不用再书写多个if-then语句了。elif使用另一个if-then语句延续else部分。1234567if command1then commands1elif command2then commands2fi 2.4.test命令test命令提供了在if-then语句中测试不同条件的途径，可以测试命令退出状态码之外的条件。 如果test命令中列出的条件成立，test命令就会退出并返回退出状态码0。这样if-then语句就与其他编程语言中的if-then语句以类似的方式工作了。如果条件不成立，test命令就会退出并返回非零的退出状态码，这使得if-then语句不会再被执行。test命令的格式非常简单：12test condition# condition是test命令要测试的一系列参数和值注意：如果不写test命令的condition部分，它会以非零的退出状态码退出，并执行else语句块。注意：bash shell提供了另一种条件测试方法，无需在if-then语句中声明test命令，即使用方括号定义测试条件，如if [ condition ]注意，第一个方括号之后和第二个方括号之前必须加上一个空格，否则就会报错。 test命令判断三类条件：①数值比较；②字符串比较；③文件比较。 数值比较 比较 含义 描述 n1 -eq n2 equal 检查n1是否与n2相等 n1 -ge n2 greater or equal 检查n1是否大于或等于n2 n1 -gt n2 greater than 检查n1是否大于n2 n1 -le n2 less or equal 检查n1是否小于或等于n2 n1 -lt n2 less than 检查n1是否小于n2 n1 -ne n2 not equal 检查n1是否不等于n2 注意：bash shell只能处理整数，不能在test命令中使用浮点值。 字符串比较 比较 描述 备注 str1 = str2 检查str1是否和str2相同 考虑标点和大小写情况 str1 != str2 检查str1是否和str2不同 考虑标点和大小写情况 str1 &lt; str2 检查str1是否比str2小 需转义，注意顺序 str1 &gt; str2 检查str1是否比str2大 需转义，注意顺序 -n str1 检查str1是否长度非0 「非0」和「为0」恰好相反 -z str1 检查str1是否长度为0 空的和未初始化的变量长度为0 注意：比较字符串的大小时，大于号和小于号必须转义，否则shell会把它们当作重定向符号，把字符串值当作文件名。注意：比较字符串的大小时，大于和小于顺序和sort命令所采用的不同：在比较测试中，大写字母被认为是小于小写字母的，但sort命令恰好相反。注意：空的和未初始化的变量会对shell脚本测试造成灾难性的影响。如果不是很确定一个变量的内容，最好在将其用于数值或字符串比较之前先通过-n或-z来测试一下变量是否含有值。 文件比较文件比较很有可能是shell编程中最为强大、也是用得最多的比较形式。它允许你测试Linux文件系统上文件和目录的状态。 比较 含义 描述 备注 -d file directory 检查file是否存在并是一个目录 —— -e file exist 检查file是否存在 可用于文件和目录 -f file file 检查file是否存在并是一个文件 —— -r file readable 检查file是否存在并可读 —— -s file —— 检查file是否存在并非空 状态码0说明有数据 -w file writable 检查file是否存在并可写 判断你对文件是否有可写权限 -x file executable 检查file是否存在并可执行 —— -O file Owner 检查file是否存在并属当前用户所有 测试你是否是文件的属主 -G file Group 检查file是否存在并且默认组与当前用户相同 检查文件的默认组非用户所属所有组 file1 -nt file2 new than 检查file1是否比file2新 指创建日期，越早创建越旧 file1 -ot file2 old than 检查file1是否比file2旧 指创建日期，越早创建越旧 注意：在使用-nt或-ot比较文件之前，必须先确认文件是存在的，因为他们都不会先检查文件是否存在，所以会导致直接运行了else部分。 2.5.复合条件测试if-then语句允许使用布尔逻辑来组合测试，布尔逻辑是一种能够将可能的返回值简化为TRUE或FALSE的方法。有AND和OR两种布尔运算符可用：12[ condition1 ] &amp;&amp; [ condition2 ][ condition1 ] || [ condition2 ] 2.6.if-then的高级特性bash shell提供了两项可在if-then语句中使用的高级特性： ①用于数学表达式的双括号(( expression ))。expression可以是任意的数学赋值或比较表达式。除了test命令使用的标准数学运算符，双括号命令中会用到的其他运算符还有：val++，后增；val--，后减；++val，先增；--val，先减；!，逻辑求反；~，位求反；**，幂运算；&lt;&lt;，左位移；&gt;&gt;，右位移；&amp;，位布尔和；|，位布尔或；&amp;&amp;，逻辑和；||，逻辑或。注意⑴：可以在if语句中用双括号命令，也可以在脚本中的普通命令里使用来赋值。注意⑵：不需要将双括号中表达式里的大于号转义，这是双括号命令提供的另一个高级特性。 ②用于高级字符串处理功能的双方括号[[ expression ]]，注意不是所有的shell都支持双方括号。与test命令相比主要是指「模式匹配（pattern matching）」，例如：1234567#!/bin/bash# using pattern matchingif [[ $USER == h* ]]; then echo &quot;Hello $USER.&quot;else echo &quot;Sorry, I do not know you.&quot;fi 在上例中我们使用了双等号（==）将右边的字符串（h*）视为一个模式，并应用模式匹配规则。运行该脚本将输出「Hello hwame.」。 2.7.case命令case命令采用列表格式来检查单个变量的多个值，而不需要再写出所有的elif语句来不停地检查同一个变量的值了：12345case variable inpattern1 | pattern2) commands1;; pattern3) commands2;; *) commands_default;;esaccase命令提供了一个更清晰的方法来为变量每个可能的值指定不同的选项，将指定的变量与不同模式进行比较。 如果变量和模式是匹配的，那么shell会执行为该模式指定的命令。可以通过单竖线操作符在一行中分隔出多个模式模式。星号会捕获所有与已知模式不匹配的值。 3.循环语句3.1.for命令重复执行一系列命令在编程中很常见，for循环不用说，基本格式如下：1234for var in listdo commandsdonefor命令读取值的方式有：①从列表中读取值；②从变量读取列表；③从命令读取值；④用通配符读取目录。 注意：列表中各值按空格依次排列，不需要括号。注意：考虑下例，第2行输出将两个单引号间的部分拼接到don和ll中间了。这种问题可以采用①使用转义字符\\将单引号转义；②使用双引号来定义用到单引号的值。123456789#!/bin/bashfor test in I don&#x27;t know if this&#x27;ll work; do echo &quot;word:$test&quot;done# 以下为输出：word:Iword:dont know if thisllword:work注意：for循环假定每个值都是用空格分割的。如果在单独的数据值中有空格，就必须用双引号将这些值圈起来。注意：在某个值两边使用双引号时，shell并不会将双引号当成值的一部分。 通常shell脚本遇到的情况是，你将一系列值都集中存储在了一个变量中，然后需要遍历变量中的整个列表。也可以通过for命令完成这个任务，例如：注意，代码还是用了另一个赋值语句向$list变量包含的已有列表中添加（或者说是拼接）了一个值。这是向变量中存储的已有文本字符串尾部添加文本的一个常用方法：list=$list&quot; Connecticut&quot;。1234567#!/bin/bashlist=&quot;Alabama Alaska Arizona Arkansas Colorado&quot;list=$list&quot; Connecticut&quot;for state in $listdo echo &quot;Have you ever visited $state?&quot;done 上述代码中，shell以空格分隔列表，事实上是由特殊的环境变量IFS（Internal Field Separator，内部字段分隔符）控制。默认情况下， bash shell会将「空格」、「制表符」、「换行符」当作字段分隔符。如果需要临时使用新的字段分隔符，可以先保存旧值，使用完新值后再还原：1234IFS.OLD=$IFSIFS=$&#x27;\\n&#x27;&lt;在代码中使用新的IFS值&gt;IFS=$IFS.OLD 如果要指定多个IFS字符，只要将它们在赋值行串起来就行：IFS=$&#39;\\n&#39;:;&quot;，这个赋值会将换行符、冒号、分号和双引号作为字段分隔符。如何使用IFS字符解析数据没有任何限制。 可以用for命令来自动遍历目录中的文件。进行此操作时，必须在文件名或路径名中使用通配符。它会强制shell使用文件扩展匹配。文件扩展匹配是生成匹配指定通配符的文件名或路径名的过程。也可以在for命令中列出多个目录通配符，将目录查找和列表合并进同一个for语句。注意：在Linux中，目录名和文件名中包含空格当然是合法的。要适应这种情况，应该将$file变量用双引号圈起来：if [ -d &quot;$file&quot; ]。如果不这么做，遇到含有空格的目录名或文件名时就会有错误产生：[: too many arguments，在test命令中，bash shell会将额外的单词当作参数，进而造成错误。 3.2.C语言风格的for命令下面为C语言代码：1234for (i = 0; i &lt; 10; i++)&#123; printf(&quot;The next number is %d\\n&quot;, i);&#125;以下是bash中C语言风格的for循环的基本格式：12for (( variable assignment ; condition ; iteration process ))for (( a = 1; a &lt; 10; a++ ))注意，有些部分并没有遵循bash shell标准的for命令： 变量赋值可以有空格； 条件中的变量不以美元符开头； 迭代过程的算式未用expr命令格式。 C语言风格的for命令也允许为迭代使用多个变量。循环会单独处理每个变量，你可以为每个变量定义不同的迭代过程。尽管可以使用多个变量，但你只能在for循环中定义一种条件，例如for (( a=1, b=10; a &lt;= 10; a++, b-- ))。 3.3.while命令while命令某种意义上是if-then语句和for循环的混杂体：1234while test_commanddo commandsdonewhile命令中定义的test_command和if-then语句中的格式一模一样。可以使用任何普通的bash shell命令，或者用test命令进行条件测试，比如测试变量值。while命令的关键在于所指定的test_command的退出状态码必须随着循环中运行的命令而改变。如果退出状态码不发生变化，while循环就将一直不停地进行下去从而陷入无限循环。 最常见的test_command的用法是用方括号来检查循环命令中用到的shell变量的值，while命令定义了每次迭代时检查的测试条件。 while命令允许你在while语句行定义多个测试命令。只有最后一个测试命令的退出状态码会被用来决定什么时候结束循环，见下例。12345678#!/bin/bashvar1=10while echo $var1 [ $var1 -ge 0 ]do echo &quot;This is inside the loop&quot; var1=$[ $var1 - 1 ]done运行结果如图：while循环会在var1变量等于0时执行echo语句，然后将var1变量的值减一。接下来再次执行测试命令，用于下一次迭代。echo测试命令被执行并显示了var变量的值（现在小于0了）。直到shell执行test测试命令，while循环才会停止。 这说明在含有多个命令的while语句中，在每次迭代中所有的测试命令都会被执行，包括测试命令失败的最后一次迭代。要留心这种用法。另一处要留意的是该如何指定多个测试命令。注意，每个测试命令都出现在单独的一行上。 3.4.until命令until命令和while命令工作的方式完全相反。until命令要求你指定一个通常返回非零退出状态码的测试命令。只有测试命令的退出状态码不为0，bash shell才会执行循环中列出的命令。一旦测试命令返回了退出状态码0，循环就结束了。1234until commanddo commandsdone和while命令类似，你可以在until命令语句中放入多个测试命令。只有最后一个命令的退出状态码决定了bash shell是否执行已定义的commands，例如：12345678#!/bin/bashvar1=100until echo $var1 [ $var1 -eq 0 ]do echo Inside the loop: $var1 var1=$[ $var1 - 25 ]done运行结果如图，shell会执行指定的多个测试命令，只有在最后一个命令成立时停止。 3.5.嵌套循环循环语句可以在循环内使用任意类型的命令，包括其他循环命令，这种循环叫作嵌套循环（nested loop），被嵌套的循环也称为内部循环（inner loop）。 内外循环的两个do和done命令没有任何差别。bash shell知道当第一个done命令执行时是指内部循环而非外部循环。 在混用循环命令时也一样，比如在while循环内部放置一个for循环，或者在until循环内部放置一个while循环。12345678910111213#!/bin/bash# using until and while loopsvar1=3until [ $var1 -eq 0 ]; do echo &quot;Outer loop: $var1&quot; var2=1 while [ $var2 -lt 5 ]; do var3=$(echo &quot;scale=4; $var1 / $var2&quot; | bc) echo &quot; Inner loop: $var1 / $var2 = $var3&quot; var2=$[ $var2 + 1 ] done var1=$[ $var1 - 1 ]done运行结果如图，外部的until循环以值3开始，并继续执行到值等于0。内部while循环以值1开始并一直执行，只要值小于5。每个循环都必须改变在测试条件中用到的值，否则循环就会无止尽进行下去。 3.6.循环处理文件数据通常必须遍历存储在文件中的数据，这需要使用到上文提到的①使用嵌套循环；②修改IFS环境变量。 典型的例子是处理/etc/passwd文件中的数据。这要求你逐行遍历该文件，并将IFS变量的值改成冒号，这样就能分隔开每行中的各个数据段了。123456789101112#!/bin/bashIFS.OLD=$IFSIFS=$&#x27;\\n&#x27;for entry in $(cat /etc/passwd)do echo &quot;Values in $entry –&quot; IFS=: for value in $entry do echo &quot; $value&quot; donedone 3.7.控制循环break命令和continue命令能帮我们控制循环内部的情况，而不必等到循环完成所有的迭代： break命令：用来退出任意类型的循环，包括while和until循环。break命令接受单个命令行参数值：break n，其中n指定了要跳出的循环层级。默认情况下跳出的是当前的循环（即省略n时为n=1）；如果你n设为2就会停止下一级的外部循环。 continue命令：continue命令可以提前中止某次循环中的命令，但并不会完全终止整个循环。亦即停止当前进行的一次迭代，直接进入下一次迭代，注意仍在同级循环中。和break命令一样，continue命令也允许通过命令行参数指定要继续执行哪一级循环：continue n，其中n定义了要继续的循环层级。 注意：可以在while和until循环中使用continue命令，但要特别小心。记住，当shell执行continue命令时，它会跳过剩余的命令。如果你在其中某个条件里对测试条件变量进行增值，问题就会出现：12345678910111213#!/bin/bash# improperly using the continue command in a while loopvar1=0while echo &quot;while iteration: $var1&quot; [ $var1 -lt 15 ]do if [ $var1 -gt 5 ] &amp;&amp; [ $var1 -lt 10 ] then continue fi echo &quot; Inside iteration number: $var1&quot; var1=$[ $var1 + 1 ]done由于该程序会陷入死循环，因此可以将脚本的输出重定向到了more命令：./mytest | more，这样才能停止输出。运行结果如下：在if-then的条件成立之前，所有一切看起来都很正常，然后shell执行了continue命令。当shell执行continue命令时，它跳过了while循环中余下的命令。不幸的是，被跳过的部分正是$var1计数变量增值的地方，而这个变量又被用于while测试命令中，这意味着这个变量的值不会再变化了，从前面连续的输出显示中你也可以看出来。 下面是继续外部for循环的一个例子：123456789101112131415#!/bin/bash# continuing an outer loopfor (( a = 1; a &lt;= 5; a++ ))do echo &quot;Iteration $a:&quot; for (( b = 1; b &lt; 3; b++ )) do if [ $a -gt 2 ] &amp;&amp; [ $a -lt 4 ] then continue 2 fi var3=$[ $a * $b ] echo &quot; The result of $a * $b is $var3&quot; donedone其中的if-then语句用continue命令来停止处理循环内的命令，但会继续处理外部循环。注意，值为3的那次迭代并没有处理任何内部循环语句，因为尽管continue命令停止了处理过程，但外部循环依然会继续。运行结果如图： 3.8.处理循环的输出在shell脚本中，你可以对循环的输出使用管道或进行重定向，这可以通过在done命令之后添加一个处理命令来实现。 可以将循环的结果通过管道管接给另一个命令，例如将for命令的输出传给了sort命令，该命令会改变for命令输出结果的顺序，注意结果已经在脚本内部排好序了。 例如下面将for命令的输出重定向到文件的例子，在for命令之后正常显示了echo语句：123456#!/bin/bashfor (( a = 1; a &lt; 10; a++ ))do echo &quot;The number is $a&quot;done &gt; output.txtecho &quot;The command is finished.&quot;运行结果如图： 4.处理用户输入4.1.命令行参数向shell脚本传递数据的最基本方法是使用命令行参数，他允许在运行脚本时向命令行添加数据，例如./mytest 10 30向脚本mytest传递了两个命令行参数（10和30）。脚本会通过特殊的变量来处理命令行参数。 bash shell会将一些称为位置参数（positional parameter）的特殊变量分配给输入到命令行中的所有参数，这也包括shell所执行的脚本名称。 位置参数变量是标准的数字：$0是程序名，$1是第一个参数，$2是第二个参数，依次类推，直到第九个参数$9。如果脚本需要的命令行参数不止9个，则必须在变量数字周围加上花括号，比如$&#123;10&#125;。 如果需要输入更多的命令行参数，则每个参数都必须用空格分开，shell会将每个参数分配给对应的变量。要在参数值中包含空格，必须要用引号（单引号或双引号均可）。注意：将文本字符串作为参数传递时，引号并非数据的一部分，它们只是表明数据的起止位置。注意：利用$0读取脚本名时存在一个潜在的问题，即$0参数会同时包含路径和连在一起的命令，如下表所示。解决这个问题只需要使用basename命令，他会返回不包含路径的脚本名：basename $0，例如script=$(basename $0)。 执行命令 $0变量 备注 bash mz.sh mz.sh 没有问题 ./mz.sh ./mz.sh 包含命令 bash /home/hwame/mz.sh /home/hwame/mz.sh 包含路径 在shell脚本中使用命令行参数时要小心些。当脚本认为参数变量中会有数据而实际上并没有时，脚本很有可能会产生错误消息。通俗的说，当脚本中使用了变量$1、$2、$3时，如果允许脚本时没有给出对应的命令行参数则会报错。 因此在使用参数前一定要检查其中是否存在数据，一种方法是使用-n测试来检查命令行参数$1中是否有数据：if [ -n &quot;$1&quot;]; then。 4.2.特殊参数变量如果每次都在脚本中使用之前检查一下命令行参数，无疑比较麻烦。bash shell为此提供了一个特殊变量$#，他含有脚本运行时携带的命令行参数的个数。可以在脚本中任何地方使用这个特殊变量，就跟普通变量一样。注意，变量$#的值不包括脚本名称。 那么问题来了。既然$#变量含有参数的总数，那么变量$&#123;$#&#125;就代表了最后一个命令行参数变量。然而并不是这样，你不能在花括号内使用美元符，必须将美元符换成感叹号即$&#123;!#&#125;。很奇怪，但不讲道理。我们也可以拆分一下，将$#赋值给一个变量params然后再使用params变量：12345#!/bin/bash# Grabbing the last parameterparams=$#echo The last parameter is $paramsecho The last parameter is $&#123;!#&#125;上述示例中的两种方式都没问题。但要注意，当命令行上没有任何参数时，$#的值为0，params变量的值也一样，但$&#123;!#&#125;变量会返回命令行用到的脚本名。 有时候需要抓取命令行上提供的所有参数，希望能够在单个变量中存储所有的命令行参数，而不是先用$#变量来判断命令行上有多少参数，然后再进行遍历。 可以使用一组其他的特殊变量$*和$@来解决这个问题： $*变量会将命令行上提供的所有参数当作一个单词保存，这个单词包含了命令行中出现的每一个参数值。基本上$*变量会将这些参数视为一个整体，而不是多个个体。 $@变量会将命令行上提供的所有参数当作同一字符串中的多个独立的单词。通常通过for命令遍历所有的参数值，得到每个参数。 通过使用for命令遍历这两个特殊变量，可以看到它们是如何不同地处理命令行参数的。 $*变量会将所有参数当成单个参数，而$@变量会单独处理每个参数。这是遍历命令行参数的一个绝妙方法。二者之间的差异见下例：123456789101112131415#!/bin/bashcount=1for param in &quot;$*&quot;do echo &quot;\\$* Parameter #$count = $param&quot; count=$[ $count + 1 ]doneechocount=1for param in &quot;$@&quot;do echo &quot;\\$@ Parameter #$count = $param&quot; count=$[ $count + 1 ]done运行结果如图： 4.3.移动变量bash shell的shift命令能够用来操作命令行参数。顾名思义，他会根据它们的相对位置来移动命令行参数。默认情况下它会将每个参数变量向左移动一个位置。所以，变量$3的值会移到$2中，变量$2的值会移到$1中，而变量$1的值则会被删除（注意，变量$0的值即程序名不会改变）。也可以一次性移动多个位置，只需要给shift命令提供一个参数指明要移动的位置数就行了：shift n。注意：如果某个参数被移出，它的值就被丢弃了，无法再恢复。 这是遍历命令行参数的另一个好方法，尤其是在你不知道到底有多少参数时。你可以只操作第一个参数，移动参数，然后继续操作第一个参数，例如：1234567#!/bin/bashcount=1while [ -n &quot;$1&quot; ]; do echo &quot;Parameter #$count = $1&quot; count=$[ $count + 1 ] shiftdone运行结果如图所示： 4.4.处理选项「选项」是跟在单破折线后面的单个字母，它能改变命令的行为，此处介绍3种在脚本中处理选项的方法。 (1)查找选项表面上看，命令行选项也没什么特殊的。在命令行上，它们紧跟在脚本名之后，就跟命令行参数一样。实际上，如果愿意，你可以像处理命令行参数一样处理命令行选项。 ①处理简单选项：可以用shift命令来处理脚本程序携带的命令行选项，用case语句来判断某个参数是否为选项。case语句会检查每个参数是不是有效选项，如果是就运行对应语句中的命令。不管选项按什么顺序出现在命令行上，这种方法都适用。示例如下：1234567891011#!/bin/bash# extracting command line options as parameterswhile [ -n &quot;$1&quot; ]; do case &quot;$1&quot; in -a) echo &quot;Found the -a option&quot; ;; -b) echo &quot;Found the -b option&quot; ;; -c) echo &quot;Found the -c option&quot; ;; *) echo &quot;$1 is not an option&quot; ;; esac shiftdone ②分离参数和选项：对于在shell脚本中同时使用选项和参数的情况，标准方式是用特殊字符（双破折线--）来将二者分开，该字符会告诉脚本何时选项结束以及普通参数何时开始。shell会用双破折线来表明选项列表结束。在双破折线之后，脚本就可以放心地将剩下的命令行参数当作参数，而不是选项来处理了。要检查双破折线，只要在case语句中加一项就行了，如下例所示：12345678910111213141516171819#!/bin/bash# extracting options and parameterswhile [ -n &quot;$1&quot; ]; do case &quot;$1&quot; in -a) echo &quot;Found the -a option&quot; ;; -b) echo &quot;Found the -b option&quot; ;; -c) echo &quot;Found the -c option&quot; ;; --) shift break ;; *) echo &quot;$1 is not an option&quot; ;; esac shiftdonecount=1for param in $@; do echo &quot;Parameter #$count: $param&quot; count=$[ $count + 1 ]done 运行结果如图，可以看出，第一次未分离时脚本认为所有的命令行参数都是选项；第二次使用--分离后，当脚本遇到双破折线时，它会停止处理选项，并将剩下的参数都当作命令行参数。 ③处理带值的选项：有些选项会带上一个额外的参数值，例如：./mz.sh -a test1 -b -c -d test2。当命令行选项要求额外的参数时，脚本必须能检测到并正确处理，如下例：123456789101112131415161718192021#!/bin/bash# extracting command line options and valueswhile [ -n &quot;$1&quot; ]; do case &quot;$1&quot; in -a) echo &quot;Found the -a option&quot;;; -b) param=&quot;$2&quot; echo &quot;Found the -b option, with parameter value $param&quot; shift ;; -c) echo &quot;Found the -c option&quot;;; --) shift break ;; *) echo &quot;$1 is not an option&quot;;; esac shiftdonecount=1for param in &quot;$@&quot;; do echo &quot;Parameter #$count: $param&quot; count=$[ $count + 1 ]done 在这个例子中，case语句定义了三个它要处理的选项，其中-b选项还需要一个额外的参数值。由于要处理的参数是$1，额外的参数值就应该位于$2（因为所有的参数在处理完之后都会被移出）。只要将参数值从$2变量中提取出来就可以了。当然，因为这个选项占用了两个参数位，所以你还需要使用shift命令多移动一个位置。运行结果如图： (2)getopt命令上述shell脚本已经有了处理命令行选项的基本能力，但还有一些限制。比如，合并选项是Linux中一个很常见的用法，如果你想将多个选项放进一个参数中时，它就不能工作了。getopt命令是一个在处理命令行选项和参数时非常方便的工具。它能够识别命令行参数，从而在脚本中解析它们时更方便。 命令格式：getopt optstring parameters。optstring是这个过程的关键所在，它定义了命令行有效的选项字母，还定义了哪些选项字母需要参数值。首先，在optstring中列出你要在脚本中用到的每个命令行选项字母。然后，在每个需要参数值的选项字母后加一个冒号。getopt命令会基于你定义的optstring解析提供的参数。 举例如图：命令行getopt ab:cd -a -b test1 -cd test2 test3中的optstring定义了四个有效选项字母：a、b、c和d。冒号（:）被放在了字母b后面，因为b选项需要一个参数值。当getopt命令运行时，它会检查提供的参数列表（-a -b test1 -cd test2 test3），并基于提供的optstring进行解析。注意，它会自动将-cd选项分成两个单独的选项，并插入双破折线来分隔行中的额外参数test2 test3。注意：如果指定了一个不在optstring中的选项，默认情况下getopt命令会产生一条错误消息，可以在命令后加-q选项来忽略这条错误消息。如下图所示： 可以在脚本中使用getopt来格式化脚本所携带的任何命令行选项或参数，但用起来略微复杂。用getopt命令生成的格式化后的版本来替换已有的命令行选项和参数，set命令的选项之一是双破折线--，它会将命令行参数替换成set命令的命令行值。 该方法会将原始脚本的命令行参数传给getopt命令，之后再将getopt命令的输出传给set命令，用getopt格式化后的命令行参数来替换原始的命令行参数，格式看起来如下所示：set -- $(getopt -q ab:cd &quot;$@&quot;)。现在原始的命令行参数变量的值会被getopt命令的输出替换，而getopt已经为我们格式化好了命令行参数。利用该方法就可以写出能帮我们处理命令行参数的脚本：123456789101112131415161718192021#!/bin/bashset -- $(getopt -q ab:cd &quot;$@&quot;)while [ -n &quot;$1&quot; ]; do case &quot;$1&quot; in -a) echo &quot;Found the -a option&quot; ;; -b) param=&quot;$2&quot; echo &quot;Found the -b option, with parameter value $param&quot; shift ;; -c) echo &quot;Found the -c option&quot; ;; --) shift break ;; *) echo &quot;$1 is not an option&quot;;; esac shiftdonecount=1for param in &quot;$@&quot;; do echo &quot;Parameter #$count: $param&quot; count=$[ $count + 1 ]done注意到该例和上文查找选项中第三种情况「处理带值的选项」一样，唯一不同的是加入了getopt命令来帮助格式化命令行参数。并且可以运行带有复杂选项的脚本如合并的选项：./mz.sh -ac，同时之前的功能照样没有问题。 (3)更高级的getopts命令然而，getopt命令并不擅长处理带空格和引号的参数值，它会将空格当作参数分隔符，而不是根据双引号将二者当作一个参数。 getopts命令（注意是复数）内建于bash shell，它跟近亲getopt看起来很像，但多了一些扩展功能。getopt将命令行上选项和参数处理后只生成一个输出，而getopts命令能够和已有的shell参数变量配合默契。 每次调用getopts时，它一次只处理命令行上检测到的一个参数。处理完所有的参数后，它会退出并返回一个大于0的退出状态码。这让它非常适合用于解析命令行所有参数的循环中。 getopts命令的格式如下：getopts optstring variable。optstring值类似于getopt命令中的那个。有效的选项字母都会列在optstring中，如果选项字母要求有个参数值，就加一个冒号。要去掉错误消息的话，可以在optstring之前加一个冒号。getopts命令将当前参数保存在命令行中定义的variable中。getopts命令会用到两个环境变量：OPTARG环境变量保存选项需要跟的一个参数值；OPTIND环境变量保存了参数列表中getopts正在处理的参数位置。这样你就能在处理完选项之后继续处理其他命令行参数了。1234567891011#!/bin/bash# simple demonstration of the getopts commandwhile getopts :ab:c optdo case &quot;$opt&quot; in a) echo &quot;Found the -a option&quot; ;; b) echo &quot;Found the -b option, with value $OPTARG&quot;;; c) echo &quot;Found the -c option&quot; ;; *) echo &quot;Unknown option: $opt&quot;;; esacdonewhile语句定义了getopts命令，指明了要查找哪些命令行选项，以及每次迭代中存储它们的变量名（opt）。注意到在本例中case语句的用法有些不同：getopts命令解析命令行选项时会移除开头的单破折线，所以在case定义中不用单破折线。getopts命令有几个好用的功能：①可以在参数值中包含空格；②可以将选项字母和参数值放在一起使用，而不用加空格，getopts命令能够从选项中正确解析出参数值；③可以将命令行上所有未定义的选项统一输出成问号，以问号形式发送给代码。上述代码运行结果如图： getopts命令知道何时停止处理选项，并将参数留给你处理。在getopts处理每个选项时，它会将OPTIND环境变量值增一。在getopts完成处理时，你可以使用shift命令和OPTIND值来移动参数。如下例：12345678910111213141516171819#!/bin/bashwhile getopts :ab:cd optdo case &quot;$opt&quot; in a) echo &quot;Found the -a option&quot; ;; b) echo &quot;Found the -b option, with value $OPTARG&quot; ;; c) echo &quot;Found the -c option&quot; ;; d) echo &quot;Found the -d option&quot; ;; *) echo &quot;Unknown option: $opt&quot; ;; esacdoneshift $[ $OPTIND - 1 ]count=1for param in &quot;$@&quot;do echo &quot;Parameter $count: $param&quot; count=$[ $count + 1 ]done运行结果如图： 4.5.将选项标准化所谓选项标准化，就是尽量遵循某些字母选项在Linux世界里已经拥有的某种程度的标准含义，而不是随意决定用哪些字母选项以及它们的用法，将选项标准化使得脚本看起来能更友好一些。常用的Linux命令选项如下： 选项 含义 描述 -a all 显示所有对象 -c count 生成一个计数 -d directory 指定一个目录 -e extend 扩展一个对象 -f file 指定读入数据的文件 -h help 显示命令的帮助信息 -i ignorecase 忽略文本大小写 -l long 产生输出的长格式版本 -n non-interactive 使用非交互模式（批处理） -o output redirect 将所有输出重定向到指定的输出文件 -q-s quietsilent 以安静模式运行 -r recursive 递归地处理目录和文件 -v verbose 生成详细输出 -x exclude 排除某个对象 -y yes 对所有问题回答yes 4.6.获得用户输入尽管命令行选项和参数是从脚本用户处获得输入的一种重要方式，但有时脚本的交互性还需要更强一些。比如你想要在脚本运行时问个问题，并等待运行脚本的人来回答。bash shell为此提供了read命令。 (1)基本的读取read命令从标准输入（键盘）或另一个文件描述符中接受输入，在收到输入后会将数据放进一个指定的变量。例如：1234#!/bin/bashecho -n &quot;Enter your name: &quot;read nameecho &quot;Hello $name, welcome to my program. &quot;注意，上例中生成提示的echo命令使用了-n选项。该选项不会在字符串末尾输出换行符，允许脚本用户紧跟其后输入数据，而不是下一行。这让脚本看起来更像表单。实际上，read命令包含了-p选项，允许你直接在read命令行指定提示符。例如：1234#!/bin/bashread -p &quot;Please enter your age: &quot; agedays=$[ $age * 365 ]echo &quot;That makes you over $days days old! &quot;read命令也允许指定多个变量，输入的每个数据值都会分配给变量列表中的下一个变量。如果变量数量不够，剩下的数据就全部分配给最后一个变量。是不是和Python中的*args和**kwargs有点像呢？也可以在read命令行中不指定变量，这样它收到的任何数据都会放进特殊环境变量REPLY中。REPLY环境变量会保存输入的所有数据，可以在shell脚本中像其他变量一样使用。 (2)超时如果不管是否有数据输入，脚本都必须继续执行，你可以用-t选项来指定一个计时器，他指定了read命令等待输入的秒数。当计时器过期后，read命令会返回一个非零退出状态码，可以使用if-then语句或while循环这种标准的结构化语句来理清所发生的具体情况。 也可以不对输入过程计时，而是让read命令来统计输入的字符数。当输入的字符达到预设的字符数时，就自动退出，将输入的数据赋给变量。可以将-n选项和值1一起使用，告诉read命令在接受单个字符后退出。只要按下单个字符回答后，read命令就会接受输入并将它传给变量，无需按回车键。12345678910#!/bin/bashread -n1 -p &quot;Do you want to continue [Y/N]? &quot; answercase $answer in Y | y) echo echo &quot;fine, continue on…&quot;;; N | n) echo echo OK, goodbye exit;;esacecho &quot;This is the end of the script&quot;运行结果如图： (3)隐藏方式读取当需要输入类似密码这种需要从脚本用户处得到输入，但又在屏幕上显示输入信息时，可以使用-s选项不回显终端的输入（实际上数据会被显示，只是read命令会将文本颜色设成跟背景色一样）。输入提示符输入的数据不会出现在屏幕上，但会赋给变量，以便在脚本中使用。例如：read -s -p &quot;Enter your password: &quot; password。 (4)从文件中读取可以用read命令来读取文件里的数据，每次调用read命令都会从文件中读取一行文本。当文件中再没有内容时，read命令会退出并返回非零退出状态码。如何将文件中的数据传给read命令呢？最常见的方法是对文件使用cat命令，将结果通过管道直接传给含有read命令的while命令。见下例：12345678#!/bin/bashcount=1cat textfile | while read linedo echo &quot;Line $count: $line&quot; count=$[ $count + 1]doneecho &quot;Finished processing the file&quot;文件textfile内容及运行结果如下： 5.创建函数5.1.基本脚本函数函数是一个脚本代码块，你可以为其命名并在代码中任何位置重用，调用函数（在脚本中使用该代码块）时只要使用所起的函数名就行了。 创建函数的第一种格式是采用关键字function，后跟分配给该代码块的函数名：name属性定义了赋予函数的唯一名称，脚本中定义的每个函数都必须有一个唯一的名称。commands是构成函数的一条或多条bash shell命令，在调用该函数时会按命令在函数中出现的顺序依次执行，就像在普通脚本中一样。123function name &#123; commands&#125; 创建函数的第二种格式更接近于其他编程语言中定义函数的方式：函数名后的空括号表明正在定义的是一个函数，这种格式的命名规则和之前定义shell脚本函数的格式一样。123name() &#123; commands&#125; 至于使用函数，只需要像其他shell命令一样，在行中指定函数名就行了。 注意①：函数定义不一定非得是shell脚本中首先要做的事，但必须在使用函数之前定义它，否则会收到一条command not found的错误消息。注意②：函数名必须是唯一的，如果你重定义了函数，新定义会覆盖原来函数的定义，这一切不会产生任何错误消息。 5.2.返回值bash shell会把函数当作一个小型脚本，运行结束时会返回一个退出状态码，生成退出状态码有以下3种不同的方法： 默认退出状态码：默认情况下，函数的退出状态码是函数中最后一条命令返回的退出状态码。在函数执行结束后，可以用标准变量$?来确定函数的退出状态码。注意：由于函数的默认退出状态码取决于函数体中最后一条命令的退出状态码，因此你无法知道函数中其他命令中是否成功运行，所以这种方法很危险。 使用return命令：使用return命令来退出函数并返回特定的退出状态码，它允许指定一个整数值来定义函数的退出状态码，从而提供了一种简单的途径来编程设定函数退出状态码。注意：①函数一结束就取返回值，否则可能会丢失返回值。②退出状态码的范围是0~255，超出则会取余。 使用函数输出：正如可以将命令的输出保存到shell变量中一样，你也可以对函数的输出采用同样的处理办法。可以用这种技术来获得任何类型的函数输出，并将其保存到变量中。见下例：1234567#!/bin/bashfunction myfunc &#123; read -p &quot;Enter a value: &quot; value echo $[ $value * 2 ]&#125;result=$(myfunc)echo &quot;The new value is $result&quot; 注意①：该函数实际上输出了两条消息，read命令输出了一条简短的消息来向用户询问输入值，但bash shell并不将其作为STDOUT输出的一部分，并且忽略掉它。如果你用echo语句生成这条消息来向用户查询，那么它会与输出值一起被读进shell变量中。注意②：这种方法还可以返回浮点值和字符串值，这使它成为一种获取函数返回值的强大方法。上例运行结果如图： 5.3.在函数中使用变量 在函数中使用变量时，你需要注意它们的定义方式以及处理方式——这是shell脚本中常见错误的根源。 向函数传递参数bash shell会将函数当作小型脚本来对待，这意味着你可以像普通脚本那样向函数传递参数。 函数可以使用标准的参数环境变量来表示命令行上传给函数的参数。例如，函数名会在$0变量中定义，函数命令行上的任何参数都会通过$1、$2等定义。也可以用特殊变量$#来判断传给函数的参数数目。注意①：在脚本中指定函数时，必须将参数和函数放在同一行，例如func1 $value1 10，result=$(func1 $value1 10)；注意②：由于函数使用特殊参数环境变量作为自己的参数值，因此它无法直接获取脚本在命令行中的参数值。尽管函数也使用了$1和$2变量，但它们和脚本主体中的$1和$2变量并不相同。要在函数中使用这些值，必须在调用函数时手动将它们传过去。12345678#!/bin/bashfunction myfunc &#123; echo $[ $1 * $2 ]&#125;value1=$(myfunc 10 20)value2=$(myfunc)value3=$(myfunc $1 $2)echo &quot;The result is $valuex&quot;如上例，value1是正常的函数调用方式，将参数和函数放在同一行。如果想让value2以这种方式直接获取命令行参数值将报错：syntax error: operand expected...，原因见上，解决办法就是按value3的方式。尽管在函数的定义和调用时都使用了$1和$2变量，但他们的区别就如同形参和实参。 在函数中处理变量变量的作用域也会经常带来麻烦，作用域是变量可见的区域。函数中定义的变量与普通变量的作用域不同，也就是说，对脚本的其他部分而言，它们是隐藏的。 函数使用两种类型的变量：全局变量和局部变量。 全局变量：在shell脚本中任何地方都有效的变量。如果你在脚本的主体部分定义了一个全局变量，那么可以在函数内读取它的值。类似地，如果你在函数内定义了一个全局变量，可以在脚本的主体部分读取它的值。默认情况下，在脚本中定义的任何变量都是全局变量。在函数外定义的变量可在函数内正常访问。注意：在使用全局变量时，如果变量被修改后新值将依然有效，这有时会产生难以预料的后果。它要求你清清楚楚地知道函数中具体使用了哪些变量，包括那些用来计算非返回值的变量。 局部变量：local关键字保证了变量只局限在该函数中，如果脚本中在该函数之外有同样名字的变量，那么shell将会保持这两个变量的值是分离的。如果要将函数内部使用的任何变量都声明成局部变量，只需要在变量声明的前面加上local关键字：local temp。也可以在变量赋值语句中使用local关键字：local temp=$[ $value + 5 ]。 5.4.数组变量和函数向函数传递数组参数向脚本函数传递数组变量的方法会有点不好理解。将数组变量当作单个参数传递的话，它不会起作用。见下例：1234567891011121314#!/bin/bashfunction testit &#123; echo &quot;The parameters are: $@&quot; thisarray=$1 echo &quot;The received array is $&#123;thisarray[*]&#125;&quot;&#125;myarray=(1 2 3 4 5)echo &quot;The original array is: $&#123;myarray[*]&#125;&quot;testit $myarray# 运行结果如下：# The original array is: 1 2 3 4 5# The parameters are: 1# The received array is 1如你所见，如果将该数组变量作为函数参数，函数只会取数组变量的第一个值。要解决这个问题，必须将该数组变量的值分解成单个值，然后将这些值作为函数参数使用。在函数内部，可以将所有的参数重新组合成一个新的变量。如下例所示，$myarray变量来保存所有的数组元素，然后将它们都放在函数的命令行上。该函数随后从命令行参数中重建数组变量。在函数内部，数组仍然可以像其他数组一样使用。12345678910111213#!/bin/bashfunction testit &#123; local newarray newarray=($(echo &quot;$@&quot;)) echo &quot;The new array value is: $&#123;newarray[*]&#125;&quot;&#125;myarray=(1 2 3 4 5)echo &quot;The original array is $&#123;myarray[*]&#125;&quot;testit $&#123;myarray[*]&#125;# 运行结果如下：# The original array is 1 2 3 4 5# The new array value is: 1 2 3 4 5下面是一个遍历数组并将所有元素累加的例子：12345678910111213141516#!/bin/bashfunction addarray &#123; local sum=0 local newarray newarray=($(echo &quot;$@&quot;)) for value in $&#123;newarray[*]&#125; do sum=$[ $sum + $value ] done echo $sum&#125;myarray=(1 2 3 4 5)echo &quot;The original array is: $&#123;myarray[*]&#125;&quot;arg1=$(echo $&#123;myarray[*]&#125;)result=$(addarray $arg1)echo &quot;The result is $result&quot;运行结果如图： 从函数返回数组从函数里向shell脚本传回数组变量也用类似的方法：函数用echo语句来按正确顺序输出单个数组值，然后脚本再将它们重新放进一个新的数组变量中。见下例：1234567891011121314151617181920#!/bin/bashfunction returnarray &#123; local oriarray local newarray local elements local i oriarray=($(echo &quot;$@&quot;)) newarray=($(echo &quot;$@&quot;)) elements=$[ $# - 1 ] for (( i = 0; i &lt;= $elements; i++ )) &#123; newarray[$i]=$[ $&#123;oriarray[$i]&#125; * 2 ] &#125; echo $&#123;newarray[*]&#125;&#125;myarray=(1 2 3 4 5)echo &quot;The original array is: $&#123;myarray[*]&#125;&quot;arg1=$(echo $&#123;myarray[*]&#125;)result=($(returnarray $arg1))echo &quot;The new array is: $&#123;result[*]&#125;&quot;该脚本用$arg1变量将数组值传给returnarray函数，函数将该数组重组到新的数组变量中，生成该输出数组变量的一个副本。然后对数据元素进行遍历，将每个元素值翻倍，并将结果存入函数中该数组变量的副本。returnarray函数使用echo语句来输出每个数组元素的值。脚本用returnarray函数的输出来重新生成一个新的数组变量。运行结果如图： 5.5.函数递归局部函数变量的一个特性是自成体系，除了从脚本命令行处获得的变量，自成体系的函数不需要使用任何外部资源。这个特性使得函数可以递归地调用，也就是说，函数可以调用自己来得到结果。通常递归函数都有一个最终可以迭代到的基准值。许多高级数学算法用递归对复杂的方程进行逐级规约，直到基准值定义的那级。递归算法的经典例子是计算阶乘：1234567891011121314#!/bin/bashfunction factorial &#123; if [ $1 -eq 1 ] then echo 1 else local temp=$[ $1 - 1 ] local result=$(factorial $temp) echo $[ $result * $1 ] fi&#125;read -p &quot;Enter value: &quot; valueresult=$(factorial $value)echo &quot;The factorial of $value is: $result&quot;运行结果如下： 5.6.创建库bash shell允许创建函数库文件，然后在多个脚本中引用该库文件。第一步需要创建一个包含脚本中所需函数的公用库文件，例如定义了3个简单的函数的库文件myfuncs。第二步就是在用到这些函数的脚本文件中包含该库文件，但是问题就来了。 和环境变量一样，shell函数仅在定义它的shell会话内有效。如果你在shell命令行界面的提示符下运行myfuncs的shell脚本，shell会创建一个新的shell并在其中运行这个脚本。它会为那个新shell定义这三个函数，但当你运行另外一个要用到这些函数的脚本时，它们是无法使用的。这同样适用于脚本：如果你尝试像普通脚本文件那样运行库文件，函数并不会出现在脚本中。例如运行下例将报错addem: command not found：12345#!/bin/bash./myfuncs# 库文件中的函数addem将两数相加result=$(addem 10 15)echo &quot;The result is $result&quot; 使用函数库的关键在于source命令。 source命令会在当前shell上下文中执行命令，而不是创建一个新shell。可以用source命令来在shell脚本中运行库文件脚本。这样脚本就可以使用库中的函数了。source命令有个快捷的别名.，称作点操作符（dot operator）。要在shell脚本中运行myfuncs库文件，只需添加：. ./myfuncs。如果库文件和shell脚本不是位于同一目录，则需要使用相应路径访问该库文件。 5.7.在命令行上使用函数和在shell脚本中将脚本函数当命令使用一样，在命令行界面的提示符下你也可以直接使用这些函数。一旦在shell中定义了函数，你就可以在整个系统中使用它了，无需担心脚本是不是在PATH环境变量里。重点在于让shell能够识别这些函数，有以下两种方法： 在命令行上创建函数； 在.bashrc文件中定义函数。 对于简单的函数，可以在命令行上直接定义一个函数，因为shell会解释用户输入的命令。如果采用单行方式定义函数，必须在每个命令后面加个分号，这样shell就能知道在哪里是命令的起止了；如果采用多行方式定义函数，则不需要添加分号，只需要回车即可。如图所示：注意：在命令行上创建函数时，如果你给函数起了个跟内建命令或另一个命令相同的名字，函数将会覆盖原来的命令。 在命令行上创建函数不仅输入不便，而且最主要的问题是退出shell时函数就消失了。最简单的解决办法就是将函数定义在.bashrc文件中，bash shell在每次启动时都会在主目录下查找这个文件，不管是交互式shell还是从现有shell中启动的新shell。 直接定义函数，可以直接在主目录下的.bashrc文件中定义函数。许多Linux发行版已经在.bashrc文件中定义了一些东西，所以注意不要误删了，把你写的函数放在文件末尾就行了。 读取函数文件，只要是在shell脚本中，都可以用source命令（或者它的别名.操作符）将库文件中的函数添加到.bashrc脚本中。 shell还会将定义好的函数传给子shell进程，这样一来，这些函数就自动能够用于该shell会话中的任何shell脚本了。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hwame.top/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://hwame.top/tags/shell/"}]},{"title":"搭建Github图床并利用jsDelivr加速","slug":"github-pics-with-jsdelivr","date":"2020-11-25T03:13:37.000Z","updated":"2020-11-27T01:56:23.000Z","comments":true,"path":"20201125/github-pics-with-jsdelivr.html","link":"","permalink":"https://hwame.top/20201125/github-pics-with-jsdelivr.html","excerpt":"摘要：之前都是将博文图片直接放在images文件夹下，图片加载较慢，故搭建Github图床并利用jsDelivr加速（先看后记有惊喜）。","text":"摘要：之前都是将博文图片直接放在images文件夹下，图片加载较慢，故搭建Github图床并利用jsDelivr加速（先看后记有惊喜）。 文章说明文章作者：鴻塵文章链接：https://hwame.top/20201125/github-pics-with-jsdelivr.html 1.搭建Github图床1.1.新建仓库登陆Github账户，新建仓库【或直接点击https://github.com/new】，按如下设置后点击Create repository，如图所示： Repository name：仓库名称（英文），即图床名； Description：描述； Public/Private：选择公开； Add a README file：使用README.md初始化，可选。 1.2.上传图片仓库创建完成后，就已经可以直接使用了。可以直接在网页端点击Add file→Upload files即可上传文件/文件夹，如图所示： 也可以使用其他软件，如PicGo等【需要访问令牌，见下文】。 1.3.使用图片对于仓库中的文件（图片），有以下两种方式：说明：使用jsDelivr的CDN加速服务，它可以加速Github仓库的文件，免费且无需注册、无需额外配置，只需要一个正确的URL即可。12345# 直接引用![图片描述](https://raw.githubusercontent.com/username/repos/branch/path/xxx.png)# 使用CDN加速![图片描述](https://cdn.jsdelivr.net/gh/username/repos@version/path/xxx.png)以下是两种方式使用效果，感受一下加载速度的区别： https://raw.githubusercontent.com/hwame/pics/main/avatar.jpg https://cdn.jsdelivr.net/gh/hwame/pics@main/avatar.jpg 2.使用PicGo上传图片2.1.说明PicGo是一个用于快速上传图片并获取图片URL链接的开源工具，使用它可以解放写作双手、提高生产力。使用PicGo的原因仅仅是因为能够方便地将上传图片到Github，并直接获取jsDelivr的加速后的图片地址。 下载地址：https://github.com/Molunerfinn/PicGo/releases 说明：由于使用PicGo上传文件需要获取控制仓库的权限，因此需要访问令牌，如果不需要借助第三方工具上传，则无需此步骤，自行取舍（比如我还是喜欢自己动动手）。说明：由于我未使用第三方工具，此部分主要目的是解释一下token并不是必须的，内容参考如风蒹葭的文章使用 jsDelivr CDN 加速 Github 仓库的图片，以作为博客的图床。 2.2.生成令牌以此点击头像→Settings→Developer settings→Personal access tokens【或直接点击https://github.com/settings/tokens】，可以看到已有的访问令牌，但是口令只显示一次，所以不可复用，需要重新生成。点击Generate new token，可能需要输入密码，在 New personal access token中填写备注、勾选repo整个复选框，如图所示。 最后点击Generate token即可，将生成的token【图中打码处】复制保存，只显示一次，否则需要重新生成，如图所示。 2.3.PicGo配置下载安装好以后，配置「Github图床」： 设定仓库名：Github仓库，格式为username/repos，示例：hwame/pics。 设定分支名：Github仓库的分支，格式为branch，示例：main。 注意：由于众所周知的原因，Github新创建的仓库默认分支已不再是master而是main了！！ 设定Token：即上一步生成的访问令牌。 指定存储路径：可选。不填则为仓库根目录，建议按图片分类放在不同文件夹下。 设定自定义域名：此即jsDelivr的配置，格式为https://cdn.jsdelivr.net/gh/username/repos@branch，示例：https://cdn.jsdelivr.net/gh/hwame/pics@main gh：表示来自Github的内容； username：Github用户名； repos：Github仓库； branch：仓库分支，注意是master还是main。 2.4.PicGo使用PicGo配置完成后即可使用了，它支持拖拽、点击、剪贴板上传，上传后，图片链接直接复制的你的剪贴板中，极大地提高了生产效率。 3.图床迁移截至目前，博客使用的「图床」共有以下几种： 路过图床： 优点：免费且稳定，可创建多相册，图片可标记 缺点：需要额外使用邮箱注册账号，内容不易维护 阿里云服务器： 优点：对文件拥有绝对权限，可定制程度高，任何部分都可以随心所欲地配置（只要你有钞能力） 缺点：价格与网络带宽直接挂钩，有使用期限，服务器到期后文件迁移及博客内容更新耗时费力，最主要还是贵！ 直接引用Github图片： 直接引用只在「文章缩略图」作为图标引用的，例如Hexo Logo，图标文件一般较小，因此没必要放到图床上，不必迁移 直接放在「本地」，和博客文件放在一起： 优点：静态文件都在一个地方，管理较为方便 缺点：慢！ 基于以上因素，我决定将所有图片都放在Github图床上，并使用jsDelivr加速，迁移内容主要有： 文章图片； 相册图片； 最新文章缩略图； 目前看来体验还不错。最主要的是，Hexo博客的文件和图片文件都托管在Github上了，管理起来很方便，不用担心服务器挂掉或者到期，也不用担心其他图床失效，而且通过jsDelivr加速后图片资源加载速度有明显改善，网站浏览体验满分~ 4.后记写到这里其实可以发现，jsDelivr和图片在哪个仓库并没有什么关系！我们不必单独新建仓库，在./themes/pure/source/文件夹下的文件都会直接上传到hwame.github.io仓库的根目录，所以我们在./themes/pure/source/images/下的文件会同步到hwame/hwame.github.io/images/下，因此也可以直接利用jsDelivr加速！ 只需要将原来的图片地址/images/xxx.png对应修改为https://cdn.jsdelivr.net/gh/hwame/hwame.github.io@master/images/xxx.png即可，同一张图片【Github文件位置】的测试： https://hwame.top/images/avatar.jpg https://cdn.jsdelivr.net/gh/hwame/hwame.github.io@master/images/avatar.jpg 结论：所以没必要重新创建图床仓库，只需要更新一下文章的图片链接即可。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://hwame.top/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://hwame.top/tags/Hexo/"}]},{"title":"循环中的lambda函数产生的作用域及闭包问题","slug":"python-lambda-in-a-for-loop","date":"2020-10-20T08:45:08.000Z","updated":"2020-11-27T06:17:30.000Z","comments":true,"path":"20201020/python-lambda-in-a-for-loop.html","link":"","permalink":"https://hwame.top/20201020/python-lambda-in-a-for-loop.html","excerpt":"摘要：在Python循环中定义函数时涉及到的作用域和闭包等问题。","text":"摘要：在Python循环中定义函数时涉及到的作用域和闭包等问题。 文章说明文章作者：鴻塵参考内容： 为什么在具有不同值的循环中定义的lambdas都返回相同的结果？ Python经典的大坑问题：lambda和循环作用域问题 Python Lambda in a loop What do lambda function closures capture? 文章链接：https://hwame.top/20201020/python-lambda-in-a-for-loop.html 1.背景最近有同学问我一个使用scipy进行参数优化的问题，目标函数： f(x) = \\frac{a + x_1}{b + x_2} - c \\times x_3 + d \\times x_4由于涉及到较多的参数和约束条件，因此考虑使用for循环，程序主要代码如下： 123456789101112131415161718192021222324from scipy.optimize import minimizeimport numpy as npdef fun(args): # 目标函数及系数 a, b, c, d = args return lambda x: (a + x[0]) / (b + x[1]) - c * x[0] + d * x[2]def cons(): # 约束条件constraints，暂时略过 cons = [fun1, fun2, fun3, fun4, fun5, fun6] return consif __name__ == &quot;__main__&quot;: args = (2, 1, 3, 4) # 定义常量值a, b, c, d cons = cons() # 生成约束 x0 = np.asarray((0.5, 0.5, 0.5)) # 设置初始猜测值 # 开始优化 res = minimize(fun(args), x0, method=&#x27;SLSQP&#x27;, constraints=cons) print(res.fun) # 优化结果，即最优目标函数值 print(res.success) # 优化状态，即是否成功 print(res.x) # 优化结果，即x的最优解 对于约束函数的生成，由于每个 $x$ 分量都有一个上界和下界，范围为$[0.1, 0.9]$，所以约束条件会随分量的增多呈线性增长，因此写死是不现实的，考虑用for循环：12345678910111213141516171819# 直接把所有情况写死def cons(): cons = (&#123;&#x27;type&#x27;: &#x27;ineq&#x27;, &#x27;fun&#x27;: lambda x: x[0] - 0.1&#125;, &#123;&#x27;type&#x27;: &#x27;ineq&#x27;, &#x27;fun&#x27;: lambda x: -x[0] + 0.9&#125;, &#123;&#x27;type&#x27;: &#x27;ineq&#x27;, &#x27;fun&#x27;: lambda x: x[1] - 0.1&#125;, &#123;&#x27;type&#x27;: &#x27;ineq&#x27;, &#x27;fun&#x27;: lambda x: -x[1] + 0.9&#125;, &#123;&#x27;type&#x27;: &#x27;ineq&#x27;, &#x27;fun&#x27;: lambda x: x[2] - 0.1&#125;, &#123;&#x27;type&#x27;: &#x27;ineq&#x27;, &#x27;fun&#x27;: lambda x: -x[2] + 0.9&#125;) return cons# 借助for循环def cons(): cons = [] for i in range(3): b = &#123;&#x27;type&#x27;: &#x27;ineq&#x27;, &#x27;fun&#x27;: lambda x: x[i] - 0.1&#125; c = &#123;&#x27;type&#x27;: &#x27;ineq&#x27;, &#x27;fun&#x27;: lambda x: 0.9 - x[i]&#125; cons.append(b) cons.append(c) return cons 2.问题描述显然，使用循环的方式便于程序的拓展，而且也省时，但是会出一个问题：生成的cons约束函数只有最后一个生效，且所有函数都相同。 这个问题我曾经遇到过，第一反应就确定了问题出在循环上。尽管当时解决了却并没有完全弄懂它，以致于再次遇到还是一脸懵逼，因此查阅了详细的资料，在此记录下来。 3.原因分析3.1.问题引入 借助官方文档中一个简单的例子来说明。 12345678func = []for myx in range(4): func.append(lambda: myx**2)# 调用函数func[0](), func[1](), func[2](), func[3]()# 预期结果：(0, 1, 4, 9)# 实际结果：(9, 9, 9, 9) 3.2.原因解释来自官方文档的解释： 发生这种情况是因为myx不是lambdas的内部变量，而是在外部作用域中定义，并且在调用lambda时访问它——而不是在定义它时。当循环结束时，myx的值是3，所以所有的函数现在返回3**2，即9。你可以通过更改myx的值来验证这一点，即使退出了循环，列表中的函数仍然发生了变化且是所有并查看lambdas的结果如何变化:123myx = 8func[1]()# 输出：64，且func[0](), func[2](), func[3]()皆输出64 3.3.作用域和闭包来自Max Shawabkeh的解释，原文链接： Scoping in Python is dynamic and lexical. A closure will always remember the name and scope of the variable, not the object it’s pointing to. Since all the functions in your example are created in the same scope and use the same variable name, they always refer to the same variable. 翻译：Python的作用域是动态且词汇丰富的。闭包将始终记住变量的名称和范围，而不是其指向的对象。由于示例中的所有函数都是在同一作用域中创建的，并且使用相同的变量名称，因此它们始终引用相同的变量。 来自Claudiu的解释： Python has static scoping, not dynamic scoping.. it’s just all variables are references, so when you set a variable to a new object, the variable itself (the reference) has the same location, but it points to something else. 翻译：Python具有静态作用域，而不是动态作用域。它只是所有变量都是引用，因此当您将变量设置为新对象时，变量本身（引用）具有相同的位置，但指向其他对象。 来自欢喜明的解释，原文链接： 函数在定义的时候，并没有分配内存空间用来保存任何变量的值，只有在执行的时候才会分配空间保存变量的值。 Python的作用域由def、class、lambda等语句产生，而if、try、for等语句并不会产生新的作用域。 Python变量名引用的查找顺序为： ①本地作用域（Local）； ②外围作用域，即当前作用域是一个内嵌作用域（Enclosing Locals）； ③全局/模块作用域（Global），即模块内的作用域，其作用范围是单一文件内； ④内置作用域（Built-in）。 来自千山飞雪的解释，原文链接： 在一个内部函数中，对外部作用域的变量进行引用，(并且一般外部函数的返回值为内部函数)，那么内部函数就被认为是闭包。 闭包无法修改外部函数的局部变量；python循环中不包含域的概念。 来自Walter Mundt的解释，原文链接： The corollary is that the outer function can change i but the inner function cannot (since that would make i a local instead of a closure based on Python’s syntactic rules). 翻译：结论是外部函数可以更改i，而内部函数则不能（因为这将使i成为局部变量，而不是基于Python语法规则的闭包）。 3.4.解决方案 以上文所举的一个简单的例子来说明。1234# 一个简单的例子func = []for myx in range(4): func.append(lambda: myx**2) 方案一：带默认值的参数①使用具有默认值的参数来强制捕获变量，即官方文档所谓之「将值保存在lambdas的局部变量中」：123func = []for myx in range(4): func.append(lambda tmp=myx: tmp**2)②上述方法①等价的写法：12345func = []for myx in range(4): def myfunc(tmp=myx): return tmp**2 func.append(myfunc) 方案二：使内部函数成为闭包①创建一个外部函数包裹内部函数，使内部函数成为闭包，1234567func = []for myx in range(4): def makefunc(myx): def myfunc(): return myx**2 return myfunc func.append(makefunc(myx))②上述方法①可以简化为使用单个的makefunc()函数：12345678def makefunc(myx): def myfunc(): return myx**2 return myfuncfunc = []for myx in range(4): func.append(makefunc(myx))③当内部函数较为简单时，可以使用lambda简化代码：123456def makefunc(param): return lambda: param**2func = []for myx in range(4): func.append(makefunc(myx))④同样，可以使用嵌套的lambda函数简化上述方法①的代码，这可能看起来不太直观：123func = []for myx in range(4): func.append((lambda myx: lambda: myx**2)(myx)) 方案三：使用标准库函数partialPython的functools模块提供了「偏函数partial」，其返回一个新的「partial对象」（参考这里），它会被「冻结了」一部分函数参数和/或关键字的部分函数应用所使用，从而得到一个具有简化签名的新对象。官方文档如图所示： 其他参考资料： 廖雪峰的官方网站之偏函数； 极客学院之Python的partial函数； 菜鸟教程之Python偏函数； 方案三代码：1234from functools import partialfunc = []for myx in range(4): func.append(partial(lambda param: param**2, myx)) Georgy认为，lambda可以使用functools.partial来代替，这是一种语法更简单的方法。以下是一个便于理解的例子，原文链接：1234567891011121314nums = [1, 2, 3]lambdas = [lambda: print(i) for i in nums]binding = [lambda i=i: print(i) for i in nums]partials = [partial(print, i) for i in nums]for function in lambdas: function() # 输出：3 3 3for function in binding: function() # 输出：1 2 3for function in partials: function() # 输出：1 2 3 3.5.说明 上述各例中的函数调用时是不需要传参的，这对于需要传参的函数没什么区别。 本文以循环中的lambda函数引入作用域及闭包问题，但需注意的是这种行为并不是lambda所特有的，也适用于常规函数。 上述各种方案运行结果如下： 方案名 描述 运行结果 方案一① 带默认值的参数，使用lambda 方案一② 带默认值的参数，不使用lambda 方案二① 使内部函数成为闭包，函数置于循环中 方案二② 使内部函数成为闭包，使用单个的makefunc()函数 方案二③ 使内部函数成为闭包，使用lambda的单个函数 方案二④ 使内部函数成为闭包，使用嵌套的lambda的函数 方案三 使用标准库函数functools.partial 4.实际问题的解决办法至此，解决方案很简单了，只需要绑定外部变量到lambda函数中即可，就像在函数中设置默认值一样def myfunc(x, tmp=i)：12345678def cons(): cons = [] for i in range(3): b = &#123;&#x27;type&#x27;: &#x27;ineq&#x27;, &#x27;fun&#x27;: lambda x, tmp=i: x[tmp] - 0.1&#125; c = &#123;&#x27;type&#x27;: &#x27;ineq&#x27;, &#x27;fun&#x27;: lambda x, tmp=i: 0.9 - x[tmp]&#125; cons.append(b) cons.append(c) return cons当然，也可以使用上文提到的另外的方法。","categories":[{"name":"python","slug":"python","permalink":"https://hwame.top/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://hwame.top/tags/python/"}]},{"title":"如何将matplotlib图像渲染到前端","slug":"render-matplotlib-figure-to-flaskweb","date":"2020-10-08T01:06:32.000Z","updated":"2020-10-08T07:26:44.000Z","comments":true,"path":"20201008/render-matplotlib-figure-to-flaskweb.html","link":"","permalink":"https://hwame.top/20201008/render-matplotlib-figure-to-flaskweb.html","excerpt":"摘要：matplotlib结合seaborn二维绘图功能强大，可以绘制eCharts画不出的图像，因此考虑直接将matplotlib图像渲染到前端。","text":"摘要：matplotlib结合seaborn二维绘图功能强大，可以绘制eCharts画不出的图像，因此考虑直接将matplotlib图像渲染到前端。 文章说明文章说明：前端绘图一般是用百度eCharts，但其样式不够丰富且可定制化程度不高，有时无法满足需求，因此直接将python的matplotlib数据可视化渲染到前端。另请参考：python将matplotlib输出到web另请参考：如何将Matplotlib图像展示在web页面上另请参考：Mac使用matplotlib.pyplot画图出现中文乱码文章作者：鴻塵文章链接：https://hwame.top/20201008/render-matplotlib-figure-to-flaskweb.html 一、背景前端页面的数据可视化一般是用百度eCharts，但其样式不够丰富且可定制化程度不高，有时无法满足需求。最近需要在前端展示相关图（Correlogram），python中可以使用matplotlib结合seaborn轻松实现，但eCharts实例中没有类似的样例，因此考虑直接将matplotlib图像渲染到前端。 二、思路1.保存图片到服务器static目录将画好的图片保存在服务器的static目录下，前端再从该目录读取图片进行展示。这种思路很直接，是最容易想到的，但是存在以下问题： 无法判断响应时间。因为图像生成是通过前端用户传递一系列参数，再根据这些参数计算相应的数据，利用计算的数据进行可视化，因此后端生成图片的时间未知，所以只能采用在前端延时展示。 前端访问static目录不方便。前端VUE＋后端Flask的前后端分离的项目中，前端访问static目录不方便。 占用服务器内存和带宽。将图片保存在服务器，前端从服务器获取资源时会占用一部分网络带宽，影响到前端资源加载的速度，并且图片累积将会占用服务器内存。 2.使用请求的方式将图像传到前端将图像以请求的方式传到前端，前端只需将&lt;img&gt;标签的src属性赋值为后端的请求路径即可。该方法可以在后端生成完图像后再发送给前端，无需设置延时获取图像。拟采用该方法。 3.将图像以Base64格式发送给前端这种思路和思路2类似，但是区别在于调用savefig方法时不存储为图像，而是存储为二进制格式，二进制格式再转化为Base64字符串格式，并将其发送给前端，前端只需要将&lt;img&gt;标签的src属性赋值为该字符串即可。 三、代码实现对比三种方法，显然思路3为最优解： 在后端生成完图像后再发送给前端，无需设置延时获取图像； 只需要往前端发送一次请求，代码更加精简； 调用了 savefig 方法，可以去除白边。 接口使用python的flask框架，代码如下：123456789101112131415161718192021222324import matplotlibmatplotlib.use(&#x27;Agg&#x27;) # 不出现画图的框import matplotlib.pyplot as pltfrom io import BytesIOimport base64import seaborn as sns@app.route(&#x27;/correlation&#x27;)def correlation(): data = df.corr() # 开始画图 plt.figure(figsize=(12, 10), dpi=80) sns.heatmap(data, xticklabels=data.columns, yticklabels=data.columns, cmap=&#x27;RdYlGn&#x27;, center=0, annot=True) plt.title(&#x27;Correlogram&#x27;, fontsize=22) plt.xticks(fontsize=12) plt.yticks(fontsize=12) # plt.show() # 转成图片的步骤 sio = BytesIO() plt.savefig(sio, format=&#x27;png&#x27;, bbox_inches=&#x27;tight&#x27;, pad_inches=0.0) data = base64.encodebytes(sio.getvalue()).decode() src = &quot;data:image/png;base64,&#123;&#125;&quot;.format(data) plt.close() # 记得关闭，不然画出来的图是重复的 return src 四、效果预览前端通过请求获取该src后，只需将其赋值给&lt;img&gt;标签的src属性即可：1&lt;img src=&#123;&#123;src&#125;&#125;&gt;预览图如下： 五、部署问题1.无GUI图形界面服务器是不带GUI界面的CentOS 7，但是matplotlib.pyplot是需要tkinter库的支持的：_tkinter.TclError: no display name and no $DISPLAY environment variable。然而，我们并不需要安装tkinter、tcl-devel和tk-devel等，因为我们并不是需要在Linux上看到画出的图，只需要改一下后端agg即可【貌似Linux下默认后端已是Agg，从配置文件可以看到】，代码如下：1234import matplotlib as mplmpl.use(&#x27;Agg&#x27;)# 在from matplotlib import pylot之前添加mpl.use(&#x27;Agg&#x27;)from matplotlib import pylot 2.中文字体乱码原因分析由于matplotlib没有中文字体，直接会报错：RuntimeWarning: Glyph xxxxx missing from current font.，网上有说需要添加两行代码（在缺少字体文件的情况下，这种方法无效），即：12345plt.rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;SimHei&#x27;]#设置字体，设置了字体后，负号会变成乱码plt.rcParams[&#x27;axes.unicode_minus&#x27;] = False#让负号的乱码正常显示 因为没有黑体这个字体，所以仍会报错，因此需要手动下载对应字体。并将其复制到对应位置：./python3.6/site-packages/matplotlib/mpl-data/fonts/ttf/。 修改配置文件解决字体缺失的问题后，还需要修改配置文件matplotlibrc，文件位置：./python3.6/site-packages/matplotlib/mpl-data/matplotlibrc。直接修改配置文件的好处是，不需要每次都在程序代码中添加诸如plt.rcParams[&#39;font.sans-serif&#39;] = [&#39;SimHei&#39;]的配置项。 将#font.family : sans-serif修改为font.family : sans-serif（去掉注释） 将#font.sans-serif : DejaVu Serif, ...修改为font.sans-serif : SimHei, DejaVu Serif, ...（去掉注释，添加SimHei） 将#axes.unicode_minus : True修改为axes.unicode_minus : False（去掉注释，属性设置为False） 说明：黑体SimHei也可以改为其他字体，最接近宋体和Times New Roman的是STSong，参考如何使matplotlib同时使用宋体和Times New Roman。 删除matplotlib缓存Linux上的matplotlib缓存文件位于用户家目录下的”~/.cache/matplotlib/“，可以看到其下包含了缓存文件fontlist-v310.json及缓存文件夹tex.cache。若不删除缓存，可能看不到配置生效。1rm -rf ~/.cache/matplotlib/ 3.其他任何人都没法保证自己写的代码没有bug，而且测试时也不可能考虑到所有的情况。一旦程序部署上线作为服务运行，出现问题用户也只能看到50x的错误，因此要养成善于查看日志的习惯！从日志入手，才能分析问题出现的原因，从而能打补丁、修bug、改代码，使程序更健壮、服务更稳定。","categories":[{"name":"python","slug":"python","permalink":"https://hwame.top/categories/python/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://hwame.top/tags/Linux/"},{"name":"matplotlib","slug":"matplotlib","permalink":"https://hwame.top/tags/matplotlib/"},{"name":"python","slug":"python","permalink":"https://hwame.top/tags/python/"}]},{"title":"力扣简洁优雅的python解法","slug":"shortest-leetcode-python-solutions","date":"2020-06-04T13:32:55.000Z","updated":"2020-06-05T03:42:18.000Z","comments":true,"path":"20200604/shortest-leetcode-python-solutions.html","link":"","permalink":"https://hwame.top/20200604/shortest-leetcode-python-solutions.html","excerpt":"摘要：Python语言特点之一就是优雅简洁，为方便学习数据结构，搬运自Github【项目地址】上汇总LeetCode最短最优雅的解法的项目。","text":"摘要：Python语言特点之一就是优雅简洁，为方便学习数据结构，搬运自Github【项目地址】上汇总LeetCode最短最优雅的解法的项目。 文章说明文章来源：Shortest-LeetCode-Python-Solutions文章作者：Knife丶原文链接：https://github.com/cy69855522/Shortest-LeetCode-Python-Solutions文章说明：方便学习数据结构，搬运自Github 前言 Leet Code 刷题笔记 - - 不求最快最省，但求最短最优雅 :herb:，Shorter is better here. 代码精炼是 Python 的核心，同时能够反应对于语言的熟练程度，本项目目的在于汇总 leet code 最短最优雅的解法，拒绝长篇大论，缩短学习周期，掌握各种技巧，助您在面试中写出令人眼前一亮的解答，给考官留个好印象。 为什么我们追求最短? 1.短代码更pythonic，而且通常能够避免一些冗余过程。 2.除了刷题掌握算法思路之外，我们更追求深入理解和掌握python,学会套用技巧，举一反三。 3.真正面试的时候不一定要这么短，可以适当展开几行(O_o 除非你就是想秀其他人一脸 😅)，保证思路更清晰，相信就算展开几行也会比其他题解短很多吧。 4.刷题很累，找点乐子，送给自己一些成就感吧。 5.所有已收录代码都是优中选优，题库解析部分除了短代码外，也有常规解法作为补充。 6.若基础知识不够扎实，可以先看专题探索部分，然后再转题库解析学习 Python 中隐藏的先进技巧。 项目持续更新中，优先使用 python3，不支持的题目使用 python2 代替，如果您有更短更优雅的解法希望分享的话欢迎联系更新~ [直接发issue 或 fork，记得留下署名和联系方式~~] 鉴于追求的主题，此项目收录 1.在代码量(不是行数)上明显优于现有解的最短代码 2.思路更高效的一般解法（作为补充放在首选解之后） [题目自带的代码不计入代码量] 如果您对当前解析有任何疑问，咱们 issue 见~ 由于CSDN博客更新需要人工审核比较慢，所以迁移到github上，优先更新github内容。 为了快速找到题目可以按 [Ctrl键 + F键] 输入题目序号或名字定位。 欢迎加入QQ交流群：902025048 ∷二维码 群内提供更多相关资料~里程碑 腾讯精选练习（50题: 25简单 21中等 4困难） 代码行数 总计：140行 平均：2.8行 【2019/05/05】 🧬 数据结构 🐤 队列 &amp; 栈（5 章节 32 栏目） 高可读，不含VIP解锁题 题目详情 2019/05/31 🐑 数组和字符串（5 章节 29 栏目） 高可读 题目详情 2019/06/15 🦌 链表（5 章节 26 栏目） 高可读 题目详情 2019/06/25 🦎 哈希表（5 章节 35 栏目） 高可读，不含VIP解锁题 题目详情 2019/07/07 🐄 二分查找（8 章节 30 栏目） 高可读，不含VIP解锁题 题目详情 2019/07/30 🦉 二叉树（3 章节 16 栏目） 高可读 题目详情 2019/09/21 🐦 二叉搜索树（3 章节 16 栏目） 高可读 题目详情 2019/11/15 🐈 N叉树（3 章节 7 栏目） 高可读，不含VIP解锁题 题目详情 2019/11/17 ⏱ 递归 I（5 章节 28 栏目） 高可读 题目详情 2019/11/28 推荐 👻 Leetcode最简C++题解 🎃 C++清晰题解汇总 🚀 AI Power 云GPU租借/出租平台：Python是AI的核心，GPU是AI的动力，想要朝AI工程师发展的朋友不妨了解一下~ 现在注册并绑定（参考Github）即可获得高额算力，注册不涉及个人隐私信息，奖励可随时提现。详情请参考AI Power指南 🌟 推荐刷题路线：专题探索 → 腾讯精选50题 → 题库解析题库解析此专栏追求代码的精简和技巧性，默认已看过题目，🤡 没看过的话点标题可以跳转链接，咱们一起体验炫酷的 Python1. Two Sum 4行123456class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: d = &#123;&#125; for i, n in enumerate(nums): if n in d: return [d[n], i] d[target-n] = i $O(N)$时间效率的快速解法，用字典记录 ｛需要的值:当前索引｝2. Add Two Numbers 5行12345678910111213# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode, carry=0) -&gt; ListNode: if not (l1 or l2): return ListNode(1) if carry else None l1, l2 = l1 or ListNode(0), l2 or ListNode(0) val = l1.val + l2.val + carry l1.val, l1.next = val % 10, self.addTwoNumbers(l1.next, l2.next, val &gt; 9) return l1 int(True) 等于 1 None or 7 等于 7 用 carry 记录是否应该进位3. Longest Substring Without Repeating Characters 3行12345class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: i, r, d = 0, 0, &#123;&#125; for j, c in enumerate(s): i, r, d[c] = max(i, d.get(c, -1) + 1), max(r, j - i), j return max(r, len(s) - i) 双指针滑动窗口 i 代表起始位置，r 记录最优解，d 是一个字典，记录所有字符最后出现的位置 每次迭代过程中，遇到遇见过的字符时，i 就会变为那个字符上一次出现位置 + 1，r 记录上一次应该达到的全局最大值，所以最后需要再比较一次4. Median of Two Sorted Arrays 5行1234567class Solution: def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float: a, b, m = *sorted((nums1, nums2), key=len), (len(nums1) + len(nums2) - 1) // 2 self.__class__.__getitem__ = lambda self, i: m-i-1 &lt; 0 or a[i] &gt;= b[m-i-1] i = bisect.bisect_left(self, True, 0, len(a)) r = sorted(a[i:i+2] + b[m-i:m-i+2]) return (r[0] + r[1 - (len(a) + len(b)) % 2]) / 2 本题思路与官方题解类似，时间复杂度$O(\\log(\\min(m, n)))$，没看过的话建议先大体了解一下 python 中 bisect 模块针对的是 list, 如果直接构造 list，时间复杂度为 $O(\\min(m, n))$，因此我们修改当前类的魔法方法伪造 list 在一个有序递增数列中，中位数左边的那部分的最大值一定小于或等于右边部分的最小值 如果总数组长度为奇数，m 代表中位数的索引，否则 m 代表用于计算中位数的那两个数字的左边一个。比如输入为[1,2]，[3]，那么m应该为[1,2,3]中位数2的索引1，如果输入为[1,3]，[2,4]，那么m应该为[1,2,3,4]中2的索引1 使用二分搜索找到 m 对应的值在a或b中对应的索引，也就是说，我们要找的中位数或中位数左部应该是 a[i] 或者 b[m-i] bisect.bisect_left 搜索列表中保持列表升序的情况下，True应该插入的位置（从左侧），比如 [F,F,T] 返回 2，[F,F] 返回 2 这里保证 a 是 nums1 和 nums2 中较短的那个，是为了防止二分搜索的时候索引越界 sorted返回一个list，假设返回值是 [nums1, nums2]，那么前面加个 * 号就代表取出列表的所有内容，相当于一个迭代器，结果相当于直接写 nums1, nums25. Longest Palindromic Substring 5行1234567class Solution: def longestPalindrome(self, s: str) -&gt; str: r = &#x27;&#x27; for i, j in [(i, j) for i in range(len(s)) for j in (0, 1)]: while i &gt; -1 and i + j &lt; len(s) and s[i] == s[i + j]: i, j = i - 1, j + 2 r = max(r, s[i + 1:i + j], key=len) return &#x27;&#x27; if not s else r 遍历字符串的每个索引 i，判断能否以 s[i] 或 s[i:i+j+1] 为中心向往拓展回文字符串7. Reverse Integer 2行 1234class Solution: def reverse(self, x): r = x // max(1, abs(x)) * int(str(abs(x))[::-1]) return r if r.bit_length() &lt; 32 or r == -2**31 else 0 x // max(1, abs(x))意味着 0：x为0， 1：x为正， -1：x为负，相当于被废弃的函数cmp [::-1]代表序列反转 $2^{31}$ 和 $-2^{31}$ 的比特数为32，其中正负号占用了一位 32位整数范围 $[−2^{31}, \\; 2^{31} − 1]$ 中正数范围小一个是因为0的存在8. String to Integer (atoi) 1行123class Solution: def myAtoi(self, s: str) -&gt; int: return max(min(int(*re.findall(&#x27;^[\\+\\-]?\\d+&#x27;, s.lstrip())), 2**31 - 1), -2**31) 使用正则表达式 ^：匹配字符串开头，[\\+\\-]：代表一个+字符或-字符，?：前面一个字符可有可无，\\d：一个数字，+：前面一个字符的一个或多个，\\D：一个非数字字符 max(min(数字, 2**31 - 1), -2**31) 用来防止结果越界9. Palindrome Number 1行 123class Solution: def isPalindrome(self, x: int) -&gt; bool: return str(x) == str(x)[::-1] 不使用字符串的进阶解法： 1234class Solution: def isPalindrome(self, x: int) -&gt; bool: r = list(map(lambda i: int(10**-i * x % 10), range(int(math.log10(x)), -1, -1))) if x &gt; 0 else [0, x] return r == r[::-1] 思路是一样的，这里把整数转成了列表而不是字符串 比如一个整数$12321$，我想取出百位数可以这么做：$12321 * 10^{\\text{int}(\\log_{10}12321)} % 10 = 123 % 10 = 3$11. Container With Most Water 3行12345class Solution: def maxArea(self, height: List[int]) -&gt; int: res, l, r = 0, 0, len(height) - 1 while l &lt; r: res, l, r = (max(res, height[l] * (r - l)), l + 1, r) if height[l] &lt; height[r] else (max(res, height[r] * (r - l)), l, r - 1) return res 双指针 $O(N)$ 解法 res：结果，l：容器左壁索引，r：容器右壁索引 如果 height[l] &lt; height[r] 那么 l += 1 否则 r -= 1，说明：如果 height[0] &lt; height[3] 那么(0, 1), (0, 2)对应的容器体积一定小于(0, 3)的，因为此时计算体积的时候高为 height(0)，容器的宽减少而高不增加，面积必然缩小13. Roman to Integer 2行 1234class Solution: def romanToInt(self, s: str) -&gt; int: d = &#123;&#x27;I&#x27;:1, &#x27;IV&#x27;:3, &#x27;V&#x27;:5, &#x27;IX&#x27;:8, &#x27;X&#x27;:10, &#x27;XL&#x27;:30, &#x27;L&#x27;:50, &#x27;XC&#x27;:80, &#x27;C&#x27;:100, &#x27;CD&#x27;:300, &#x27;D&#x27;:500, &#x27;CM&#x27;:800, &#x27;M&#x27;:1000&#125; return sum(d.get(s[max(i-1, 0):i+1], d[n]) for i, n in enumerate(s)) 构建一个字典记录所有罗马数字子串，注意长度为2的子串记录的值是（实际值-子串内左边罗马数字代表的数值） 这样一来，遍历整个s的时候判断当前位置和前一个位置的两个字符组成的字符串是否在字典内，如果在就记录值，不在就说明当前位置不存在小数字在前面的情况，直接记录当前位置字符对应值 举个例子，遍历经过IV的时候先记录I的对应值1再往前移动一步记录IV的值3，加起来正好是IV的真实值4。max函数在这里是为了防止遍历第一个字符的时候出现[-1:0]的情况14. Longest Common Prefix 2行 1234class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: r = [len(set(c)) == 1 for c in zip(*strs)] + [0] return strs[0][:r.index(0)] if strs else &#x27;&#x27; 利用好zip和set os 模块有提供一样的函数 123class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: return os.path.commonprefix(strs) 15. 3Sum 5行1234567class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: nums, r = sorted(nums), set() for i in [i for i in range(len(nums)-2) if i &lt; 1 or nums[i] &gt; nums[i-1]]: d = &#123;-nums[i]-n: j for j, n in enumerate(nums[i + 1:])&#125; r.update([(nums[i], n, -nums[i]-n) for j, n in enumerate(nums[i+1:]) if n in d and d[n] &gt; j]) return list(map(list, r)) 时间复杂度：$O(N^2)$ 这里 sort 一是为了避免重复，这一点可以体现在我们输出的结果都是升序的，如果不这么做 set 无法排除一些相同结果，而是为了节省计算，防止超时 for 循环内部的代码思想同第一题 Two Sum，用字典记录｛需要的值:当前索引｝，如果字典中存在相同的数字，那么将会记录比较大的那个索引，因此可以用d[n] &gt; i来避免一个元素重复选择 (nums[i], n, -nums[i]-n)保证了列表升序16. 3Sum Closest 7行123456789class Solution: def threeSumClosest(self, nums: List[int], target: int) -&gt; int: nums, r, end = sorted(nums), float(&#x27;inf&#x27;), len(nums) - 1 for c in range(len(nums) - 2): i, j = max(c + 1, bisect.bisect_left(nums, target - nums[end] - nums[c], c + 1, end) - 1), end while r != target and i &lt; j: s = nums[c] + nums[i] + nums[j] r, i, j = min(r, s, key=lambda x: abs(x - target)), i + (s &lt; target), j - (s &gt; target) return r float(&#39;inf&#39;) = ＋∞(正无穷) 排序，遍历，双指针，$O(N^2)$ 时间复杂度，二分法初始化 排序是为了使用双指针，首先遍历得到索引 c，然后计算 c，左指针 i，右指针 j 对应数字之和，如果大于 target，j 向内移动，否则 i 向内移动 i 的初始值不是 c + 1，是为了减少计算量，用二分法得到一个合理的初始值17. Letter Combinations of a Phone Number 3行12345class Solution: def letterCombinations(self, digits: str) -&gt; List[str]: from itertools import product l = &#x27;- - abc def ghi jkl mno pqrs tuv wxyz&#x27;.split() return [&#x27;&#x27;.join(c) for c in product(*[l[int(i)] for i in digits])] if digits else [] 本题相当于求解笛卡尔积18. 4Sum 5行1234567class Solution: def fourSum(self, nums: List[int], target: int) -&gt; List[List[int]]: from itertools import combinations as com dic, l = collections.defaultdict(list), [*com(range(len(nums)), 2)] for a, b in l: dic[target - nums[a] - nums[b]].append((a, b)) r = [(*ab, c, d) for c, d in l for ab in dic[nums[c] + nums[d]]] return [*set(tuple(sorted(nums[i] for i in t)) for t in r if len(set(t)) == 4)] 思想类似于 2SUM，先得到任意两个数字的和记入字典，然后再获得其余任意俩个数字，看看是否匹配。2个 2SUM 相当于 4SUM。时间复杂度为 $O(N^2)$ 1.用 combination 获得 nums 中任意两个不同索引的组合 2.用字典记录任意两个数字的和，dic =｛除了这两个数字之外还差多少：这俩个数字在 nums 中的索引｝ 3.用 r 记录所有满足条件的索引序列，注意此时可能含有重复的索引 4.利用 len + set 保证 a，b，c，d 各不相等，用 set 删除重复的结果19. Remove Nth Node From End of List 5行12345678910111213# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode: l = [] while head: l, head = l + [head], head.next if n != len(l): l[-n-1].next = l[-n].next del l[-n] return l and l[0] 列表记录整个链表，换成队列记录最后几个可以把空间复杂度压到 $O(1)$20. Valid Parentheses 2行 1234class Solution: def isValid(self, s: str) -&gt; bool: while any((&#x27;()&#x27; in s, &#x27;[]&#x27; in s, &#x27;&#123;&#125;&#x27; in s)): s = s.replace(&#x27;()&#x27;, &#x27;&#x27;).replace(&#x27;[]&#x27;, &#x27;&#x27;).replace(&#x27;&#123;&#125;&#x27;, &#x27;&#x27;) return not s 不断删除有效括号直到不能删除，思路简单效率低。另外，stack的方法也很简单，而且快多了。 123456789class Solution: def isValid(self, s: str) -&gt; bool: stack, d = [], &#123;&#x27;&#123;&#x27;: &#x27;&#125;&#x27;, &#x27;[&#x27;: &#x27;]&#x27;, &#x27;(&#x27;: &#x27;)&#x27;&#125; for p in s: if p in &#x27;&#123;[(&#x27;: stack += [p]; elif not (stack and d[stack.pop()] == p): return False return not stack 21. Merge Two Sorted Lists 4行123456789101112# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode: if l1 and l2: if l1.val &gt; l2.val: l1, l2 = l2, l1 l1.next = self.mergeTwoLists(l1.next, l2) return l1 or l2 7 or 9 等于 7 None and 7 等于 None23. Merge k Sorted Lists 4行123456789101112# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode: r, n, p = [], lists and lists.pop(), None while lists or n: r[len(r):], n = ([n], n.next or lists and lists.pop()) if n else ([], lists.pop()) for n in sorted(r, key=lambda x: x.val, reverse=True): n.next, p = p, n return n if r else [] 本题思路： 把题目给的所有链表中的所有节点放进一个列表 r。 对这个列表 r 中的所有节点进行从大到小的排序。$O(N\\log N)$ 把每个节点的指针指向前一个节点。（第一个节点，也就是最大的那个，指向None。） 返回最后一个节点，也就是整个新链表的开头。 如何把所有节点放进 r(result link)？ 我们首先初始化 r 为空列表，初始化 n(node) 为题目所给的第一个链表的开头节点，并删除lists中的这个节点，接着进入while循环，如果 n 不为空，那么 r += [n]，这里使用了切片的技巧（r[len(r):]=[n]相当于r=r+[n]），n=n.next，如果n是第一个链表的最后一个节点的话n.next就是None，下一次while的时候如果lists不为空就说明还有别的链表，此时n为None，我们让 r 不变，n=lists.pop()，也就是从lists中再取下一个节点赋值给n，重复以上步骤直到 lists 为空，我们就把所有节点放进 r 了。 怎么对 r 排序？ 用了sorted函数，其中key定义了排序时用来比较的是每个元素的val属性，同时设置reverse为True代表降序排序。 如何修改每个节点的指针？ 我们初始化 p(previous node) 为None。遍历降序排好的列表 r，r中的第一个元素就是值最大的元素，也就是我们应该返回的链表的结尾，我们设置它指向None，然后让p=这个节点，继续for循环。之后每经过一个节点 n 就把这个节点的next属性设置为上一个节点 p，遍历完成之后的 n，也就是我们遍历经过的最后一个元素，拥有最小的值，自然就是整个新链表的起始节点，我们将其作为输出值，函数返回。 24. Swap Nodes in Pairs 3行1234567891011# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def swapPairs(self, head: ListNode) -&gt; ListNode: if head and head.next: head.next.next, head.next, head = head, self.swapPairs(head.next.next), head.next return head 每次递归交换两个节点，并返回新头参与上次递归 多值交换参考这里26. Remove Duplicates from Sorted Array 3行 12345class Solution: def removeDuplicates(self, nums: List[int]) -&gt; int: for i in range(len(nums)-1, 0, -1): if nums[i] == nums[i-1]: nums.pop(i) return len(nums) 时间效率$O(N^2)$, pop操作的平均时间复杂度为$O(N)$, 空间效率$O(1)$，逆遍历可以防止删除某个元素后影响下一步索引的定位 每次删除数组元素会引发大量的数据迁移操作，使用以下算法解题效率更高 12345678class Solution: def removeDuplicates(self, nums: List[int]) -&gt; int: i = 0 for j in range(1, len(nums)): if nums[j] != nums[i]: nums[i + 1] = nums[j] i += 1 return i + 1 if nums else 0 此解法思路同官方题解 数组完成排序后，我们可以放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。只要 nums[i] = nums[j]，我们就增加 j 以跳过重复项。当我们遇到 nums[j] != nums[i]时，跳过重复项的运行已经结束，因此我们必须把它（nums[j]）的值复制到 nums[i + 1]。然后递增 i，接着我们将再次重复相同的过程，直到 j 到达数组的末尾为止28. Implement strStr() 1行 123class Solution: def strStr(self, haystack: str, needle: str) -&gt; int: return haystack.find(needle) 不用内置函数也可以 123456class Solution: def strStr(self, haystack: &#x27;str&#x27;, needle: &#x27;str&#x27;) -&gt; &#x27;int&#x27;: for i in range(0, len(haystack) - len(needle) + 1): if haystack[i:i+len(needle)] == needle: return i return -1 29. Divide Two Integers 5行1234567class Solution: def divide(self, dividend: int, divisor: int) -&gt; int: a, b, r, t = abs(dividend), abs(divisor), 0, 1 while a &gt;= b or t &gt; 1: if a &gt;= b: r += t; a -= b; t += t; b += b else: t &gt;&gt;= 1; b &gt;&gt;= 1 return min((-r, r)[dividend ^ divisor &gt;= 0], (1 &lt;&lt; 31) - 1) 让被除数不断减去除数，直到不够减。每次减完后除数翻倍，并记录当前为初始除数的几倍（用 t 表示倍数 time），若发现不够减且 t 不为 1 则让除数变为原来的一半， t 也减半 a 为被除数绝对值，b 为除数绝对值，r 表示 result，t 表示当前除数对于原始除数的倍数 a &lt;&lt; b 相当于 a * 2**b，a &gt;&gt; b 相当于 a // 2**b 异或操作 ^ 可以判断俩数字是否异号33. Search in Rotated Sorted Array 3行12345class Solution: def search(self, nums, target): self.__class__.__getitem__ = lambda self, m: not(target &lt; nums[0] &lt;= nums[m] or nums[0] &lt;= nums[m] &lt; target or nums[m] &lt; target &lt;= nums[-1]) i = bisect.bisect_left(self, True, 0, len(nums)) return i if target in nums[i:i+1] else -1 作出数列的函数图像，可以看作是一个含断点的局部递增函数，形如:zap:，前面一段总是比较高 python 中 bisect 模块针对的是 list, 如果直接构造 list，相当于遍历所有元素，时间复杂度为 $O(N)$ 而不是 $O(logN)$，因此我们修改当前类的魔法方法伪造 list，然后用当前类代替list 用二分搜索时，m 代表 middle，low 代表 low，hi 代表 high，当满足任一条件｛① targe &lt; middle 且 middle 在前一段上 且 target &lt; nums[0] ② target &gt; middle 且 middle 在第一段上 ③ target &gt; middle 且 middle 在第二段上 且 target &lt;= nums[-1]｝时，应该向右搜索，因此 getitem 返回 False。 另外还有一种简单的思路：二分法找到断点的位置恢复原始数组，然后正常二分法即可 1234567891011121314151617class Solution: def search(self, nums, target): lo, hi, k = 0, len(nums) - 1, -1 while lo &lt;= hi: m = (lo + hi) // 2 if m == len(nums) - 1 or nums[m] &gt; nums[m+1]: k = m + 1 break elif m == 0 or nums[m] &lt; nums[m-1]: k = m break if nums[m] &gt; nums[0]: lo = m + 1 else: hi = m - 1 i = (bisect.bisect_left(nums[k:] + nums[:k], target) + k) % max(len(nums), 1) return i if nums and nums[i] == target else -1 34. 在排序数组中查找元素的第一个和最后一个位置 用自带的bisect函数，一行 12345class Solution: def searchRange(self, nums: List[int], target: int) -&gt; List[int]: # if not nums or target not in nums: return [-1, -1] return [bisect.bisect_left(nums, target), bisect.bisect_right(nums, target)-1] \\ if nums and target in nums else [-1, -1] 35. Search Insert Position 1行123class Solution: def searchInsert(self, nums: List[int], target: int) -&gt; int: return bisect.bisect_left(nums, target, 0, len(nums)) 36. Valid Sudoku 4行123456class Solution: def isValidSudoku(self, board: List[List[str]]) -&gt; bool: row = [[x for x in y if x != &#x27;.&#x27;] for y in board] col = [[x for x in y if x != &#x27;.&#x27;] for y in zip(*board)] pal = [[board[i+m][j+n] for m in range(3) for n in range(3) if board[i+m][j+n] != &#x27;.&#x27;] for i in (0, 3, 6) for j in (0, 3, 6)] return all(len(set(x)) == len(x) for x in (*row, *col, *pal)) 利用 set 检查每个区块中是否有重复数字 pal 取区块的遍历方式是利用 i，j 遍历每个宫格左上角位置，然后取 3*3 区块38. Count and Say 1行 123class Solution: def countAndSay(self, n: int) -&gt; str: return &#x27;1&#x27; * (n is 1) or re.sub(r&#x27;(.)\\1*&#x27;, lambda m: str(len(m.group())) + m.group(1), self.countAndSay(n - 1)) 正则表达式 re.sub(正则，替换字符串或函数，被替换字符串，是否区分大小写) . 可匹配任意一个除了\\n的字符(.) 匹配任意一个除了\\n的字符并把这个匹配结果放进第一组(.)\\1 匹配一个任意字符的二次重复并把那个字符放入数组(.)\\1* 匹配一个任意字符的多次重复并把那个字符放入数组 group(default=0)可以取匹配文本 group(1)取第一个括号内的文本43. Multiply Strings 5行1234567class Solution: def multiply(self, num1: str, num2: str) -&gt; str: d = &#123;&#125; for i, n1 in enumerate(num1[::-1]): for j, n2 in enumerate(num2[::-1]): d[i + j] = d.get(i + j, 0) + int(n1) * int(n2) for k in [*d]: d[k + 1], d[k] = d.get(k + 1, 0) + int(d[k] * 0.1), d[k] % 10 return re.sub(&#x27;^0*&#x27;, &#x27;&#x27;, &#x27;&#x27;.join(map(str, d.values()))[::-1]) or &#x27;0&#x27; 本题的难点在于计算整数的时候不能超过32bits，因此使用竖式计算 我们遍历num1中的每个数字n1，然后带着这个数字遍历num2中的每个数字n2做乘法，所得乘积放进 d 中相应的位置然后逐位计算结果 i + j 正好对应俩个数字相乘后所在的位置，比如 0 + 0 就应该是个位， 0 + 1 就是十位， 1 + 1 百位。这里所说的位置可以参考这篇博客中的过程图 若完全不想使用int()可以参考： 123456789class Solution: def multiply(self, num1: str, num2: str) -&gt; str: d = &#123;&#125; for i, n1 in enumerate(num1[::-1]): for j, n2 in enumerate(num2[::-1]): d[i + j] = d.get(i + j, 0) + (ord(n1) - 48) * (ord(n2) - 48) for k in [*d]: d[k + 1], d[k] = d.get(k + 1, 0) + math.floor(d[k] * 0.1), d[k] % 10 return re.sub(&#x27;^0*&#x27;, &#x27;&#x27;, &#x27;&#x27;.join(map(str, d.values()))[::-1]) or &#x27;0&#x27; 46. Permutations 1行123class Solution: def permute(self, nums: List[int]) -&gt; List[List[int]]: return [[n] + sub for i, n in enumerate(nums) for sub in self.permute(nums[:i] + nums[i+1:])] or [nums] 每次固定第一个数字递归地排列数组剩余部分 python 有内置函数可以直接实现 1234class Solution: def permute(self, nums: List[int]) -&gt; List[List[int]]: from itertools import permutations return list(permutations(nums)) 49. Group Anagrams 1行123class Solution: def groupAnagrams(self, strs): return [[*x] for _, x in itertools.groupby(sorted(strs, key=sorted), sorted)] 使用 groupby 函数依据 sorted 结果分组50. Pow(x, n) 2行1234class Solution: def myPow(self, x, n, r=1) -&gt; float: x, n = n &lt; 0 and 1 / x or x, abs(n) return self.myPow(x * x, n // 2, r * (not n % 2 or x)) if n else r 尾递归 $O(\\log N)$ 解法 x^4 正常计算过程：x * x * x * x，$O(N)$ 优化后：(x**2)**2，$O(\\log N)$53. Maximum Subarray 2行1234class Solution: def maxSubArray(self, nums): from functools import reduce return reduce(lambda r, x: (max(r[0], r[1]+x), max(r[1]+x,x)), nums, (max(nums), 0))[0] reduce 函数详解 r[0]代表以当前位置为结尾的局部最优解 r[1]代表全局最优解 直接DP的解法更好理解一些 12345class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: for i in range(1, len(nums)): nums[i] = max(nums[i], nums[i] + nums[i-1]) return max(nums) 54. Spiral Matrix 1行123class Solution: def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]: return matrix and [*matrix.pop(0)] + self.spiralOrder([*zip(*matrix)][::-1]) 为什么是[*matrix.pop(0)]而不是matrix.pop(0)？因为对于后面的递归，传进来的列表中元素是tuple58. Length of Last Word 1行123class Solution: def lengthOfLastWord(self, s: str) -&gt; int: return len(s.strip(&#x27; &#x27;).split(&#x27; &#x27;)[-1]) 59. Spiral Matrix II 3行12345class Solution: def generateMatrix(self, n: int) -&gt; List[List[int]]: r, n = [[n**2]], n**2 while n &gt; 1: n, r = n - len(r), [[*range(n - len(r), n)]] + [*zip(*r[::-1])] return r 流程图123|| =&gt; |9| =&gt; |8| |6 7| |4 5| |1 2 3| |9| =&gt; |9 8| =&gt; |9 6| =&gt; |8 9 4| |8 7| |7 6 5| 61. Rotate List 4行123456789101112# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def rotateRight(self, head: ListNode, k: int) -&gt; ListNode: l = [] while head: l[len(l):], head = [head], head.next if l: l[-1].next, l[-1 - k % len(l)].next = l[0], None return l[- k % len(l)] if l else None 62. Unique Paths 1行 123class Solution: def uniquePaths(self, m: int, n: int) -&gt; int: return int(math.factorial(m+n-2)/math.factorial(m-1)/math.factorial(n-1)) 题目可以转换为排列组合问题，解是$\\cal C^{\\min (m,\\; n)}_{ m+n}$，从$m+n$个中选出$m$个下移或$n$个右移。 用DP做也很快，以后自己算 $\\cal C_a^b$ 也可以用算这题的DP法代替 math.factorial 的速度不亚于DP，可能内部有优化 0的阶乘为166. Plus One 1行 123class Solution: def plusOne(self, digits: List[int]) -&gt; List[int]: return list(map(int, str(int(&#x27;&#x27;.join(map(str, digits))) + 1))) 67. Add Binary 1行123class Solution: def addBinary(self, a: str, b: str) -&gt; str: return bin(int(a, 2) + int(b, 2))[2:] 非内置函数解法：1234567891011class Solution: def addBinary(self, a: str, b: str) -&gt; str: r, p = &#x27;&#x27;, 0 d = len(b) - len(a) a = &#x27;0&#x27; * d + a b = &#x27;0&#x27; * -d + b for i, j in zip(a[::-1], b[::-1]): s = int(i) + int(j) + p r = str(s % 2) + r p = s // 2 return &#x27;1&#x27; + r if p else r 69. Sqrt(x) 1行123class Solution: def mySqrt(self, x: int) -&gt; int: return int(x ** 0.5) 出题者应该是希望看到下面的答案：123456class Solution: def mySqrt(self, x: int) -&gt; int: r = x while r*r &gt; x: r = (r + x/r) // 2 return int(r) 基本不等式$\\frac {a+b}{2} \\ge \\sqrt{ab}$ 推导自 $(a-b)^2 \\ge 0$，注意 $a&gt;0$ 且 $b&gt;0$。 r 代表 result70. Climbing Stairs 2行 1234class Solution: def climbStairs(self, n: int) -&gt; int: from functools import reduce return reduce(lambda r, _: (r[1], sum(r)), range(n), (1, 1))[0] dp递归方程：到达当前楼梯的路径数 = 到达上个楼梯的路径数 + 到达上上个楼梯的路径数 这里用一个元组 r 来储存（当前楼梯路径数，下一层楼梯路径数） 利用 reduce 来代替for循环。reduce 函数详解71. Simplify Path 4行123456class Solution: def simplifyPath(self, path: str) -&gt; str: r = [] for s in path.split(&#x27;/&#x27;): r = &#123;&#x27;&#x27;:r, &#x27;.&#x27;:r, &#x27;..&#x27;:r[:-1]&#125;.get(s, r + [s]) return &#x27;/&#x27; + &#x27;/&#x27;.join(r) 73. 矩阵置零 5行123456789class Solution: def setZeroes(self, matrix: List[List[int]]) -&gt; None: row = [[0] * len(i) if 0 in i else i for i in matrix] col = [[0] * len(j) if 0 in j else list(j) for j in zip(*matrix)] col2row = list(map(list, zip(*col))) # 上面一行效果等同： # col2row = [list(i) for i in zip(*col)] for i in range(len(matrix)): matrix[i] = col2row[i] if row[i] != [0] * len(matrix[0]) else row[i] 获取每一行 / 列的值，假如有0 就整行 / 整列置为0 重新将列排序列表转换为行排序列表，即原来的matrix中有0的列全为0，行不变 zip(*col) 返回的是zip类型，需要转换成list，其中元素类型为元组 所以之后做了两步转换，先将zip()返回的各个元组转换为list，在将整个转换为list 替换matrix各行， 如果一整行为0， 则替换为0，否则为col2row对应的各行 74. 搜索二维矩阵 4行123456class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool: if not matrix or not matrix[0]: return False col = list(list(zip(*matrix))[0]) # set() -&gt; list() index = bisect.bisect_left(col, target, 0, len(matrix)-1) # 二分查找 return target in (matrix[index] + matrix[index-1]) 先获取首列，然后二分类找到这个数所在的行，然后进行判断 78. Subsets 2行1234class Solution: def subsets(self, nums: List[int]) -&gt; List[List[int]]: from itertools import combinations return sum([list(combinations(nums, i)) for i in range(len(nums) + 1)], []) 80. 删除排序数组中的重复项 II 4行12345def removeDuplicates(nums: [int]) -&gt; int: for i in range(len(nums)-3, -1, -1): if nums[i] == nums[i+1] and nums[i] == nums[i+2]: nums.pop(i) return len(nums) 从尾部开始考虑 81. 搜索旋转排序数组 II 1行12def search(nums: [int], target: int) -&gt; bool: return target in nums 83. Remove Duplicates from Sorted List 3行1234567891011# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def deleteDuplicates(self, head: ListNode) -&gt; ListNode: if head: head.next = self.deleteDuplicates(head.next) return head.next if head.next and head.val == head.next.val else head 如果当前节点和下一个节点的值相同，则返回第二个节点 在每个递归中将下一个递归结果连接到当前节点 88. Merge Sorted Array 1行123456class Solution: def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums1 in-place instead. &quot;&quot;&quot; while n &gt; 0: nums1[m+n-1], m, n = (nums1[m-1], m-1, n) if m and nums1[m-1] &gt; nums2[n-1] else (nums2[n-1], m, n-1) 这种题倒着算更容易 上面那行代码其实就相当于： 12345678910class Solution: def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums1 in-place instead. &quot;&quot;&quot; while n &gt; 0: if m and nums1[m-1] &gt; nums2[n-1]: nums1[m+n-1], m, n = nums1[m-1], m-1, n else: nums1[m+n-1], m, n = nums2[n - 1], m, n-1 89. Gray Code 1行123class Solution: def grayCode(self, n: int) -&gt; List[int]: return (lambda r: r + [x | 1&lt;&lt;n-1 for x in r[::-1]])(self.grayCode(n-1)) if n else [0] 前4个结果： 1234[0][0 1][00 01 11 10][000 001 011 010 110 111 101 100] 递归方程：这一步结果 = 上一步结果 + 上一步结果的镜像并在每个二进制数字前面加一位1 &lt;&lt; 左移符号，即在二进制表示后加一位 0 ，例子：3&lt;&lt;1 等于 6（011 → 110），相当于 3 * 2的1次方 x | 1&lt;&lt;n-1 就是在十进制数字 x 的二进制前面加一位1之后的十进制结果，比如 x = 1，有 1 | 10 等于 110 循环可以避免一些不必要的操作，会比递归快一些： 123456class Solution: def grayCode(self, n: int) -&gt; List[int]: r = [0] for i in range(n): r.extend([x | 1&lt;&lt;i for x in r[::-1]]) return r 或者直接背格雷码的公式🥶吧：123class Solution: def grayCode(self, n: int) -&gt; List[int]: return [i ^ i &gt;&gt; 1 for i in range(1 &lt;&lt; n)] 91. Decode Ways 4行123456class Solution: def numDecodings(self, s: str) -&gt; int: pp, p = 1, int(s[0] != &#x27;0&#x27;) for i in range(1, len(s)): pp, p = p, pp * (9 &lt; int(s[i-1:i+1]) &lt;= 26) + p * (int(s[i]) &gt; 0) return p 输入 ‘12’ 的结果为 2，如果我们在 ‘12’ 后面增加一个数字 3，输入变成 ‘123’，结果是 ‘12’的结果 + ‘1’的结果 = 3 i 从索引 1 开始逐渐遍历 s，当前位置对应结果 = 上上次结果(如果 i 位置字符和 i-1 位置字符的组合满足条件) + 上次结果(如果 s[i] 不为 0)94. Binary Tree Inorder Traversal 2行1234567891011# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def inorderTraversal(self, root: TreeNode) -&gt; List[int]: f = self.inorderTraversal return f(root.left) + [root.val] + f(root.right) if root else [] 递归12345678910111213class Solution: def inorderTraversal(self, root: TreeNode) -&gt; List[int]: r, stack = [], [] while True: while root: stack.append(root) root = root.left if not stack: return r node = stack.pop() r.append(node.val) root = node.right return r 迭代98. Validate Binary Search Tree 3行123456789101112# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isValidBST(self, root: TreeNode, first=True) -&gt; bool: if not root: return first or [] l = self.isValidBST(root.left, 0) + [root.val] + self.isValidBST(root.right, 0) return all([a &gt; b for a, b in zip(l[1:], l)]) if first else l 搜索二叉树的中序遍历结果呈升序101. Symmetric Tree 5行1234567891011121314# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isSymmetric(self, root: TreeNode) -&gt; bool: if not root or root.left is root.right: return True l, r, i, o = root.left, root.right, TreeNode(0), TreeNode(0) if (l and l.val) != (r and r.val): return False i.left, i.right, o.left, o.right = l.left, r.right, l.right, r.left return self.isSymmetric(i) and self.isSymmetric(o) 一棵树对称意味着： 左节点 == 右节点 左节点的左子树与右节点右子树对称 左节点的右子树与右节点左子树对称 前三行处理特殊情况：root为None或root无子节点直接返回True，root只有一个子节点或root两个子节点不相等直接返回False 第一个条件在前三行处理过了，对于第二和第三个条件，我们分别构造两个假树i(inner)和o(outer)，i代表内假树，对应条件二，o代表外假树，对应条件三。递归内外假树即可104. Maximum Depth of Binary Tree 1行12345678910# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def maxDepth(self, root: TreeNode) -&gt; int: return max(map(self.maxDepth,(root.left, root.right))) + 1 if root else 0 利用map函数递归左右节点获取最大值，map函数会将参数一所指向的函数应用于参数二里的所有对象并返回所有结果构成的迭代器110. 平衡二叉树 3行123456789101112# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isBalanced(self, root: TreeNode, first=True) -&gt; bool: if not root: return first or 0 l, r = map(lambda x: self.isBalanced(x, False), [root.left, root.right]) return max(l,r)+1 if min(l,r)&gt;-1 and abs(l-r)&lt;=1 else (-1, False)[first] DFS递归每个节点 如果这个节点不平衡，那么这棵树肯定不平衡，它和它的所有父节点都返回 -1（根节点返回False） 如果节点平衡，则返回当前树的高度 + 1（根节点返回True）112. Path Sum 3行123456789101112# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def hasPathSum(self, root: TreeNode, sum: int) -&gt; bool: if not root: return False l, r, f = root.left, root.right, lambda x: self.hasPathSum(x, sum - root.val) return l is r and sum == root.val or f(l) or f(r) 考虑初始状态：当树不存在时直接返回 False 考虑支路1：当前节点为叶节点时直接判断总和是否达到要求 考虑支路2：当前节点为非叶节点时将总和缩小并继续递归，判断左右节点是否存在满足条件的 当递归函数到达叶节点时，sum 已经被削减了多次，此时 sum - node.val 即为 原始的sum - 整条路径的总和118. Pascal’s Triangle 1行123class Solution: def generate(self, numRows: int) -&gt; List[List[int]]: return [[math.factorial(i)//math.factorial(i-j)//math.factorial(j) for j in range(i+1)] for i in range(numRows)] 参考了杨辉三角的数学性质，维基百科 正常迭代方法： 123456class Solution: def generate(self, numRows: int) -&gt; List[List[int]]: r = [[1]] for i in range(1, numRows): r.append([1] + [sum(r[-1][j:j+2]) for j in range(i)]) return numRows and r or [] 121. Best Time to Buy and Sell Stock 2行1234class Solution: def maxProfit(self, prices: List[int]) -&gt; int: from functools import reduce return reduce(lambda r, p: (max(r[0], p-r[1]), min(r[1], p)), prices, (0, float(&#x27;inf&#x27;)))[0] r = (结果，之前遍历过的所有元素中的最小值) reduce 函数详解123456class Solution: def maxProfit(self, prices: List[int]) -&gt; int: r, m = 0, float(&#x27;inf&#x27;) for p in prices: r, m = max(r, p - m), min(m, p) return r 122. Best Time to Buy and Sell Stock II 2行123class Solution: def maxProfit(self, prices: List[int]) -&gt; int: return sum(b - a for a, b in zip(prices, prices[1:]) if b &gt; a) 本题可以在同一天买入和卖出，因此只要当天票价比昨天的高就可以卖出124. Binary Tree Maximum Path Sum 4行12345678910111213# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def maxPathSum(self, root: TreeNode, ok=True) -&gt; int: if not root: return 0 l, r = self.maxPathSum(root.left, False), self.maxPathSum(root.right, False) self.max = max(getattr(self, &#x27;max&#x27;, float(&#x27;-inf&#x27;)), l + root.val + r) return self.max if ok else max(root.val + max(l, r), 0) 使用 self.max 记录全局最大值，getattr 返回自身 max 属性的值或预定义的负无穷 本题思路是：递归每一个节点，返回max(以当前节点为结尾的最大路径和,0)。并更新最大值全局最大路径和=max(全局最大路径和，当前节点值+左子树返回结果+右子树返回结果) 用ok判断是不是第一次递归，是就返回全局最大值，否则照常133. Clone Graph12345678910&quot;&quot;&quot;# Definition for a Node.class Node: def __init__(self, val, neighbors): self.val = val self.neighbors = neighbors&quot;&quot;&quot;class Solution: def cloneGraph(self, node: &#x27;Node&#x27;) -&gt; &#x27;Node&#x27;: return copy.deepcopy(node) dfs解法请参考 133克隆图136. Single Number 2行1234class Solution: def singleNumber(self, nums: List[int]) -&gt; int: from functools import reduce return reduce(int.__xor__, nums) 这里用到了异或（xor），相同的数字异或后为0，0异或任何数都等于那个数，用reduce在列表所有元素之间使用异或^，那么留下的就是那个单独的数字了138. Copy List with Random Pointer 1行1234567891011&quot;&quot;&quot;# Definition for a Node.class Node: def __init__(self, val, next, random): self.val = val self.next = next self.random = random&quot;&quot;&quot;class Solution: def copyRandomList(self, head: &#x27;Node&#x27;) -&gt; &#x27;Node&#x27;: return copy.deepcopy(head) 内置函数139. Word Break 8行123456789101112class Solution: def wordBreak(self, s, wordDict): def f(s, d=&#123;&#125;): if not s in d: for i in range(1, 1 + len(s)): d[s[:i]] = s[:i] in wordDict and (i == len(s) or f(s[i:])) if d[s[:i]]: return True return False return d[s] return f(s) brute force + memory141. Linked List Cycle 2行1234567891011121314# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def hasCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: bool &quot;&quot;&quot; while head and head.val != None: head.val, head = None, head.next return head != None 这题不支持python3，所以用pyhton2解法代替，下题记得调回来 破坏走过的所有节点，下次再遇到就知道了 不过以上方法会丢失原有信息，一般解法为快慢指针123456789101112131415# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def hasCycle(self, head): slow = fast = head while fast and fast.next: fast = fast.next.next slow = slow.next if slow == fast: return True return False 142. Linked List Cycle II 5行1234567891011121314151617# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def detectCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; s = &#123;None&#125; while head not in s: s.add(head) head = head.next return head 把见过的节点丢集合里，下次再遇见就是环的开始 还有一个纯数学的快慢指针解法，设环的起始节点为 E，快慢指针从 head 出发，快指针速度为 2，设相交节点为 X，head 到 E 的距离为 H，E 到 X 的距离为 D，环的长度为 L，那么有：快指针走过的距离等于慢指针走过的距离加快指针多走的距离（多走了 n 圈的 L） 2(H + D) = H + D + nL，因此可以推出 H = nL - D，这意味着如果我们让俩个慢指针一个从 head 出发，一个从 X 出发的话，他们一定会在节点 E 相遇 12345 _____ / \\head___________E \\ \\ / X_____/ 1234567891011121314class Solution(object): def detectCycle(self, head): slow = fast = head while fast and fast.next: fast = fast.next.next slow = slow.next if slow == fast: break else: return None while head is not slow: head = head.next slow = slow.next return head 146. LRU Cache 7行1234567891011121314151617181920class LRUCache(object): def __init__(self, capacity): self.od, self.cap = collections.OrderedDict(), capacity def get(self, key): if key not in self.od: return -1 self.od.move_to_end(key) return self.od[key] def put(self, key, value): if key in self.od: del self.od[key] elif len(self.od) == self.cap: self.od.popitem(False) self.od[key] = value# Your LRUCache object will be instantiated and called as such:# obj = LRUCache(capacity)# param_1 = obj.get(key)# obj.put(key,value) 148. Sort List 10行12345678910111213141516171819# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def sortList(self, head: ListNode) -&gt; ListNode: if not (head and head.next): return head pre, slow, fast = None, head, head while fast and fast.next: pre, slow, fast = slow, slow.next, fast.next.next pre.next = None return self.mergeTwoLists(*map(self.sortList, (head, slow))) def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode: if l1 and l2: if l1.val &gt; l2.val: l1, l2 = l2, l1 l1.next = self.mergeTwoLists(l1.next, l2) return l1 or l2 使用快慢指针寻找链表中点，并分解链表 递归融合俩个有序链表，详解见 21 题 此处忽略了递归开栈导致的非 常数级空间复杂度（想太多了吧），如果一定要抬杠，推荐使用quicksort 123456789101112131415161718192021222324252627282930313233343536class Solution(object): def sortList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; def partition(start, end): node = start.next.next pivotPrev = start.next pivotPrev.next = end pivotPost = pivotPrev while node != end: temp = node.next if node.val &gt; pivotPrev.val: node.next = pivotPost.next pivotPost.next = node elif node.val &lt; pivotPrev.val: node.next = start.next start.next = node else: node.next = pivotPost.next pivotPost.next = node pivotPost = pivotPost.next node = temp return [pivotPrev, pivotPost] def quicksort(start, end): if start.next != end: prev, post = partition(start, end) quicksort(start, prev) quicksort(post, end) newHead = ListNode(0) newHead.next = head quicksort(newHead, None) return newHead.next 150. Evaluate Reverse Polish Notation 5行1234567class Solution: def evalRPN(self, tokens: List[str]) -&gt; int: t, f = tokens.pop(), self.evalRPN if t in &#x27;+-*/&#x27;: b, a = f(tokens), f(tokens) t = eval(&#x27;a&#x27; + t + &#x27;b&#x27;) return int(t) 递归地返回左右表达式操作后结果 eval 函数将字符串看作代码得到输出值155. Min Stack 每个1行123456789101112131415161718192021222324class MinStack: def __init__(self): self.data = [(None, float(&#x27;inf&#x27;))] def push(self, x: &#x27;int&#x27;) -&gt; &#x27;None&#x27;: self.data.append((x, min(x, self.data[-1][1]))) def pop(self) -&gt; &#x27;None&#x27;: if len(self.data) &gt; 1: self.data.pop() def top(self) -&gt; &#x27;int&#x27;: return self.data[-1][0] def getMin(self) -&gt; &#x27;int&#x27;: return self.data[-1][1]# Your MinStack object will be instantiated and called as such:# obj = MinStack()# obj.push(x)# obj.pop()# param_3 = obj.top()# param_4 = obj.getMin() 160. Intersection of Two Linked Lists 3行123456789101112131415# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def getIntersectionNode(self, headA, headB): &quot;&quot;&quot; :type head1, head1: ListNode :rtype: ListNode &quot;&quot;&quot; a, b = (headA, headB) if headA and headB else (None, None) while a != b: a, b = not a and headB or a.next, not b and headA or b.next return a 这题不支持 Python3 所以只能用 Python2 做了 把第一条链表的尾部接到第二条链表的开头，第二条接到第一条的开头，就能消除俩条链表的长度差，并在某一时刻在第一个交叉点相遇，或在走完俩条链表长度的时候同时为 None 1234# 假设有两条链表1→2→3→4和①→②→③，模拟一下算法流程 ↓1 → 2 ↘ ↗ → 4 1 → 2 ↘ ↗ → 4 → ① → → → 3(②) ❤ 相遇了① → → → 3(②) → ③ 把4接到①前面，把③接到1前面 ① → → → 3(②) → ③ → 1 → 2 ↗ 若非相交链表则同时走到None 162. Find Peak Element 2行1234class Solution: def findPeakElement(self, nums: List[int]) -&gt; int: self.__class__.__getitem__ = lambda self, i: i and nums[i - 1] &gt; nums[i] return bisect.bisect_left(self, True, 0, len(nums)) - 1 二分查找套路 如果当前位置的左边是更大的数字，则当前位置置为True，继续向左搜索，最后应该插入的位置 = 我们寻找的位置 + 1，因此最后 - 1165. Compare Version Numbers 4行123456class Solution: def compareVersion(self, version1: str, version2: str) -&gt; int: v1, v2 = [*map(int, version1.split(&#x27;.&#x27;))], [*map(int, version2.split(&#x27;.&#x27;))] d = len(v2) - len(v1) v1, v2 = v1 + [0] * d, v2 + [0] * -d return (v1 &gt; v2) - (v1 &lt; v2) 利用 python 序列比较的性质169. Majority Element 1行123class Solution: def majorityElement(self, nums: List[int]) -&gt; int: return sorted(nums)[len(nums) // 2] 171. Excel Sheet Column Number 1行123class Solution: def titleToNumber(self, s: str) -&gt; int: return sum((ord(c) - 64) * 26**i for i, c in enumerate(s[::-1])) 173. Binary Search Tree Iterator 6行1234567891011121314151617181920212223242526272829303132# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass BSTIterator: def __init__(self, root: TreeNode): self.s = [] while root: self.s[len(self.s):], root = [root], root.left def next(self) -&gt; int: &quot;&quot;&quot; @return the next smallest number &quot;&quot;&quot; r, root = self.s[-1], self.s.pop().right while root: self.s[len(self.s):], root = [root], root.left return r.val def hasNext(self) -&gt; bool: &quot;&quot;&quot; @return whether we have a next smallest number &quot;&quot;&quot; return bool(self.s)# Your BSTIterator object will be instantiated and called as such:# obj = BSTIterator(root)# param_1 = obj.next()# param_2 = obj.hasNext() 模拟中序遍历的迭代过程，使用堆栈 self.s 进行深度优先搜索 空间复杂度为 O(树的高度) $平均时间复杂度 = \\frac {循环总次数（N）}{迭代器长度（N）} = O(1)$ 迭代器解法：123456789101112131415161718192021from itertools import chainclass BSTIterator: def __init__(self, root: TreeNode): def gen(root): yield from chain(gen(root.left), [root.val], gen(root.right)) if root else () self.iter, self.len = gen(root), 0 for _ in gen(root): self.len += 1 def next(self) -&gt; int: &quot;&quot;&quot; @return the next smallest number &quot;&quot;&quot; self.len -= 1 return next(self.iter) def hasNext(self) -&gt; bool: &quot;&quot;&quot; @return whether we have a next smallest number &quot;&quot;&quot; return bool(self.len) 平均时空复杂度： $O(1)$，$O(1)$189. Rotate Array 1行123456class Solution: def rotate(self, nums: List[int], k: int) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. &quot;&quot;&quot; nums[:] = nums[len(nums) - k:] + nums[:len(nums) - k] 空间复杂度 = $O(N)$ 进阶： 123456class Solution: def rotate(self, nums: List[int], k: int) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. &quot;&quot;&quot; for _ in range(k % len(nums)): nums[-1:], nums[:0] = [], nums[-1:] 时间复杂度 = $O(k \\;\\%\\; len(nums))$，空间复杂度 = $O(1)$190. Reverse Bits 1行12345class Solution: # @param n, an integer # @return an integer def reverseBits(self, n): return int(bin(n)[2:].zfill(32)[::-1], 2) 字符串操作 ziff用法191. Number of 1 Bits 1行1234567class Solution(object): def hammingWeight(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; return bin(n).count(&#x27;1&#x27;) 198. House Robber 2行1234class Solution: def rob(self, nums: List[int]) -&gt; int: from functools import reduce return reduce(lambda r, n: (max(r[0], n + r[1]), r[0]), nums, (0, 0))[0] DP递归方程：一直偷到这家的钱 = max（一直偷到上一家的钱，一直偷到上上家的钱 + 这家的钱）😃有点小绕 以上为下面代码的化简版，reduce 函数详解123456class Solution: def rob(self, nums: List[int]) -&gt; int: last, now = 0, 0 for i in nums: last, now = now, max(last + i, now) return now DP不一定要数组，这里两个变量就够了，空间复杂度为$O(1)$200. Number of Islands 7行123456789class Solution(object): def numIslands(self, grid): def sink(i, j): if 0 &lt;= i &lt; len(grid) and 0 &lt;= j &lt; len(grid[i]) and int(grid[i][j]): grid[i][j] = &#x27;0&#x27; for i, j in zip((i, i+1, i, i-1), (j+1, j, j-1, j)): sink(i, j) return 1 return 0 return sum(sink(i, j) for i in range(len(grid)) for j in range(len(grid[i]))) 根据题意，我们可以把每一个陆地点当作树根，用 DFS 搜索四周的陆地并沉没它，那么这一整块的陆地都被沉没了，下次我们再遇到陆地点的时候就说明发现新大陆了202. Happy Number 1行123class Solution: def isHappy(self, n: int) -&gt; bool: return self.isHappy(sum(int(i) ** 2 for i in str(n))) if n &gt; 4 else n == 1 不是快乐数的数称为不快乐数(unhappy number)，所有不快乐数的数位平方和计算，最后都会进入 4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4 的循环中 这个规律比较难想到的，正常解法是判断n是否会进入循环：1234567class Solution: def isHappy(self, n: int) -&gt; bool: seen = &#123;1&#125; while n not in seen: seen.add(n) n = sum(int(i) ** 2 for i in str(n)) return n == 1 203. Remove Linked List Elements 2行12345678910# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def removeElements(self, head: ListNode, val: int) -&gt; ListNode: if head: head.next = self.removeElements(head.next, val) return head.next if head and head.val == val else head 递归：每次都返回从当前位置算起第一个有效的节点或None205. Isomorphic Strings 1行123class Solution: def isIsomorphic(self, s: str, t: str) -&gt; bool: return [*map(s.index, s)] == [*map(t.index, t)] 同构代表两个字符串中每个位置上字符在自身第一次出现的索引相同206. Reverse Linked List 2行12345678910# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def reverseList(self, head: ListNode, tail=None) -&gt; ListNode: if head: head.next, tail, head = tail, head, head.next return self.reverseList(head, tail) if head else tail 递归解法 此解法为尾递归，即直接以递归返回值作为结果，一般编译器会做优化，避免多余的函数开栈操作，实现效果相当于迭代1234567891011# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def reverseList(self, head: ListNode) -&gt; ListNode: p = None while head: head.next, p, head = p, head, head.next return p 迭代解法215. Kth Largest Element in an Array 1行123class Solution: def findKthLargest(self, nums: List[int], k: int) -&gt; int: return sorted(nums)[-k] $O(N\\log N)$调库 面试官一般不会接受以上答案的，可以参考下面这个$O(N)$的quick-selection，思路借鉴的quick-sort 123456789101112class Solution: def findKthLargest(self, nums: List[int], k: int) -&gt; int: l = [x for x in nums if x &gt; nums[0]] m = [x for x in nums if x == nums[0]] r = [x for x in nums if x &lt; nums[0]] f = self.findKthLargest if k &lt;= len(l): return f(l, k) elif k &lt;= len(l) + len(m): return nums[0] return f(r, k - len(l) - len(m)) 217. Contains Duplicate 1行123class Solution: def containsDuplicate(self, nums: List[int]) -&gt; bool: return len(nums) != len(set(nums)) 219. Contains Duplicate II 4行123456class Solution: def containsNearbyDuplicate(self, nums: List[int], k: int) -&gt; bool: r, d = k + 1, &#123;&#125; for i, n in enumerate(nums): r, d[n] = min(r, i - d.get(n, -k - 1)), i return r &lt;= k 本题题目有误，实际意思是找同数字最小间隔，若不超过 k 则满足条件 遍历列表，每次都比对最小间隔，并更新哈希表索引，当前位置往左的最小间隔一定是与上一次同数字出现的索引的距离225. Implement Stack using Queues 6行1234567891011121314151617class MyStack: def __init__(self): self.q = collections.deque() def push(self, x): self.q.append(x) for _ in range(len(self.q) - 1): self.q.append(self.q.popleft()) def pop(self): return self.q.popleft() def top(self): return self.q[0] def empty(self): return not len(self.q) push 的时候把 x 放入队尾，然后遍历一遍原始队列元素，每次弹出之后加入队尾230. Kth Smallest Element in a BST 3行123456789101112# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def kthSmallest(self, root, k): from itertools import chain, islice def gen(x): yield from chain(gen(x.left), [x.val], gen(x.right)) if x else () return next(islice(gen(root), k - 1, k)) 本题利用迭代器骚了一波，不太了解的话看这里 【yield 推荐阅读博客】 chain 函数可以组合多个迭代器，islice 函数对迭代器做切片操作 此题常规解法 中序遍历 还是需要了解下的 12345678910111213141516171819202122232425# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def kthSmallest(self, root, k): &quot;&quot;&quot; :type root: TreeNode :type k: int :rtype: int &quot;&quot;&quot; res = [] self.visitNode(root, res) return res[k - 1] # 中序遍历 def visitNode(self, root, res): if root is None: return self.visitNode(root.left, res) res.append(root.val) self.visitNode(root.right, res) 231. 2的幂 1行1234567class Solution: def isPowerOfTwo(self, n: int) -&gt; bool: &quot;&quot;&quot; :type n: int :rtype: bool &quot;&quot;&quot; return n &gt; 0 and n &amp; n - 1 == 0 2 的幂的二进制形式最高位一定是1，其余为0 用常规思路也行 123class Solution(object): def isPowerOfTwo(self, n): return n &gt; 0 and 2**int(math.log2(n)) == n 232. Implement Queue using Stacks 13行1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class MyQueue: def __init__(self): &quot;&quot;&quot; Initialize your data structure here. &quot;&quot;&quot; self.stack = [] def push(self, x: int) -&gt; None: &quot;&quot;&quot; Push element x to the back of queue. &quot;&quot;&quot; self.stack.append(x) def pop(self) -&gt; int: &quot;&quot;&quot; Removes the element from in front of queue and returns that element. &quot;&quot;&quot; temp = [] while self.stack: temp.append(self.stack.pop()) r = temp.pop() while temp: self.stack.append(temp.pop()) return r def peek(self) -&gt; int: &quot;&quot;&quot; Get the front element. &quot;&quot;&quot; temp = [] while self.stack: temp.append(self.stack.pop()) r = temp[-1] while temp: self.stack.append(temp.pop()) return r def empty(self) -&gt; bool: &quot;&quot;&quot; Returns whether the queue is empty. &quot;&quot;&quot; return not self.stack# Your MyQueue object will be instantiated and called as such:# obj = MyQueue()# obj.push(x)# param_2 = obj.pop()# param_3 = obj.peek()# param_4 = obj.empty() 使用俩个栈来模拟队列，当需要取第一个元素的时候创建一个临时的栈temp，把栈里面的东西全部抽出来放进temp，完成操作后放回去234. Palindrome Linked List 3行1234567891011# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def isPalindrome(self, head: ListNode) -&gt; bool: def gen(n): while n: yield n.val; n = n.next return [*gen(head)] == [*gen(head)][::-1] 235. Lowest Common Ancestor of a Binary Search Tree 2行1234567891011# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def lowestCommonAncestor(self, root, p, q): while (root.val - p.val) * (root.val - q.val) &gt; 0: root = (root.left, root.right)[p.val &gt; root.val] return root 最近公共祖先的值一定介于p、q值之间（ 闭区间$[p, \\;q]$ ）236. Lowest Common Ancestor of a Binary Tree 2行1234567891011# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def lowestCommonAncestor(self, root: &#x27;TreeNode&#x27;, p: &#x27;TreeNode&#x27;, q: &#x27;TreeNode&#x27;) -&gt; &#x27;TreeNode&#x27;: l, r = map(lambda x: x and self.lowestCommonAncestor(x, p, q), (root.left, root.right)) return (root in (p, q) or l and r) and root or l or r 递归全部节点，p 的祖先节点全部返回 p，q 的祖先节点全部返回 q，除非它同时是俩个节点的最近祖先，也就是 p，q 分别位于左右子树，那么返回自身 这思路用在235也行237. Delete Node in a Linked List 1行12345678910111213# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def deleteNode(self, node): &quot;&quot;&quot; :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. &quot;&quot;&quot; node.val, node.next = node.next.val, node.next.next node = node.next是不行的，因为这里只是改了函数参数引用的对象，而原来传进来的 node 没有任何改变 详细说明下：如果Python的函数得到的参数是可变对象（比如list，set，这样的，内部属性可以改变的），那么我们实际得到的是这个对象的浅拷贝。比如这个函数刚刚开始的时候题目传进来一个参数node，我们设这个节点为A，那么实际上得到的参数node是一个对于A的一个浅拷贝，你可以想象node是一把钥匙，它可以打开真正的节点A的门，如果我们现在让node = node.next，那么我们只是换了钥匙，变成了打开 A.next 的门的对应的钥匙，因此链表没有被修改， A没有被修改，只是我们手里的钥匙变了。而如果我们直接写node.val, node.next = node.next.val, node.next.next，就相当于我们先用钥匙找到 A 的门，然后修改了 A 的属性，链表发生变化 此题考查python函数的传参形式为“传对象引用”，相当于浅拷贝（对于可变对象来说）238. Product of Array Except Self 5行1234567class Solution: def productExceptSelf(self, nums: List[int]) -&gt; List[int]: res, l, r = [1] * len(nums), 1, 1 for i, j in zip(range(len(nums)), reversed(range(len(nums)))): res[i], l = res[i] * l, l * nums[i] res[j], r = res[j] * r, r * nums[j] return res $O(N)$双指针双向遍历240. Search a 2D Matrix II 1行12345678class Solution: def searchMatrix(self, matrix, target): &quot;&quot;&quot; :type matrix: List[List[int]] :type target: int :rtype: bool &quot;&quot;&quot; return any(target in row for row in matrix) 以下为 $O(m+n)$ 解法： 1234567891011121314class Solution: def searchMatrix(self, matrix, target): &quot;&quot;&quot; :type matrix: List[List[int]] :type target: int :rtype: bool &quot;&quot;&quot; j = -1 for row in matrix: while j &gt; -len(row) and row[j] &gt; target: j -= 1 if row and row[j] == target: return True return False 从矩阵右上角开始，若值比 target 大则证明这一列的值都比 target 大，继续搜索前面的列；若比 target 小说明 target 可能在后面的行中，进入下一行258. Add Digits 1行123class Solution: def addDigits(self, num: int) -&gt; int: return num % 9 or 9 * bool(num) $O(1)$ 数学推理：设某个数字的字符串表示为&#39;abc&#39;，则这个数字代表a*100 + b*10 + c，转换后成为a + b + c，可见每次转换相当于把原数字减去a*99 + b*9 = 9 * (a*11 + b)，可以推出只要高于个位的位置上有数字，算法就会减去一个小于原数字的9的倍数，这就相当于数字 % 9。但9 % 9 = 0，而 9 本身就没有十位，因此需要考虑原数字是 0 或 9 的倍数的特殊情况 首先计算num % 9，若结果为 0 则考虑num本身是否为 0，若不为 0 返回 912345class Solution: def addDigits(self, num: int) -&gt; int: while num &gt; 9: num = eval(&#x27;+&#x27;.join(n for n in str(num))) return num 循环判断268. Missing Number 1行123class Solution: def missingNumber(self, nums: List[int]) -&gt; int: return sum(range(len(nums) + 1)) - sum(nums) $O(N)$时间，$O(1)$空间（迭代器）123class Solution: def missingNumber(self, nums: List[int]) -&gt; int: return int(len(nums) * (len(nums) + 1) / 2 - sum(nums)) 等差数列求和公式，$O(1)$空间278. First Bad Version 2行12345678910111213# The isBadVersion API is already defined for you.# @param version, an integer# @return a bool# def isBadVersion(version):class Solution: def firstBadVersion(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; self.__class__.__getitem__ = lambda self, x: isBadVersion(x) return bisect.bisect_left(self, True, 1, n) 改造当前类的魔法方法getitem以使用内置函数 复现二分搜索解法如下：1234567891011121314151617181920# The isBadVersion API is already defined for you.# @param version, an integer# @return a bool# def isBadVersion(version):class Solution: def firstBadVersion(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; l, h = 1, n while l &lt;= h: m = (l + h) // 2 if isBadVersion(m) &gt; m * isBadVersion(m - 1): return m elif isBadVersion(m): h = m - 1 else: l = m + 1 本题二分搜索中判断返回的条件为 当前版本为True且（当前索引为0 或 左边的版本为False） m * 的作用是避免 m - 1 为负数，如果 m 为 0，则代表左边没有版本，只需判断当前版本是否为 True True &gt; False 或 0279. Perfect Squares 4行123456class Solution: def numSquares(self, n: int) -&gt; int: dp = [0] for i in range(1, n+1): dp.append(min(dp[-j*j] for j in range(1, 1 + int(i**0.5))) + 1) return dp[-1] dp方程：总和为 n 的最小完全平方数个数 = min(总和为 (n - 某个完全平方数) 的最小完全平方数个数) + 1 中文版力扣这题用dp会超时，可以使用bfs，或者拉格朗日四平方数和定理 😎：任何一个正整数都可以表示成不超过四个整数的平方之和。 推论：满足四数平方和定理的数n（四个整数的情况），必定满足 $n=4^{a(8b+7)}$123456789101112131415class Solution: def numSquares(self, n: int) -&gt; int: while n % 4 == 0: n /= 4 if n % 8 == 7: return 4 a = 0 while a**2 &lt;= n: b = int((n - a**2)**0.5) if a**2 + b**2 == n: return bool(a) + bool(b) a += 1 return 3 283. Move Zeroes 1行123456class Solution: def moveZeroes(self, nums: List[int]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. &quot;&quot;&quot; nums.sort(key=bool, reverse=True) sort 时间复杂度为$O(N\\log N)$, 直接遍历可以达到 $O(N)$12345678910class Solution: def moveZeroes(self, nums: List[int]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. &quot;&quot;&quot; i = 0 for i, n in enumerate(filter(lambda x: x, nums)): nums[i] = n for i in range(i + 1, len(nums)): nums[i] = 0 直接使用 filter 迭代器可以避免交换操作，思路更简单287. Find the Duplicate Number 2行1234class Solution: def findDuplicate(self, nums: List[int]) -&gt; int: self.__class__.__getitem__ = lambda sef, m: sum(n &lt;= m for n in nums) &gt; m return bisect.bisect_left(self, True, 1, len(nums) - 1) 本题可用二分查找，整个算法时间复杂度为 $O(N\\log N)$，由题意可知搜索范围在 1 到 n 之间，那么如何缩小范围？只需判断数组中不超过中间数 m 的元素数量是否大于 m 即可，若大于，则表示范围 1 到 m 内肯定包含重复的数字 搜索范围为 [1, n]，向左（包括target）搜索的条件为：不大于 n 的数字在 nums 存在超过 m 个，即搜索范围可以被缩小为 [1, m]292. Nim Game 1行123class Solution: def canWinNim(self, n: int) -&gt; bool: return bool(n % 4) 只要轮到你的时候剩余石头数量不是 4 的倍数都是完胜，因为你有办法使得每次轮到对方的时候剩余石头数量都为 4 的倍数326. Power of Three 1行123class Solution: def isPowerOfThree(self, n: int) -&gt; bool: return n &gt; 0 and 3 ** round(math.log(n, 3)) == n math.log 函数得到的数据可能不够精确，可以使用 round 取整328. Odd Even Linked List 6行1234567891011121314# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def oddEvenList(self, head: ListNode) -&gt; ListNode: if not head or not head.next: return head r, odd, p, head = head, head, head.next, head.next.next while head: odd.next, head.next, p.next = head, odd.next, head.next p, odd, head = p.next, head, p.next and p.next.next return r odd 记录上一个奇数位节点，p 记录前一个节点 从第3个位置开始循环，每次都把当前节点接到 odd 后面，然后跳到下一个奇数位节点继续循环342. Power of Four 1行123class Solution: def isPowerOfFour(self, num: int) -&gt; bool: return num &gt; 0 and not math.log(num, 4) % 1 采用 log 运算，若结果为整数则 num 为 4 的幂 整数 % 1 为 0344. Reverse String 1行123456class Solution: def reverseString(self, s: List[str]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify s in-place instead. &quot;&quot;&quot; s.reverse() 345. Reverse Vowels of a String 2行1234class Solution: def reverseVowels(self, s: str) -&gt; str: vowels = re.findall(&#x27;(?i)[aeiou]&#x27;, s) return re.sub(&#x27;(?i)[aeiou]&#x27;, lambda m: vowels.pop(), s) 遍历俩次，第一次找出元音字母放进 stack，第二次每遇到一个就把之前的栈顶替换进来347. Top K Frequent Elements 1行123class Solution: def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]: return [*next(zip(*collections.Counter(nums).most_common(k)))] Counter类的目的是用来跟踪值出现的次数。它是一个无序的容器类型，以字典的键值对形式存储，其中元素作为key，其计数作为value 关于 Counter，更多详细内容可参考 这里 非内置解法：12345678910111213class Solution: def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]: d = &#123;n: 0 for n in nums&#125; for n in nums: d[n] += 1 r = [] for _ in range(k): n = max(d, key=d.get) r.append(n) d[n] = -1 return r 349. Intersection of Two Arrays 1行123class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: return [*set(nums1) &amp; set(nums2)] 经过 set 之后，重复的元素被删除 与运算对于集合来说就是求交集350. Intersection of Two Arrays II 1行123class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: return [*(collections.Counter(nums1) &amp; collections.Counter(nums2)).elements()] 对于两个 Counter 对象，与操作意味着取两者都有的key, value取小的那一个 参考：Python Counter 计数工具12345678910111213141516class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: nums1.sort() nums2.sort() r = [] i = j = 0 while i &lt; len(nums1) and j &lt; len(nums2): if nums1[i] == nums2[j]: r.append(nums1[i]) i += 1 j += 1 elif nums1[i] &lt; nums2[j]: i += 1 else: j += 1 return r 进阶解法 ↑ 使用双指针将两个列表中共同的元素抠下来，因为已经排序，所以遇到不同元素时数值小的那个列表的指针向前移动367. Valid Perfect Square 4行123456class Solution: def isPerfectSquare(self, num: int) -&gt; bool: r = num while r * r &gt; num: r = (r + num / r) // 2 return r * r == num 基本不等式$\\frac{a+b}{2} \\ge \\sqrt{ab}$ 推导自 $(a-b)^2 \\ge 0$ → $a^2 + b^2 \\ge 2ab$ → $\\frac{a+b}{2} \\ge \\sqrt{ab}$（换元），注意 $a&gt;0$ 且 $b&gt;0$ $\\frac { r+ \\frac{num}{r}}{2} \\ge \\sqrt{num}$ 而 $r &gt; \\frac{num}{r}$ 保证每次迭代 r 在不断减小,而//的存在保证最接近的时候能够逃离循环体387. First Unique Character in a String 2行1234class Solution: def firstUniqChar(self, s: str) -&gt; int: d = &#123;c: s.count(c) for c in set(s)&#125; return ([i for i, c in enumerate(s) if d[c] == 1] + [-1])[0] 首先用字典 d 储存｛字符：出现次数｝，注意这里的字符来自 set，为了避免重复操作，防止TLE 用 list 记录 s 中出现次数为 1 的字符的索引 返回 list 第一个元素，如果原来的 s 中不存在出现次数为 1 的字符，则会返回后面添加的 [-1] 作为第一个元素389. Find the Difference 1行123class Solution: def findTheDifference(self, s: str, t: str) -&gt; str: return chr(sum(map(ord, t)) - sum(map(ord, s))) 每一个字符都对应一个 ASCII 数字，那么那个不同的数字的 ASCII 码就等于 t 的所有字符码之和 - s 的 ord 函数将单个字符转换为 ASCII 码， chr相反394. Decode String 14行1234567891011121314151617class Solution: def decodeString(self, s: str) -&gt; str: stack = [[&#x27;&#x27;, 1, &#x27;&#x27;]] a = n = &#x27;&#x27; for c in s: if c.isalpha(): a += c elif c.isdigit(): n += c elif c == &#x27;[&#x27;: stack.append([a, int(n), &#x27;&#x27;]) a = n = &#x27;&#x27; else: p, t, b = stack.pop() stack[-1][-1] += p + t * (b + a) a = &#x27;&#x27; return stack.pop()[-1] + a 用 stack 记录（[]之前的字母，翻倍次数，翻倍内容）412. Fizz Buzz 1行 123class Solution: def fizzBuzz(self, n): return [&#x27;Fizz&#x27; * (not i % 3) + &#x27;Buzz&#x27; * (not i % 5) or str(i) for i in range(1, n+1)] 7 or 8 = 7 0 or 8 = 8414. Third Maximum Number 3行12345class Solution: def thirdMax(self, nums: List[int]) -&gt; int: nums = set(nums) for _ in range((2, 0)[len(nums) &lt; 3]): nums.remove(max(nums)) return max(nums) 430. Flatten a Multilevel Doubly Linked List 5行1234567891011121314151617&quot;&quot;&quot;# Definition for a Node.class Node: def __init__(self, val, prev, next, child): self.val = val self.prev = prev self.next = next self.child = child&quot;&quot;&quot;from itertools import chainclass Solution: def flatten(self, head: &#x27;Node&#x27;) -&gt; &#x27;Node&#x27;: def gen(n): yield from chain([n], gen(n.child), gen(n.next)) if n else () iters = gen(head); p = head and next(iters) for n in iters: p.next, n.prev, p.child, n.child, p = n, p, None, None, n return head 使用迭代器按顺序输出所有节点，然后连接448. Find All Numbers Disappeared in an Array 1行1234class Solution: def findDisappearedNumbers(self, nums: List[int]) -&gt; List[int]: s = set(nums) return [i for i in range(1, len(nums) + 1) if i not in s] set 的内部实现为 dict，in 操作时间复杂度为 $O(1)$ 应题目进阶要求，以下解为 $O(N)$ 时间效率，无额外空间（除了返回数组和中间变量） 12345class Solution: def findDisappearedNumbers(self, nums: List[int]) -&gt; List[int]: for n in nums: nums[abs(n) - 1] = -abs(nums[abs(n) - 1]) return [i + 1 for i, n in enumerate(nums) if n &gt; 0] 此解实际上是利用索引把数组自身当作哈希表处理 将 nums 中所有正数作为索引i，置 nums[i] 为负值。那么，仍为正数的位置即为（未出现过）消失的数字 原始数组：[4,3,2,7,8,2,3,1] 重置后为：[-4,-3,-2,-7,8,2,-3,-1] 结论：[8,2] 分别对应的index为[5,6]（消失的数字）454. 4Sum II 2行1234class Solution: def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -&gt; int: dic = collections.Counter(a + b for a in A for b in B) return sum(dic.get(- c - d, 0) for c in C for d in D) 思路同第一题 TWO SUM 的 $O(N)$ 字典解法，记录需要的值461. Hamming Distance 1行123class Solution: def hammingDistance(self, x: int, y: int) -&gt; int: return bin(x ^ y).count(&#x27;1&#x27;) 485. Max Consecutive Ones 1行123class Solution: def findMaxConsecutiveOnes(self, nums: List[int]) -&gt; int: return len(max(&#x27;&#x27;.join(map(str, nums)).split(&#x27;0&#x27;))) 变成字符串然后用”0”去切分然后比子串长度494. Target Sum 5行123456789class Solution: def findTargetSumWays(self, nums: List[int], S: int) -&gt; int: def dfs(cur, i, d = &#123;&#125;): if i &lt; len(nums) and (i, cur) not in d: # 搜索周围节点 d[(i, cur)] = dfs(cur + nums[i], i + 1) + dfs(cur - nums[i], i + 1) return d.get((i, cur), int(cur == S)) return dfs(0, 0) dfs遍历所有可能结果，以当前位置 i 和当前总和 cur 为根节点，以下一位数字的加减为邻域扩散搜索 利用 d 构造记忆，以便剪枝（搜索过程中遇到相同位置和相同cur值时返回值应该相同） dfs中 d 参数传的是引用，所以只有第一次会采用默认值 {}495. Teemo Attacking123class Solution: def findPoisonedDuration(self, t: List[int], d: int) -&gt; int: return len(t) and sum(min(t[i] - t[i-1], d) for i in range(1, len(t))) + d 总时间 = 所有间隔时间的总和，每一次的间隔时间 = min(下次发射时间 - 这次发射时间，duration)498. Diagonal Traverse 5行1234567class Solution: def findDiagonalOrder(self, matrix: List[List[int]]) -&gt; List[int]: m, n, r = len(matrix), len(matrix) and len(matrix[0]), [] for l in range(m + n - 1): temp = [matrix[i][l - i] for i in range(max(0, l+1 - n), min(l+1, m))] r += temp if l % 2 else temp[::-1] return r 0 and 0 答案是 0，此处避免 matrix 为 [] 时导致报错 按照从右上角到左下角的顺序遍历 matrix 的所有对角线并放入列表 temp 如果 对角线元素个数 是偶数则应该把 temp 反转 把 temp 加入结果 r507. Perfect Number123class Solution: def checkPerfectNumber(self, num: int) -&gt; bool: return num in (6, 28, 496, 8128, 33550336, 8589869056, 137438691328, 2305843008139952128) 题目中给出了解的范围，且解的个数是固定的，因此可以提前计算出所有解557. Reverse Words in a String III 1行123class Solution: def reverseWords(self, s: str) -&gt; str: return &#x27; &#x27;.join(s.split(&#x27; &#x27;)[::-1])[::-1] 561. Array Partition I 1行123class Solution: def arrayPairSum(self, nums: List[int]) -&gt; int: return sum(sorted(nums)[::2]) 575. Distribute Candies 1行123class Solution: def distributeCandies(self, candies: List[int]) -&gt; int: return min(len(set(candies)), len(candies) // 2) 姐姐优先拿不同种类的糖果581. Shortest Unsorted Continuous Subarray 2行1234class Solution: def findUnsortedSubarray(self, nums: List[int]) -&gt; int: diff = [i for i, (a, b) in enumerate(zip(nums, sorted(nums))) if a != b] return len(diff) and max(diff) - min(diff) + 1 获取所有当前数组与排序后数组具有不同数值的索引，最右边的索引 - 最左边的 + 1 就是结果589. N-ary Tree Preorder Traversal 1行12345678910&quot;&quot;&quot;# Definition for a Node.class Node: def __init__(self, val=None, children=None): self.val = val self.children = children&quot;&quot;&quot;class Solution: def preorder(self, root: &#x27;Node&#x27;) -&gt; List[int]: return root and sum([[root.val], *map(self.preorder, root.children)], []) or [] 递归解法，利用 and or 控制递归叶节点和普通节点123456789101112131415161718&quot;&quot;&quot;# Definition for a Node.class Node: def __init__(self, val=None, children): self.val = val self.children = children&quot;&quot;&quot;class Solution: def preorder(self, root: &#x27;Node&#x27;) -&gt; List[int]: s = bool(root) * [root] r = [] while s: root = s.pop() r.append(root.val) s += root.children[::-1] return r 迭代解法 root 为 [] 时 bool 值为 False 同 0，乘法结果为 []，即可跳过 while root 非空时 dfs 栈式迭代 逆转 children 是由于栈的 FILO(先入后出) 特性 599. Minimum Index Sum of Two Lists 2行1234class Solution: def findRestaurant(self, list1: List[str], list2: List[str]) -&gt; List[str]: d = &#123;x: list1.index(x) + list2.index(x) for x in set(list1) &amp; set(list2)&#125; return [x for x in d if d[x] == min(d.values())] 使用字典记录｛共同喜欢的商店：索引和｝，返回索引和并列最小的商店名652. Find Duplicate Subtrees 8行1234567891011121314151617# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def findDuplicateSubtrees(self, root): d = collections.defaultdict(list) def dfs(root): if not root: return &#x27;&#x27; s = &#x27; &#x27;.join((str(root.val), dfs(root.left), dfs(root.right))) d[s].append(root) return s dfs(root) return [l[0] for l in d.values() if len(l) &gt; 1] 使用字典 d 记录｛子树结构：[root1，root2，……]｝658. Find K Closest Elements 2行123class Solution: def findClosestElements(self, arr: List[int], k: int, x: int) -&gt; List[int]: return sorted(heapq.nsmallest(k, arr, key=lambda n:(abs(n - x), n))) nsmallest 函数可以输出最小的N个数字，可参考这里12345678910class Solution: def findClosestElements(self, arr: List[int], k: int, x: int) -&gt; List[int]: l, h = 0, len(arr) - 1 while l &lt; h: m = (l + h) // 2 if arr[m] &gt;= x: h = m else: l = m + 1 return sorted(sorted(arr[max(0, l-k) : l+k], key=lambda y: abs(y - x))[:k]) 二分查找法700. Search in a Binary Search Tree 1行12345678910# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def searchBST(self, root: TreeNode, val: int) -&gt; TreeNode: return root and (root.val == val and root or self.searchBST((root.left, root.right)[root.val &lt; val], val)) 递归703. Kth Largest Element in a Stream 3行12345678910111213class KthLargest: def __init__(self, k: int, nums: List[int]): self.k, self.n = k, sorted(nums) def add(self, val: int) -&gt; int: self.n.insert(bisect.bisect_left(self.n, val, 0, len(self.n)), val) return self.n[-self.k]# Your KthLargest object will be instantiated and called as such:# obj = KthLargest(k, nums)# param_1 = obj.add(val) 首先对数组排序 每次插入新值时使用二分查找搜索插入位置，保持插入后数组的升序性质，那么就可以直接取第 k 大的值 时间复杂度 $O(T\\log N)$, 其中 T 代表插入次数 其实可以在每次插入之后丢弃小于第 k 大数据之后的所有数字，这样时间复杂度可以降为 $O(T\\log k)$ 进阶可使用堆：12345678910111213class KthLargest: def __init__(self, k: int, nums): self.k, self.nums = k, heapq.nlargest(k, nums + [float(&#x27;-inf&#x27;)]) heapq.heapify(self.nums) def add(self, val: int) -&gt; int: heapq.heappushpop(self.nums,val) return self.nums[0]# Your KthLargest object will be instantiated and called as such:# obj = KthLargest(k, nums)# param_1 = obj.add(val) 题目中提到 $len(nums) \\ge k-1$，因此我们加入一个无穷小使得 $len(nums) \\ge k$，以便构造一个 $k$ 尺寸的小根堆 堆中的数据意味着从第 $k$ 大的数字到最大的数字 维护堆的时间复杂度为 $O(T\\log k)$ 724. Find Pivot Index 4行123456class Solution: def pivotIndex(self, nums: List[int]) -&gt; int: l, r, diff = 0, 0, [0] * len(nums) for i, j in zip(range(len(nums)), range(len(nums) - 1, -1, -1)): diff[i] += l; l += nums[i]; diff[j] -= r; r += nums[j] return diff.index(0) if 0 in diff else -1 本题利用双指针，利用 i，j 双向遍历数组。 l 记录当前索引左边所有数字之和，r 记录右边的和 diff 记录当前索引左边所有数字之和 - 右边所有数字之和，中心索引左右和相等，diff[中心索引] 为 0733. Flood Fill 6行12345678class Solution: def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -&gt; List[List[int]]: if image[sr][sc] != newColor: # 根剪枝 old, image[sr][sc], m, n = image[sr][sc], newColor, len(image), len(image[0]) for i, j in zip((sr, sr+1, sr, sr-1), (sc+1, sc, sc-1, sc)): # 放入周围节点 if 0 &lt;= i &lt; m and 0 &lt;= j &lt; n and image[i][j] == old: # 邻剪枝 self.floodFill(image, i, j, newColor) return image 739. Daily Temperatures 5行1234567class Solution(object): def dailyTemperatures(self, T): stack, r = [], [0] * len(T) for i, t in enumerate(T): while stack and T[stack[-1]] &lt; t: r[stack.pop()] = i - stack[-1] stack.append(i) return r 入栈条件：当前元素比栈顶元素小，出栈条件：遇到比自己大的温度，出栈时索引距离即天数差744. Find Smallest Letter Greater Than Target1234class Solution: def nextGreatestLetter(self, letters: List[str], target: str) -&gt; str: l = [x &gt; target for x in letters] return letters[l.index(max(l))] 返回列表中大于 target 的第一个字符或第一个字符（如果没有比 target 大的字符）747. Largest Number At Least Twice of Others 2行1234class Solution: def dominantIndex(self, nums: List[int]) -&gt; int: a, b = ([0] + sorted(nums))[-2:] return (-1, nums.index(b))[b &gt;= 2 * a] 前面加个[0]防止数组长度不够 只要数组中第一大的数字不小于第二大数字的两倍即满足条件752. Open the Lock 11行12345678910111213class Solution: def openLock(self, deadends: List[str], target: str) -&gt; int: if &#x27;0000&#x27; in deadends: return -1 deadends, q = set(deadends), [(&#x27;0000&#x27;, 0)] while q: node, step = q.pop(0) for i, add in zip([*range(4)] * 2, [1] * 4 + [-1] * 4): cur = node[:i] + str((int(node[i]) + add) % 10) + node[i+1:] if cur == target: return step + 1 if not cur in deadends: q.append((cur, step + 1)) deadends.add(cur) return -1 为什么这题要用 BFS(广度优先搜索) ？根据题意，我们需要找到最少的解锁步数，这实际上可以认为是在图上搜索最短路径。BFS 总是优先搜索距离根节点近的节点，因此它搜索到的路径就是最短路径 以当前锁上的数字为根，所有能达到的数字为一阶邻域（子节点）进行搜索771. Jewels and Stones 1行123class Solution: def numJewelsInStones(self, J: str, S: str) -&gt; int: return sum(S.count(i) for i in J) 时间复杂度$O(N^2)$，另附$O(N)$解法（set内部实现为dict，in操作时间复杂度为$O(N)$） 1234class Solution: def numJewelsInStones(self, J: str, S: str) -&gt; int: j = set(J) return sum(s in j for s in S) 867. Transpose Matrix 1行123class Solution: def transpose(self, A: List[List[int]]) -&gt; List[List[int]]: return [*zip(*A)] 938. Range Sum of BST 1行12345678910# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def rangeSumBST(self, root: TreeNode, L: int, R: int) -&gt; int: return root and root.val * (L &lt;= root.val &lt;= R) + self.rangeSumBST(root.left, L, R) + self.rangeSumBST(root.right, L, R) or 0 953. Verifying an Alien Dictionary 1行123class Solution(object): def isAlienSorted(self, words, order): return words == sorted(words, key=lambda w: [order.index(x) for x in w]) 充分利用 python 序列比较的特点，sorted 的参数 key 可传入一个函数，sorted 函数会将每个元素作为输入，输入到 key 函数并获得返回值，整个序列将按此值的大小来排序。此处 key 函数为lambda w: [order.index(x) for x in w]，其为words中每个单词 word 返回一个 list，list 中每个元素为单词中字母 x 在 order 中的索引。比如当 order 为 ‘abcde……’ 时，单词 ‘cab’ 将返回 [3, 2, 1]。关于俩个 list 的大小比较，服从 python 序列比较的特性，请参考官方文档教程 5.8 节内容。 另外一个通用的方法是简单的数学计算，给每个单词赋予一个数字然后排序对比和原来的数组是否一致即可，每个字母的价值按字母表顺序，第几个就代表几，每进一位需要*10^-2避免冲突，比如字母表是abcde……，单词 cab 的价值就是 3 * 1 + 1 * 0.01 + 2 * 0.0001，价值越小的单词位置应该越靠前 1234class Solution: def isAlienSorted(self, words: List[str], order: str) -&gt; bool: d = &#123;c: i + 1 for i, c in enumerate(order)&#125; return sorted(words, key=lambda x: sum(d[c] * 10**(-2 * i) for i, c in enumerate(x))) == words 973. K Closest Points to Origin 1行123class Solution: def kClosest(self, points: List[List[int]], K: int) -&gt; List[List[int]]: return sorted(points, key=lambda x: x[0]**2 + x[1]**2)[:K] 1290. Convert Binary Number in a Linked List to Integer1234567891011# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def getDecimalValue(self, head: ListNode) -&gt; int: r = 0 while head: r, head = r &lt;&lt; 1 | head.val, head.next return r $O(N)$, 位运算专题探索 以上是一张互联网公司面试中经常考察的问题类型总结的思维导图，此栏目将根据 LeetCode 中文版探索板块给出的路线制作题解，各专栏将尽力覆盖各大知识要点并总结知识点和套路。相比于题库解析部分追求代码的绝对精简，本专题追求以高可读性呈现各大专题的常规思路，为后续的题库解析部分做铺垫。俩部分题目可能重复，但专题部分会有更详细的解析，且可能运用不同解法。 数据结构，说难也不难🌠 队列 &amp; 栈 【知识卡片】Python 有内置的高效模块实现队列/栈/优先队列：queue模块 栈一般使用 list 直接实现 Python 的 collections 模块提供的 双向队列 collections.deque 同时具有 栈 和 队列 的性质，也是一个不错的选择 ☄ 队列：先入先出的数据结构 【知识卡片】队列中的数据呈线性排列，就和“队列”这个名字一样，把它想象成排成一 队的人更容易理解。在队列中，处理总是从第一名开始往后进行，而新来的人只能排在队尾。像队列这种最先进去的数据最先被取来，即“先进先出”的结构，我们称为 First In First Out，简称 FIFO622. 设计循环队列1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283class MyCircularQueue: def __init__(self, k: int): &quot;&quot;&quot; Initialize your data structure here. Set the size of the queue to be k. :param k: :return: &quot;&quot;&quot; self.size = 0 self.max_size = k self.data = [0] * k self.front = self.rear = -1 def enQueue(self, value: int) -&gt; bool: &quot;&quot;&quot; Insert an element into the circular queue. Return true if the operation is successful. :param value: :return: &quot;&quot;&quot; if self.isFull(): return False if self.rear == -1: self.rear = self.front = 0 else: self.rear = (self.rear + 1) % self.max_size self.data[self.rear] = value self.size += 1 return True def deQueue(self) -&gt; bool: &quot;&quot;&quot; Delete an element from the circular queue. Return true if the operation is successful. :return: &quot;&quot;&quot; if self.isEmpty(): return False if self.front == self.rear: self.front = self.rear = -1 else: self.front = (self.front + 1) % self.max_size self.size -= 1 return True def Front(self) -&gt; int: &quot;&quot;&quot; Get the front item from the queue. :return: &quot;&quot;&quot; return self.data[self.front] if self.size != 0 else -1 def Rear(self) -&gt; int: &quot;&quot;&quot; Get the last item from the queue. :return: &quot;&quot;&quot; return self.data[self.rear] if self.size != 0 else -1 def isEmpty(self) -&gt; bool: &quot;&quot;&quot; Checks whether the circular queue is empty or not. :return: &quot;&quot;&quot; return self.size == 0 def isFull(self) -&gt; bool: &quot;&quot;&quot; Checks whether the circular queue is full or not. :return: &quot;&quot;&quot; return self.size == self.max_size# Your MyCircularQueue object will be instantiated and called as such:# obj = MyCircularQueue(k)# param_1 = obj.enQueue(value)# param_2 = obj.deQueue()# param_3 = obj.Front()# param_4 = obj.Rear()# param_5 = obj.isEmpty()# param_6 = obj.isFull() 此处为体现数据结构，直接使用list，list.pop(0)耗时较多，Python 有内置的高效模块实现队列/栈/优先队列：queue模块 ☄ 队列和广度优先搜索 【知识卡片】广度优先搜索 BFS 是一种对图进行搜索的算法。假设我们一开始位于某个顶点（即起点），此 时并不知道图的整体结构，而我们的目的是从起点开始顺着边搜索，直到到达指定顶点（即终 点）。在此过程中每走到一个顶点，就会判断一次它是否为终点。广度优先搜索会优先从离起点近的顶点开始搜索，这样由近及广的搜索方式也使得。根据 BFS 的特性，其常常被用于 遍历 和 搜索最短路径 【套路】BFS一般流程： 12345678910class Solution(object): def BFS(self): # 1.使用 queue.Queue 初始化队列 # 2.选择合适的根节点压入队列 # 3.使用 wile 进入队列循环，直到搜索完毕 # &#123; # 4.取出一个节点 # 5.放入这个节点周围的节点 # &#125; 使用 BFS 时，需要抓住 3 个关键点：根节点是什么？根节点的一阶邻域节点是哪些？什么时候停止搜索？200. 岛屿的个数1234567891011121314151617181920212223242526272829303132333435from queue import Queueclass Solution(object): def numIslands(self, grid): try: r = 0; m = len(grid); n = len(grid[0]) around = ((0, 1), (1, 0), (0, -1), (-1, 0)) except: return 0 for i in range(m): for j in range(n): if int(grid[i][j]): r += 1 #---------------------------BFS 开始----------------------------- # 把根节点投入队列 q = Queue() q.put((i, j)) # 开始循环 while not q.empty(): # 取出还未沉没的陆地节点并沉没陆地（防止下次遍历到的时候再算一遍） x, y = q.get() if int(grid[x][y]): grid[x][y] = &#x27;0&#x27; # 放入周围的陆地节点 for a, b in around: a += x; b += y; if 0 &lt;= a &lt; m and 0 &lt;= b &lt; n and int(grid[a][b]): q.put((a, b)) #---------------------------------------------------------------- return r BFS解法在这题很慢但是很常规 算法书中的 BFS 一般都是以树为例子介绍的，那么在本题中如何应用 BFS ？ 根据题意，我们可以把每一个陆地点当作树根，用 BFS 搜索四周的陆地并沉没它，那么这一整块的陆地都被沉没了，下次我们再遇到陆地点的时候就说明发现新大陆了 🙊752. 打开转盘锁1234567891011121314151617181920212223242526272829303132from queue import Queueclass Solution: def openLock(self, deadends: List[str], target: str) -&gt; int: deadends = set(deadends) # in 操作在set中时间复杂度为O(1) if &#x27;0000&#x27; in deadends: return -1 if target == &#x27;0000&#x27;: return 0 # -------------------------------BFS 开始---------------------------------- # 初始化根节点 q = Queue() q.put((&#x27;0000&#x27;, 0)) # (当前节点值，转动步数) # 开始循环队列 while not q.empty(): # 取出一个节点 node, step = q.get() # 放入周围节点 for i in range(4): for add in (1, -1): cur = node[:i] + str((int(node[i]) + add) % 10) + node[i+1:] if cur == target: return step + 1 if not cur in deadends: q.put((cur, step + 1)) deadends.add(cur) # 避免重复搜索 # ------------------------------------------------------------------------- return -1 为什么这题要用 BFS(广度优先搜索) ？根据题意，我们需要找到最少的解锁步数，这实际上可以认为是在图上搜索最短路径。BFS 总是优先搜索距离根节点近的节点，因此它搜索到的路径就是最短路径 以当前锁上的数字为根，所有能达到的数字为一阶邻域（子节点）进行搜索279. 完全平方数1234567891011121314151617181920212223242526272829303132333435from queue import Queueclass Solution: def numSquares(self, n: int) -&gt; int: around = [] for i in range(1, n + 1): if i**2 &lt;= n: around.append(i**2) else: break; r = 0 seen = set() # 防止重复运算 # ----------------BFS 开始---------------------- # 初始化根节点 q = Queue() q.put((0, r)) # 进入队列循环 while not q.empty(): # 取出一个元素 cur, step = q.get() step += 1 # 放入周围元素 for a in around: a += cur if a == n: return step if a &lt; n and (a, step) not in seen: seen.add((a, step)) q.put((a, step)) # ---------------------------------------------- return 0 将当前数字的总和视为节点，加上一个完全平方数后能达到的数字作为一阶邻域，搜索到达 n 的最短路径 ☄ 栈：后入先出的数据结构 【知识卡片】栈也是一种数据呈线性排列的数据结构，不过在这种结构中，我们只能访问最新添加的数 据。栈就像是一摞书，拿到新书时我们会把它放在书堆的最上面，取书时也只能从最上面的新书开始取。Last In First Out，简称 LIFO，常常被用于数组中不同位置之间含有 嵌套关系 的题目 【套路】栈问题关键点： 解决栈问题时，主要是需要确定入栈和出栈（从栈顶弹出）的条件 通常来说栈内储存的元素都是同一类元素，在某个层面上有共同的性质 嵌套关系是指出栈时得到的栈顶元素与当前判断是否入栈元素的关系，以此作为切入点套入计算题目结果所需的俩个元素是涉及栈的关键155. 最小栈123456789101112131415161718192021222324252627class MinStack: def __init__(self): &quot;&quot;&quot; initialize your data structure here. &quot;&quot;&quot; self.data = [(None, float(&#x27;inf&#x27;))] def push(self, x: int) -&gt; None: self.data.append((x, min(x, self.data[-1][1]))) def pop(self) -&gt; None: if len(self.data) &gt; 1: self.data.pop() def top(self) -&gt; int: return self.data[-1][0] def getMin(self) -&gt; int: return self.data[-1][1]# Your MinStack object will be instantiated and called as such:# obj = MinStack()# obj.push(x)# obj.pop()# param_3 = obj.top()# param_4 = obj.getMin() 栈中每个元组记录元素值和最小值20. 有效的括号123456789101112class Solution: def isValid(self, s: str) -&gt; bool: stack = [] d = &#123;&#x27;(&#x27;: &#x27;)&#x27;, &#x27;[&#x27;: &#x27;]&#x27;, &#x27;&#123;&#x27;: &#x27;&#125;&#x27;&#125; for p in s: if p in &#x27;&#123;[(&#x27;: stack.append(p) else: if not stack or d[stack.pop()] != p: return False return not stack 此题入栈条件为：元素是左括号，出栈条件为：匹配到右括号 栈中的元素全部为左括号739. 每日温度1234567891011class Solution(object): def dailyTemperatures(self, T): stack = [] r = [0] * len(T) for i, t in enumerate(T): while stack and T[stack[-1]] &lt; t: c = stack.pop() r[c] = i - c stack.append(i) return r 入栈条件：当前元素比栈顶元素小，出栈条件：遇到比自己大的温度 栈内元素为降序排列的温度的索引 出栈时索引距离即天数差150. 逆波兰表达式求值123456789101112131415class Solution: def evalRPN(self, tokens: List[str]) -&gt; int: # 初始化栈，用栈储存未处理的数字 stack = [] # 遍历元素 for t in tokens: if not t in &#x27;+-*/&#x27;: # 规定入栈条件 stack.append(int(t)) else: # 出栈：从栈顶弹出元素与新的栈顶做运算 a = stack.pop() stack[-1] = int(eval(str(stack[-1]) + t + &#x27;a&#x27;)) return stack[-1] 使用栈储存所有未处理的数字 出栈时，我们总是将出栈元素与新的栈顶做运算，然后用结果更新新栈顶元素 ☄ 栈和深度优先搜索 【知识卡片】深度优先搜索 DFS 和广度优先搜索一样，都是对图进行搜索的算法，目的也都是从起点开始搜索直到到达指定顶点（终点）。深度优先搜索会沿着一条路径不断往下搜索直到不能再继续为止，然后再折返，开始搜索下一条候补路径。正如树的遍历中所提到的，我们可以用 DFS 进行 前序遍历，中序遍历 和 后序遍历。在这三个遍历顺序中有一个共同的特性：除非我们到达最深的结点，否则我们永远不会回溯200. 岛屿的个数1234567891011121314151617181920212223class Solution: def numIslands(self, grid: List[List[str]]) -&gt; int: try: m = len(grid) n = len(grid[0]) except: return 0 # -------------------------DFS 开始------------------------ # 定义dfs递归方程 def dfs(i, j): if 0 &lt;= i &lt; m and 0 &lt;= j &lt; n and int(grid[i][j]): grid[i][j] = &#x27;0&#x27; for a, b in ((1, 0), (0, -1), (-1, 0), (0, 1)): dfs(i + a, j + b) # --------------------------------------------------------- r = 0 for i in range(m): for j in range(n): r += int(grid[i][j]) dfs(i, j) # 调用dfs沉没一整块陆地 return r 遍历所有格点，每当发现陆地就用dfs递归沉没它周围的陆地，那么我们发现陆地的次数就是岛屿数133. 克隆图1234567891011121314151617181920&quot;&quot;&quot;# Definition for a Node.class Node: def __init__(self, val, neighbors): self.val = val self.neighbors = neighbors&quot;&quot;&quot;class Solution: def cloneGraph(self, node: &#x27;Node&#x27;) -&gt; &#x27;Node&#x27;: d = &#123;&#125; def dfs(old): if old not in d: # 每遍历一个节点就创建一个它的副本到哈希表 d[old] = new = Node(old.val, None) # 当所有节点进入哈希表之时开始回溯，修改邻居 new.neighbors = [*map(dfs, old.neighbors)] return d[old] return dfs(node) 此题为无向连通图的搜索，用dfs遍历整个图，并为每个节点创建副本到哈希表，当回溯之时，所有节点已经在表中，修改邻居即可494. 目标和123456789class Solution: def findTargetSumWays(self, nums: List[int], S: int) -&gt; int: def dfs(cur, i, d = &#123;&#125;): if i &lt; len(nums) and (i, cur) not in d: # 搜索周围节点 d[(i, cur)] = dfs(cur + nums[i], i + 1) + dfs(cur - nums[i], i + 1) return d.get((i, cur), int(cur == S)) return dfs(0, 0) dfs遍历所有可能结果，以当前位置 i 和当前总和 cur 为根节点，以下一位数字的加减为邻域扩散搜索 利用 d 构造记忆，以便剪枝（搜索过程中遇到相同位置和相同cur值时返回值应该相同） dfs中 d 参数传的是引用，所以只有第一次会采用默认值 &#123;&#125;94. 二叉树的中序遍历12345678910111213141516171819202122232425# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def inorderTraversal(self, root: TreeNode) -&gt; List[int]: r = [] # 初始化栈 stack = [] # 进入堆栈循环 while stack or root: if root: # 入栈条件 stack.append(root) root = root.left else: # 出栈条件 root = stack.pop() r.append(root.val) root = root.right return r ☄ 小结 【套路】迭代形 BFS/DFS 12345678910class Solution(object): def BFS(self): # 1.BFS 使用 queue.Queue, DFS 使用 queue.LifoQueue # 2.选择合适的根节点压入队列 # 3.使用 wile 进入循环，直到搜索完毕 # &#123; # 4.取出一个节点 # 5.放入这个节点周围的节点 # &#125; 【套路】递归形 DFS 12345678class Solution: def dfs(self, root): if ...: # 根剪枝 root = ... # 根处理 for node in around: # 放入周围节点 if node == ...: # 邻剪枝 self.dfs(node) # 递归 return image # 终止返回 232. 用栈实现队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class MyQueue: def __init__(self): &quot;&quot;&quot; Initialize your data structure here. &quot;&quot;&quot; self.stack = [] def push(self, x: int) -&gt; None: &quot;&quot;&quot; Push element x to the back of queue. &quot;&quot;&quot; self.stack.append(x) def pop(self) -&gt; int: &quot;&quot;&quot; Removes the element from in front of queue and returns that element. &quot;&quot;&quot; temp = [] while self.stack: temp.append(self.stack.pop()) r = temp.pop() while temp: self.stack.append(temp.pop()) return r def peek(self) -&gt; int: &quot;&quot;&quot; Get the front element. &quot;&quot;&quot; temp = [] while self.stack: temp.append(self.stack.pop()) r = temp[-1] while temp: self.stack.append(temp.pop()) return r def empty(self) -&gt; bool: &quot;&quot;&quot; Returns whether the queue is empty. &quot;&quot;&quot; return not self.stack# Your MyQueue object will be instantiated and called as such:# obj = MyQueue()# obj.push(x)# param_2 = obj.pop()# param_3 = obj.peek()# param_4 = obj.empty() 使用俩个栈来模拟队列，当需要取第一个元素的时候创建一个临时的栈temp，把栈里面的东西全部抽出来放进temp，完成操作后放回去225. 用队列实现栈1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from queue import Queueclass MyStack: def __init__(self): &quot;&quot;&quot; Initialize your data structure here. &quot;&quot;&quot; self.q = Queue() def push(self, x: int) -&gt; None: &quot;&quot;&quot; Push element x onto stack. &quot;&quot;&quot; self.q.put(x) def pop(self) -&gt; int: &quot;&quot;&quot; Removes the element on top of the stack and returns that element. &quot;&quot;&quot; for _ in range(self.q.qsize() - 1): self.q.put(self.q.get()) return self.q.get() def top(self) -&gt; int: &quot;&quot;&quot; Get the top element. &quot;&quot;&quot; for _ in range(self.q.qsize() - 1): self.q.put(self.q.get()) r = self.q.get() self.q.put(r) return r def empty(self) -&gt; bool: &quot;&quot;&quot; Returns whether the stack is empty. &quot;&quot;&quot; return self.q.empty()# Your MyStack object will be instantiated and called as such:# obj = MyStack()# obj.push(x)# param_2 = obj.pop()# param_3 = obj.top()# param_4 = obj.empty() 弹栈顶的时候把队列遍历一遍，每次弹出之后加入队尾，除了最后一个394. 字符串解码1234567891011121314151617class Solution: def decodeString(self, s: str) -&gt; str: stack = [[&#x27;&#x27;, 1, &#x27;&#x27;]] a = n = &#x27;&#x27; for c in s: if c.isalpha(): a += c elif c.isdigit(): n += c elif c == &#x27;[&#x27;: stack.append([a, int(n), &#x27;&#x27;]) a = n = &#x27;&#x27; else: p, t, b = stack.pop() stack[-1][-1] += p + t * (b + a) a = &#x27;&#x27; return stack.pop()[-1] + a 用 stack 记录（[]之前的字母，翻倍次数，翻倍内容）733. 图像渲染123456789101112131415161718192021class Solution: def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -&gt; List[List[int]]: m, n = map(len, (image, image[0])) around = ((1, 0), (0, 1), (-1, 0), (0, -1)) oldColor = image[sr][sc] # 创建栈放入根节点 stack = [(sr, sc)] # 进入循环放入邻居 while stack: r, c = stack.pop() if oldColor != newColor: # 根剪枝 image[r][c] = newColor for x, y in around: x, y = x + r, y + c if 0 &lt;= x &lt; m and 0 &lt;= y &lt; n and image[x][y] == oldColor: # 邻剪枝 image[x][y] = newColor stack.append((x, y)) return image 542. 01 矩阵12345678910111213141516171819202122232425262728class Solution: def updateMatrix(self, matrix: List[List[int]]) -&gt; List[List[int]]: m, n = len(matrix), len(matrix[0]) r = [[0] * n for _ in range(m)] around = ((0, 1), (1, 0), (0, -1), (-1, 0)) for i in range(m): for j in range(n): # -------------------------BFS 开始-------------------------- # 放入根节点 q = collections.deque([(i, j, 0)]) seen = &#123;(i, j)&#125; # 循环取节点 while q: a, b, t = q.popleft() if not matrix[a][b]: r[i][j] = t break # 放入邻节点 for x, y in around: x, y = x + a, y + b if 0 &lt;= x &lt; m and 0 &lt;= y &lt; n and (x, y) not in seen: seen.add((x, y)) q.append((x, y, t + 1)) # ---------------------------------------------------------- return r 以当前位置为根，四周为邻，bfs求最短路径，t记录路径长度841. 钥匙和房间1234567891011121314151617class Solution: def canVisitAllRooms(self, rooms: List[List[int]]) -&gt; bool: seen = &#123;0&#125; # 创建队列放入根节点 q = [0] # 循环取节点 while q: cur = q.pop(0) # 放入周围节点 for i in set(rooms[cur]): if i not in seen: # 剪枝 seen.add(i) q.append(i) return len(seen) == len(rooms) 🌠 数组和字符串☄ 数组简介 【套路】数组问题必备锦囊： 有些题目在做题之前对数组排序往往可以简化解法 数组与字符串大体相似但在细节上会有不同，有时候相互转化可以简化问题724. 寻找数组的中心索引123456789class Solution: def pivotIndex(self, nums: List[int]) -&gt; int: l, r, diff = 0, 0, [0] * len(nums) for i, j in zip(range(len(nums)), range(len(nums) - 1, -1, -1)): diff[i] += l l += nums[i] diff[j] -= r r += nums[j] return diff.index(0) if 0 in diff else -1 本题利用双指针，利用 i，j 双向遍历数组。 l 记录当前索引左边所有数字之和，r 记录右边的和 diff 记录当前索引左边所有数字之和 - 右边所有数字之和，中心索引左右和相等，diff[中心索引] 为 0747. 至少是其他数字两倍的最大数123456class Solution: def dominantIndex(self, nums: List[int]) -&gt; int: m = max(nums) r = nums.index(m) nums.remove(m) return (-1, r)[not nums or m &gt;= 2 * max(nums)] 只要数组中第一大的数字不小于第二大数字的两倍即满足条件 2行排序解法 → 戳这里66. 加一123class Solution: def plusOne(self, digits: List[int]) -&gt; List[int]: return list(map(int, str(int(&#x27;&#x27;.join(map(str, digits))) + 1))) ☄ 二维数组简介 498. 对角线遍历1234567class Solution: def findDiagonalOrder(self, matrix: List[List[int]]) -&gt; List[int]: m, n, r = len(matrix), len(matrix) and len(matrix[0]), [] for l in range(m + n - 1): temp = [matrix[i][l - i] for i in range(max(0, l+1 - n), min(l+1, m))] r += temp if l % 2 else temp[::-1] return r 0 and 0 答案是 0，此处避免 matrix 为 [] 时导致报错 按照从右上角到左下角的顺序遍历 matrix 的所有对角线并放入列表 temp 如果 对角线元素个数 是偶数则应该把 temp 反转 把 temp 加入结果 r54. 螺旋矩阵123class Solution: def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]: return matrix and [*matrix.pop(0)] + self.spiralOrder([*zip(*matrix)][::-1]) 流程图： 123|1 2 3| |6 9| |8 7| |4| =&gt; |5| =&gt; | ||4 5 6| =&gt; |5 8| =&gt; |5 4| =&gt; |5||7 8 9| |4 7| 为什么是[*matrix.pop(0)]而不是matrix.pop(0)？因为对于后面的递归，传进来的列表中元素是tuple118. 杨辉三角123456class Solution: def generate(self, numRows: int) -&gt; List[List[int]]: r = [[1]] for i in range(1, numRows): r.append([1] + [sum(r[-1][j:j+2]) for j in range(i)]) return numRows and r or [] ☄ 字符串简介 67. 二进制求和1234567891011class Solution: def addBinary(self, a: str, b: str) -&gt; str: r, p = &#x27;&#x27;, 0 d = len(b) - len(a) a = &#x27;0&#x27; * d + a b = &#x27;0&#x27; * -d + b for i, j in zip(a[::-1], b[::-1]): s = int(i) + int(j) + p r = str(s % 2) + r p = s // 2 return &#x27;1&#x27; + r if p else r 此处利用了 python 的字符串乘法28. 实现strStr()123class Solution: def strStr(self, haystack: str, needle: str) -&gt; int: return haystack.find(needle) 不用内置函数也可以 123456class Solution: def strStr(self, haystack: &#x27;str&#x27;, needle: &#x27;str&#x27;) -&gt; &#x27;int&#x27;: for i in range(0, len(haystack) - len(needle) + 1): if haystack[i:i+len(needle)] == needle: return i return -1 14. 最长公共前缀 1234class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: r = [len(set(c)) == 1 for c in zip(*strs)] + [0] return strs[0][:r.index(0)] if strs else &#x27;&#x27; 利用好zip和set os 模块有提供一样的函数 123class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: return os.path.commonprefix(strs) ☄ 双指针技巧 【知识卡片】双指针 通常，我们只使用从第一个元素开始并在最后一个元素结束的一个指针来进行迭代。 但是，有时候，我们可能需要同时使用两个指针来进行迭代。 两个指针从 不同位置 出发：一个从始端开始，另一个从末端开始 双向内缩 二分夹逼 两个指针以 不同速度 移动：一个指针快一些，另一个指针慢一些 快慢指针 滑动窗口344. 反转字符串12345678910class Solution: def reverseString(self, s: List[str]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify s in-place instead. &quot;&quot;&quot; i, j = 0, len(s) - 1 while i &lt; j: s[i], s[j] = s[j], s[i] i += 1 j -= 1 561. 数组拆分 I123class Solution: def arrayPairSum(self, nums: List[int]) -&gt; int: return sum(sorted(nums)[::2]) 167. 两数之和 II - 输入有序数组123456789class Solution: def twoSum(self, numbers: List[int], target: int) -&gt; List[int]: i, j = 0, len(numbers) - 1 while numbers[i] + numbers[j] != target: if numbers[i] + numbers[j] &gt; target: j -= 1 else: i += 1 return [i+1, j+1] 27. 移除元素12345678class Solution: def removeElement(self, nums: List[int], val: int) -&gt; int: j = 0 for i in range(len(nums)): if val != nums[i]: nums[j] = nums[i] j += 1 return j 485. 最大连续1的个数12345678910class Solution: def findMaxConsecutiveOnes(self, nums: List[int]) -&gt; int: r = c = 0 for n in nums: if n: c += 1 else: r = max(r, c) c = 0 return max(r, c) 209. 长度最小的子数组12345678910class Solution: def minSubArrayLen(self, s: int, nums: List[int]) -&gt; int: i, a, r = 0, 0, float(&#x27;inf&#x27;) for j in range(len(nums)): a += nums[j] while a &gt;= s: r = min(r, j - i + 1) a -= nums[i] i += 1 return 0 if r == float(&#x27;inf&#x27;) else r i, j 双指针滑窗，$O(N)$时间复杂度，$O(1)$空间复杂度 a 代表 i 到 j 的总和 ☄ 小结 189. 旋转数组123456class Solution: def rotate(self, nums: List[int], k: int) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. &quot;&quot;&quot; for _ in range(k % len(nums)): nums[-1:], nums[:0] = [], nums[-1:] 时间复杂度 = $O(k \\% len(nums))$，空间复杂度 = $O(1)$119. 杨辉三角 II123456class Solution: def getRow(self, rowIndex: int) -&gt; List[int]: r = [1] for i in range(1, rowIndex + 1): r = [1] + [sum(r[j:j+2]) for j in range(i)] return r 跟 杨辉三角 I 没什么差别151. 翻转字符串里的单词123class Solution: def reverseWords(self, s: str) -&gt; str: return &quot; &quot;.join(s.split()[::-1]) python 的 split 中的分隔符，默认为所有的空字符，包括空格、换行(\\n)、制表符(\\t)等557. 反转字符串中的单词 III123class Solution: def reverseWords(self, s: str) -&gt; str: return &#x27; &#x27;.join(s.split()[::-1])[::-1] 26. 删除排序数组中的重复项12345678class Solution: def removeDuplicates(self, nums: List[int]) -&gt; int: i = 0 for j in range(1, len(nums)): if nums[j] != nums[i]: i += 1 nums[i] = nums[j] return len(nums) and i + 1 数组完成排序后，我们可以放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。只要 nums[i] = nums[j]，我们就增加 j 以跳过重复项。当我们遇到 nums[j] != nums[i]时，跳过重复项的运行已经结束，因此我们必须把它（nums[j]）的值复制到 nums[i + 1]。然后递增 i，接着我们将再次重复相同的过程，直到 j 到达数组的末尾为止283. 移动零12345678910111213class Solution: def moveZeroes(self, nums: List[int]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. &quot;&quot;&quot; i = 0 for j in range(len(nums)): if nums[j]: nums[i] = nums[j] i += 1 while i &lt; len(nums): nums[i] = 0 i += 1 🌠 链表 【知识卡片】链表是数据结构之一，其中的数据呈线性排列。在链表中，数据的添加和删除都较为方便， 就是访问比较耗费时间。实际上，相比较数组来说，并不存在链表这样一个对象，链表是由多个节点组成的，因此，我们能接触到的数据对象只有节点。我们可以根据节点来寻找周围节点，许多节点之间的关系抽象地构成了一个链表。 ☄ 单链表 707. 设计链表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class Node: def __init__(self, v, p=None, n=None): self.val = v self.prev = p self.next = nclass MyLinkedList: def __init__(self): &quot;&quot;&quot; Initialize your data structure here. &quot;&quot;&quot; self.key = Node(-1) self.key.prev = self.key.next = self.key def get(self, index: int) -&gt; int: &quot;&quot;&quot; Get the value of the index-th node in the linked list. If the index is invalid, return -1. &quot;&quot;&quot; i, node = 0, self.key.next while i &lt; index and node != self.key: node = node.next i += 1 return node.val if index &gt;= 0 else -1 def addAtHead(self, val: int) -&gt; None: &quot;&quot;&quot; Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. &quot;&quot;&quot; self.key.next.prev = self.key.next = Node(val, p=self.key, n=self.key.next) def addAtTail(self, val: int) -&gt; None: &quot;&quot;&quot; Append a node of value val to the last element of the linked list. &quot;&quot;&quot; self.key.prev.next = self.key.prev = Node(val, p=self.key.prev, n=self.key) def addAtIndex(self, index: int, val: int) -&gt; None: &quot;&quot;&quot; Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. &quot;&quot;&quot; index = max(0, index) i, node = 0, self.key.next while i &lt; index and node != self.key: node = node.next i += 1 if node != self.key or i == index: node.prev.next = node.prev = Node(val, p=node.prev, n=node) def deleteAtIndex(self, index: int) -&gt; None: &quot;&quot;&quot; Delete the index-th node in the linked list, if the index is valid. &quot;&quot;&quot; if index &lt; 0: return i, node = 0, self.key.next while i &lt; index and node != self.key: node = node.next i += 1 if node != self.key: node.prev.next = node.next node.next.prev = node.prev del node# Your MyLinkedList object will be instantiated and called as such:# obj = MyLinkedList()# param_1 = obj.get(index)# obj.addAtHead(val)# obj.addAtTail(val)# obj.addAtIndex(index,val)# obj.deleteAtIndex(index) 本题构建了一个双向的环形链表，记录 key 节点，key.next 指向链表的 head，key.prev 指向链表的 tail ☄ 双指针技巧 141. 环形链表123456789101112131415# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def hasCycle(self, head): slow = fast = head while fast and fast.next: fast = fast.next.next slow = slow.next if slow == fast: return True return False 想象一下，有两个速度不同的跑步者。如果他们在直路上行驶，快跑者将首先到达目的地。但是，如果它们在圆形跑道上跑步，那么快跑者如果继续跑步就会追上慢跑者。这正是我们在链表中使用两个速度不同的指针时会遇到的情况： 如果没有环，快指针将停在链表的末尾。 如果有环，快指针最终将与慢指针相遇。 所以剩下的问题是：这两个指针的适当速度应该是多少？一个安全的选择是每次移动慢指针一步，而移动快指针两步。每一次迭代，快速指针将额外移动一步。如果环的长度为 M，经过 M 次迭代后，快指针肯定会多绕环一周，并赶上慢指针。142. 环形链表 II1234567891011121314class Solution(object): def detectCycle(self, head): slow = fast = head while fast and fast.next: fast = fast.next.next slow = slow.next if slow == fast: break else: return None while head is not slow: head = head.next slow = slow.next return head 设环的起始节点为 E，快慢指针从 head 出发，快指针速度为 2，设相交节点为 X，head 到 E 的距离为 H，E 到 X 的距离为 D，环的长度为 L，那么有：快指针走过的距离等于慢指针走过的距离加快指针多走的距离（多走了 n 圈的 L） 2(H + D) = H + D + nL，因此可以推出 H = nL - D，这意味着如果我们让俩个慢指针一个从 head 出发，一个从 X 出发的话，他们一定会在节点 E 相遇 12345 _____ / \\head___________E \\ \\ / X_____/ 160. 相交链表123456789101112131415# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def getIntersectionNode(self, headA, headB): &quot;&quot;&quot; :type head1, head1: ListNode :rtype: ListNode &quot;&quot;&quot; a, b = (headA, headB) if headA and headB else (None, None) while a != b: a, b = not a and headB or a.next, not b and headA or b.next return a 这题不支持 Python3 所以只能用 Python2 做了 把第一条链表的尾部接到第二条链表的开头，第二条接到第一条的开头，就能消除俩条链表的长度差，并在某一时刻在第一个交叉点相遇，或在走完俩条链表长度的时候同时为 None 1234# 假设有两条链表1→2→3→4和①→②→③，模拟一下算法流程 ↓1 → 2 ↘ ↗ → 4 1 → 2 ↘ ↗ → 4 → ① → → → 3(②) ❤ 相遇了① → → → 3(②) → ③ 把4接到①前面，把③接到1前面 ① → → → 3(②) → ③ → 1 → 2 ↗ 若非相交链表则同时走到None 19. 删除链表的倒数第N个节点123456789101112131415161718# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode: link = [] while head: link.append(head) head = head.next if n != len(link): link[-n - 1].next = link[-n].next del link[-n] return link and link[0] 列表记录整个链表，换成队列记录最后几个可以把空间复杂度压到 $O(1)$ ☄ 经典问题 206. 反转链表123456789101112# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def reverseList(self, head: ListNode) -&gt; ListNode: p = None while head: head.next, head, p = p, head.next, head return p 遍历一遍链表，每次都把相邻节点的指向反转（A→B 变成 A←B）203. 移除链表元素1234567891011121314151617# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def removeElements(self, head: ListNode, val: int) -&gt; ListNode: while head and head.val == val: head = head.next pre, cur = head, head and head.next while cur: if cur.val == val: pre.next = cur = cur.next else: pre, cur = cur, cur.next return head 第一个 while 用于找到应该返回的链表头（应该跳过所有特殊 val 的节点） 第二个 while 用于把前一个节点指针接到下一个节点（如果当前节点值为 val）328. 奇偶链表1234567891011121314# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def oddEvenList(self, head: ListNode) -&gt; ListNode: if not head or not head.next: return head r, odd, p, head = head, head, head.next, head.next.next while head: odd.next, head.next, p.next = head, odd.next, head.next p, odd, head = p.next, head, p.next and p.next.next return r odd 记录上一个奇数位节点，p 记录前一个节点 从第3个位置开始循环，每次都把当前节点接到 odd 后面，然后跳到下一个奇数位节点继续循环234. 回文链表123456789101112131415# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def isPalindrome(self, head: ListNode) -&gt; bool: s, f, p = head, head, None while f and f.next: s.next, p, s, f = p, s, s.next, f.next.next if f: s = s and s.next while s and p and s.val == p.val: p, s = p.next, s.next return s == p == None f 记录快指针，每次走倆步，s 记录慢指针，每次走一步，p 记录 s 的前一个节点 首先使用快慢指针找到中点，第一个 while 停止时如果链表长度为奇数，s 为中点；否则 f 为 None，s 为右半部分的第一个节点 若链表长度为奇数，s 前进一步，然后 p 和 s 往俩个方向同时遍历比对是否回文 ☄ 双链表 【设计链表】 同上 ☄ 小结 21. 合并两个有序链表123456789101112# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode: if l1 and l2: if l1.val &gt; l2.val: l1, l2 = l2, l1 l1.next = self.mergeTwoLists(l1.next, l2) return l1 or l2 and：如果 and 前面的表达式已经为 False，那么 and 之后的表达式将被 跳过，返回左表达式结果 or：如果 or 前面的表达式已经为 True，那么 or 之后的表达式将被跳过，直接返回左表达式的结果 例子：[] and 7 等于 [] 判断 l1 或 l2 中是否有一个节点为空，如果存在，那么我们只需要把不为空的节点接到链表后面即可 对 l1 和 l2 重新赋值，使得 l1 指向比较小的那个节点对象 修改 l1 的 next 属性为递归函数返回值 返回 l1，注意：如果 l1 和 l2 同时为 None，此时递归停止返回 None 时间复杂度：$O(n)$ 空间复杂度：【考虑递归开栈】$O(n)$【不考虑】$O(1)$2. 两数相加12345678910111213# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode, carry=0) -&gt; ListNode: if not (l1 or l2): return ListNode(1) if carry else None l1, l2 = l1 or ListNode(0), l2 or ListNode(0) val = l1.val + l2.val + carry l1.val, l1.next = val % 10, self.addTwoNumbers(l1.next, l2.next, val &gt; 9) return l1 int(True) 等于 1 None or 7 等于 7 用 carry 记录是否应该进位430. 扁平化多级双向链表123456789101112131415161718192021222324252627&quot;&quot;&quot;# Definition for a Node.class Node: def __init__(self, val, prev, next, child): self.val = val self.prev = prev self.next = next self.child = child&quot;&quot;&quot;class Solution: def flatten(self, head: &#x27;Node&#x27;) -&gt; &#x27;Node&#x27;: stack = [head] if head else [] p = None while stack: node = stack.pop() if node.next: stack.append(node.next) if node.child: stack.append(node.child) if p: p.next = node node.prev = p p.child = node.child = None p = node return head 常规 DFS 遍历138. 复制带随机指针的链表1234567891011121314151617181920212223&quot;&quot;&quot;# Definition for a Node.class Node: def __init__(self, val, next, random): self.val = val self.next = next self.random = random&quot;&quot;&quot;class Solution: def copyRandomList(self, head: &#x27;Node&#x27;) -&gt; &#x27;Node&#x27;: d, node = &#123;None: None&#125;, head while node: d[node] = Node(node.val, None, None) node = node.next node = head while node: d[node].next = d[node.next] d[node].random = d[node.random] node = node.next return d[head] 难点在于创建节点的时候需要指向未创建的节点 遍历俩遍可有效解决，用字典记录对应的节点，然后依靠原来的链表来遍历新链表，第一次遍历未知的节点置 None，第二次再把已经创建的节点改上去 链表也是图，133题的dfs解法同样可行61. 旋转链表123456789101112131415161718# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def rotateRight(self, head: ListNode, k: int) -&gt; ListNode: l = [] while head: l.append(head) head = head.next if l: l[-1].next, l[-1 - k % len(l)].next = l[0], None return l[- k % len(l)] return None 用 list 记录链表，把链表当作环，修补原来的切断口，创造新的缺口（k）🌠 哈希表 【知识卡片】在哈希表中，我们可以利用哈希函数快速访问到数组中的目标数据。如果发生哈希 冲突，就使用链表进行存储。这样一来，不管数据量为多少，我们都能够灵活应对。 如果数组的空间太小，使用哈希表的时候就容易发生冲突，线性查找的使用频率也会更高；反过来，如果数组的空间太大，就会出现很多空箱子，造成内存的浪费。因此， 给数组设定合适的空间非常重要。 ☄ 设计哈希表 705. 设计哈希集合1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Node: def __init__(self, val, nex): self.val = val self.nex = nexclass MyHashSet: def __init__(self): &quot;&quot;&quot; Initialize your data structure here. &quot;&quot;&quot; self.size = 1000 self.h = [Node(None, None) for _ in range(self.size)] def add(self, key: int) -&gt; None: p = self.h[key % self.size] node = p.nex while node: if node.val == key: break p = node node = node.nex else: p.nex = Node(key, None) def remove(self, key: int) -&gt; None: p = self.h[key % self.size] node = p.nex while node: if node.val == key: p.nex = node.nex break p = node node = node.nex def contains(self, key: int) -&gt; bool: &quot;&quot;&quot; Returns true if this set contains the specified element &quot;&quot;&quot; node = self.h[key % self.size] while node: if node.val == key: return True node = node.nex return False# Your MyHashSet object will be instantiated and called as such:# obj = MyHashSet()# obj.add(key)# obj.remove(key)# param_3 = obj.contains(key) 在存储数据的过程中，如果发生冲突，可以利用链表在已有数据的后面插入新数据 来解决冲突。这种方法被称为“链地址法”706. 设计哈希映射12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Node: def __init__(self, key=None, val=None, nex=None): self.key = key self.val = val self.nex = nexclass MyHashMap: def __init__(self): &quot;&quot;&quot; Initialize your data structure here. &quot;&quot;&quot; self.size = 1000 self.h = [Node() for _ in range(self.size)] def put(self, key: int, value: int) -&gt; None: &quot;&quot;&quot; value will always be non-negative. &quot;&quot;&quot; p = self.h[key % self.size] c = p.nex while c: if c.key == key: c.val = value break p = c c = c.nex else: p.nex = Node(key, value) def get(self, key: int) -&gt; int: &quot;&quot;&quot; Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key &quot;&quot;&quot; c = self.h[key % self.size] while c: if c.key == key: return c.val c = c.nex return -1 def remove(self, key: int) -&gt; None: &quot;&quot;&quot; Removes the mapping of the specified value key if this map contains a mapping for the key &quot;&quot;&quot; p = self.h[key % self.size] c = p.nex while c: if c.key == key: p.nex = c.nex break p = c c = c.nex# Your MyHashMap object will be instantiated and called as such:# obj = MyHashMap()# obj.put(key,value)# param_2 = obj.get(key)# obj.remove(key) ☄ 实际应用 - 哈希集合 217. 存在重复元素123class Solution: def containsDuplicate(self, nums: List[int]) -&gt; bool: return len(set(nums)) != len(nums) 136. 只出现一次的数字1234class Solution: def singleNumber(self, nums: List[int]) -&gt; int: from functools import reduce return reduce(int.__xor__, nums) 这里用到了异或（xor），相同的数字异或后为0，0异或任何数都等于那个数，用reduce在列表所有元素之间使用异或^，那么留下的就是那个单独的数字了。349. 两个数组的交集123class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: return [*set(nums1) &amp; set(nums2)] 经过 set 之后，重复的元素被删除 与运算对于集合来说就是求交集202. 快乐数1234567class Solution: def isHappy(self, n: int) -&gt; bool: seen = &#123;1&#125; while n not in seen: seen.add(n) n = sum(int(i) ** 2 for i in str(n)) return n == 1 ☄ 实际应用 - 哈希映射 1. 两数之和123456class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: d = &#123;&#125; for i, n in enumerate(nums): if n in d: return [d[n], i] d[target-n] = i $O(N)$时间效率的快速解法，用字典记录 ｛需要的值:当前索引｝205. 同构字符串123class Solution: def isIsomorphic(self, s: str, t: str) -&gt; bool: return [*map(s.index, s)] == [*map(t.index, t)] 同构代表两个字符串中每个位置上字符在自身第一次出现的索引相同599. 两个列表的最小索引总和1234class Solution: def findRestaurant(self, list1: List[str], list2: List[str]) -&gt; List[str]: d = &#123;x: list1.index(x) + list2.index(x) for x in set(list1) &amp; set(list2)&#125; return [x for x in d if d[x] == min(d.values())] 使用字典记录｛共同喜欢的商店：索引和｝，返回索引和并列最小的商店名387. 字符串中的第一个唯一字符1234567class Solution: def firstUniqChar(self, s: str) -&gt; int: d = &#123;c: s.count(c) for c in set(s)&#125; for i, c in enumerate(s): if d[c] == 1: return i return -1 首先用字典 d 储存｛字符：出现次数｝，注意这里的字符来自 set，为了避免重复操作，防止TLE 然后遍历 s 寻找出现次数为 1 的第一个字符索引，不存在则返回 -1350. 两个数组的交集 II123class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: return [*(collections.Counter(nums1) &amp; collections.Counter(nums2)).elements()] 对于两个 Counter 对象，与操作意味着取两者都有的key, value取小的那一个 参考：Python Counter 计数工具12345678910111213141516class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: nums1.sort() nums2.sort() r = [] i = j = 0 while i &lt; len(nums1) and j &lt; len(nums2): if nums1[i] == nums2[j]: r.append(nums1[i]) i += 1 j += 1 elif nums1[i] &lt; nums2[j]: i += 1 else: j += 1 return r 进阶解法 ↑ 使用双指针将两个列表中共同的元素抠下来，因为已经排序，所以遇到不同元素时数值小的那个列表的指针向前移动219. 存在重复元素 II12345678class Solution: def containsNearbyDuplicate(self, nums: List[int], k: int) -&gt; bool: r = float(&#x27;inf&#x27;) d = &#123;&#125; for i, n in enumerate(nums): r = min(r, i - d.get(n, float(&#x27;-inf&#x27;))) d[n] = i return r &lt;= k 本题题目有误，实际意思是找同数字最小间隔，若不超过 k 则满足条件 遍历列表，每次都比对最小间隔，并更新哈希表索引，当前位置往左的最小间隔一定是与上一次同数字出现的索引的距离 ☄ 实际应用 - 设计键 49. 字母异位词分组123456class Solution: def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]: d = collections.defaultdict(list) for s in strs: d[&#x27;&#x27;.join(sorted(s))].append(s) return [*d.values()] 以排序后的单词为 key，将所有字符串分组36. 有效的数独12345678910class Solution: def isValidSudoku(self, board: List[List[str]]) -&gt; bool: row, col, pal = eval(&#x27;,&#x27;.join([&#x27;[[0] * 9 for _ in range(9)]&#x27;] * 3)) for i, r in enumerate(board): for j, n in enumerate(r): if n == &#x27;.&#x27;: continue n = int(n) - 1 if row[i][n] or col[j][n] or pal[i // 3 * 3 + j // 3][n]: return False row[i][n] = col[j][n] = pal[i // 3 * 3 + j // 3][n] = 1 return True 使用 3 个二维矩阵记录某数字是否已经在特定区域出现过，如第 1 行，第 4 列对于 row[0], col[3], pal[1] 区域，每个区域包含 9 个数值，用以记录其 索引 + 1 是否在改区域出现过652. 寻找重复的子树123456789101112131415161718# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def findDuplicateSubtrees(self, root: TreeNode) -&gt; List[TreeNode]: d, r = &#123;&#125;, [] def dfs(root): if not root: return &#x27;#&#x27; s = &#x27;# &#x27; + &#x27; &#x27;.join((str(root.val), dfs(root.left), dfs(root.right))) d[s] = d.get(s, 0) + 1 if d[s] == 2: r.append(root) return s dfs(root) return r 使用字典 d 记录｛子树结构：[root1，root2，……]｝ ☄ 小结 771. 宝石与石头1234class Solution: def numJewelsInStones(self, J: str, S: str) -&gt; int: j = set(J) return sum(bool(s in j) for s in S) set 的 in 操作时间复杂度为 O(1)3. 无重复字符的最长子串12345678class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: i, r, d = -1, 0, &#123;&#125; for j, c in enumerate(s): i = max(i, d.get(c, -1)) r = max(r, j - i) d[c] = j return r 双指针滑动窗口，i 代表窗口起始位置，j 代表窗口结束位置，r 记录最优结果，d 记录所有字符最后出现的位置（对于 j 遍历来说）454. 四数相加 II123456789101112class Solution: def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -&gt; int: dic = &#123;&#125; for a in A: for b in B: dic[a + b] = dic.get(a + b, 0) + 1 r = 0 for c in C: for d in D: r += dic.get(- c - d, 0) return r 思路同第一题 TWO SUM 的 O(N) 字典解法，记录需要的值347. 前K个高频元素12345678910111213class Solution: def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]: d = &#123;n: 0 for n in nums&#125; for n in nums: d[n] += 1 r = [] for _ in range(k): n = max(d, key=d.get) r.append(n) d[n] = -1 return r 时间复杂度 O(N)，空间复杂度 O(N) 使用字典 d 记录｛数字：出现次数｝ 循环 k 次分别取出最大值放入结果列表 r380. 常数时间插入、删除和获取随机元素1234567891011121314151617181920212223242526272829303132333435363738394041424344class RandomizedSet: def __init__(self): &quot;&quot;&quot; Initialize your data structure here. &quot;&quot;&quot; self.d = &#123;&#125; self.l = [] def insert(self, val: int) -&gt; bool: &quot;&quot;&quot; Inserts a value to the set. Returns true if the set did not already contain the specified element. &quot;&quot;&quot; if val in self.d: return False else: self.d[val] = len(self.l) self.l.append(val) return True def remove(self, val: int) -&gt; bool: &quot;&quot;&quot; Removes a value from the set. Returns true if the set contained the specified element. &quot;&quot;&quot; if val in self.d: self.d[self.l[-1]] = self.d[val] self.l[self.d.pop(val)] = self.l[-1] self.l.pop() return True else: return False def getRandom(self) -&gt; int: &quot;&quot;&quot; Get a random element from the set. &quot;&quot;&quot; return self.l[random.randint(0, len(self.l) - 1)]# Your RandomizedSet object will be instantiated and called as such:# obj = RandomizedSet()# param_1 = obj.insert(val)# param_2 = obj.remove(val)# param_3 = obj.getRandom() O(1)解法，组合使用哈希表和数组 插入时：用哈希表来判断是否已存在O(1)，数组末尾增加一个元素O(1)，哈希表记录｛值：索引｝O(1) 删除时：用哈希表来定位O(1)，把数组最后一个元素取下来顶替被删除元素位置O(1)，更新哈希表O(1) 取随机数时：随机从数组里面挑一个O(1)🌠 二分查找 【知识卡片】二分查找利用已排好序的数组，每一次查找都可以将查找范围减半。查找范围内只剩一个数据时查找结束。数据量为 n 的数组，将其长度减半 log2n 次后，其中便只剩一个数据了。也就是说，在二分查找中重复执行“将目标数据和数组中间的数据进行比较后将查找范围减半”的操作 log2n 次后，就能找到目标数据（若没找到则可以得出数据不存在的结论），因此它的时间复杂度为 O(logn) 💡【一般思路】什么时候应该使用二分搜索？怎么样使用？ 在一个已知的范围内寻找答案 该范围集合有序 一般来说题目要求时间复杂度为 logN 就应该联想到二分搜索 如果把搜索范围看成一个函数的定义域，当我们拿到 x 的时候应该通过 f(x) 在整个函数中的特点决定 target 的大致位置 🌪【常见题型】 目标匹配类：374. 猜数字大小 邻居对比类：162. 寻找峰值 枚举试错类：第 K 个满足条件的值（此类题目范围一般比较隐晦，需要自己确定，然后通过在范围内枚举试错的方法确定 target 位置），例如 719. 找出第 k 小的距离对 【套路A】 12self.__class__.__getitem__ = lambda self, x: 向左搜索的条件（不包括target）寻找的索引 = bisect.bisect_left(self, True, 0, len(nums)) - 1 python 中 bisect 模块针对的是 list, 如果直接构造 list，时间复杂度为 O(N)，因此我们修改当前类的魔法方法伪造 list bisect.left(用于比较的数组，搜索的值，起始范围(包括)，终止范围(不包括))：返回应该插入的位置 【套路B】 12self.__class__.__getitem__ = lambda self, x: 向左搜索的条件（包括target）寻找的索引 = bisect.bisect_left(self, True, 0, len(nums) - 1) 搜索范围为 $[0,\\;len(nums) - 1]$，注意此处为闭区间 【非内置公式A】 12345678910class Solution: def 二分查找二岔模板(self, nums: List[int], target: int): l, h = 0, len(nums) while l &lt; h: m = (l + h) // 2 if 必须向左搜索的条件: h = m else: l = m + 1 return l - 1 【非内置公式B】 12345678910class Solution: def 二分查找二岔模板(self, nums: List[int], target: int): l, h = 0, len(nums) - 1 while l &lt; h: m = (l + h) // 2 if 满足目标或向左搜索的条件: h = m else: l = m + 1 return l ☄ 背景 704. 二分查找123456789101112class Solution: def search(self, nums: List[int], target: int) -&gt; int: l, h = 0, len(nums) - 1 while l &lt;= h: m = (l + h) // 2 if nums[m] == target: return m elif nums[m] &gt; target: h = m - 1 else: l = m + 1 return -1 ☄ 模板 I 69. x 的平方根123456789101112class Solution: def mySqrt(self, x: int) -&gt; int: l, h = 0, x while l &lt; h: m = (l + h) // 2 if m**2 &lt;= x &lt; (m+1)**2: return m elif m**2 &lt; x: l = m + 1 else: h = m - 1 return l 374. 猜数字大小123456789101112131415161718192021# The guess API is already defined for you.# @param num, your guess# @return -1 if my number is lower, 1 if my number is higher, otherwise return 0# def guess(num):class Solution(object): def guessNumber(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; l, h = 1, n while l &lt;= n: m = (l + h) // 2 r = guess(m) if not r: return m elif r == 1: l = m + 1 else: h = m - 1 33. 搜索旋转排序数组12345678910111213141516171819202122232425262728class Solution: def search(self, nums: List[int], target: int) -&gt; int: # 寻找断点 k, l, h = 0, 1, len(nums) - 1 while l &lt;= h: m = (l + h) // 2 if nums[m] &lt; nums[m - 1]: k = m break elif nums[m] &gt; nums[0]: l = m + 1 else: h = m - 1 # 恢复升序 nums[k:], nums[:0] = [], nums[k:] # 搜索目标 l, h = 0, len(nums) - 1 while l &lt;= h: m = (l + h) // 2 if nums[m] == target: return (m + k) % len(nums) elif nums[m] &lt; target: l = m + 1 else: h = m - 1 return -1 首先通过第一个二分查找得到升序排列时的开头（也就是数组中的最小值），称其为断点 k 恢复数组后通过第二个二分查找得到目标索引 ☄ 模板 II 278. 第一个错误的版本1234567891011121314151617181920# The isBadVersion API is already defined for you.# @param version, an integer# @return a bool# def isBadVersion(version):class Solution: def firstBadVersion(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; l, h = 1, n while l &lt;= h: m = (l + h) // 2 if isBadVersion(m) &gt; m * isBadVersion(m - 1): return m elif isBadVersion(m): h = m - 1 else: l = m + 1 本题二分搜索中判断返回的条件为 当前版本为True且（当前索引为0 或 左边的版本为False） m * 的作用是避免 m - 1 为负数，如果 m 为 0，则代表左边没有版本，只需判断当前版本是否为 True True &gt; False 或 0162. 寻找峰值1234567891011class Solution: def findPeakElement(self, nums: List[int]) -&gt; int: l, h = 0, len(nums) - 1 while l &lt;= h: m = (l + h) // 2 if (not m or nums[m-1] &lt; nums[m]) and (m == len(nums) - 1 or nums[m] &gt; nums[m+1]): return m elif not m or nums[m] &gt; nums[m-1]: l = m + 1 else: h = m - 1 标准的三岔二分搜索 python 二分公式套路A：1234class Solution: def findPeakElement(self, nums: List[int]) -&gt; int: self.__class__.__getitem__ = lambda self, m: m and nums[m-1] &gt; nums[m] return bisect.bisect_left(self, True, 0, len(nums)) - 1 153. 寻找旋转排序数组中的最小值12345678910class Solution: def findMin(self, nums: List[int]) -&gt; int: l, h = 0, len(nums) - 1 while l &lt; h: m = (l + h) // 2 if nums[m] &lt; nums[-1]: h = m else: l = m + 1 return nums[l] 标准二岔二分搜索 python 二分公式套路B：1234class Solution: def findMin(self, nums: List[int]) -&gt; int: self.__class__.__getitem__ = lambda self, m: nums[m] &lt;= nums[-1] return nums[bisect.bisect_left(self, True, 0, len(nums))] ☄ 模板 III 34. 在排序数组中查找元素的第一个和最后一个位置1234567891011121314151617181920212223242526class Solution: def searchRange(self, nums: List[int], target: int) -&gt; List[int]: r = [-1, -1] l, h = 0, len(nums) - 1 while l &lt; h: m = (l + h) // 2 if target &lt;= nums[m]: h = m else: l = m + 1 if nums and nums[l] == target: r[0] = l l, h = 0, len(nums) - 1 while l &lt; h: m = (l + h) // 2 if target &lt; nums[m] or (target == nums[m] and (m == len(nums) - 1 or nums[m] &lt; nums[m+1])): h = m else: l = m + 1 if nums and nums[l] == target: r[1] = l return r 658. 找到 K 个最接近的元素12345678910class Solution: def findClosestElements(self, arr: List[int], k: int, x: int) -&gt; List[int]: l, h = 0, len(arr) - 1 while l &lt; h: m = (l + h) // 2 if arr[m] &gt;= x: h = m else: l = m + 1 return sorted(sorted(arr[max(0, l-k) : l+k], key=lambda y: abs(y - x))[:k]) 二分查找 + 邻域排序162. 寻找峰值1234567891011class Solution: def findPeakElement(self, nums: List[int]) -&gt; int: l, h = 0, len(nums) - 1 while l &lt;= h: m = (l + h) // 2 if (not m or nums[m-1] &lt; nums[m]) and (m == len(nums) - 1 or nums[m] &gt; nums[m+1]): return m elif not m or nums[m] &gt; nums[m-1]: l = m + 1 else: h = m - 1 标准的三岔二分搜索 python 二分公式套路A：1234class Solution: def findPeakElement(self, nums: List[int]) -&gt; int: self.__class__.__getitem__ = lambda self, m: m and nums[m-1] &gt; nums[m] return bisect.bisect_left(self, True, 0, len(nums)) - 1 ☄ 小结 50. Pow(x, n)1234class Solution: def myPow(self, x, n, r=1) -&gt; float: x, n = n &lt; 0 and 1 / x or x, abs(n) return self.myPow(x * x, n // 2, r * (not n % 2 or x)) if n else r 尾递归 $O(\\log N)$ 解法 x^4 正常计算过程：x * x * x * x，$O(N)$ 优化后：(x**2)**2，$O(\\log N)$367. 有效的完全平方数12345678910class Solution: def isPerfectSquare(self, num: int) -&gt; bool: l, h = 0, num while l &lt; h: m = (l + h) // 2 if m * m &gt;= num: h = m else: l = m + 1 return l * l == num 一个数字的算术平方根一定小于等于它自身，因此答案被限制在[0, num]的范围内，且待选答案呈升序排列，故可用二分查找744. 寻找比目标字母大的最小字母12345678910class Solution: def nextGreatestLetter(self, letters: List[str], target: str) -&gt; str: l, h = 0, len(letters) - 1 while l &lt; h: m = (l + h) // 2 if letters[m] &gt; target: h = m else: l = m + 1 return letters[l] if letters[l] &gt; target else letters[0] 二分查找 O(logN) 所谓的循环只有在数组中所有字符比目标小的时候起作用，只需要在最后增加一个判断就行了12345class Solution: def nextGreatestLetter(self, letters: List[str], target: str) -&gt; str: self.__class__.__getitem__ = lambda self, m: target &lt; letters[m] i = bisect.bisect_left(self, True, 0, len(letters) - 1) return letters[i] if letters[i] &gt; target else letters[0] 套路B ☄ 更多练习 153. 寻找旋转排序数组中的最小值12345678910class Solution: def findMin(self, nums: List[int]) -&gt; int: l, h = 0, len(nums) - 1 while l &lt; h: m = (l + h) // 2 if nums[m] &lt; nums[-1]: h = m else: l = m + 1 return nums[l] -标准二岔二分搜索 python 二分公式套路B：1234class Solution: def findMin(self, nums: List[int]) -&gt; int: self.__class__.__getitem__ = lambda self, m: nums[m] &lt;= nums[-1] return nums[bisect.bisect_left(self, True, 0, len(nums))] 154. 寻找旋转排序数组中的最小值 II123456789101112class Solution: def findMin(self, nums: List[int]) -&gt; int: l, h = 0, len(nums) - 1 while l &lt; h: m = (l + h) // 2 if nums[m] &lt; nums[h]: h = m elif nums[m] == nums[h]: h -= 1 else: l = m + 1 return nums[l] 每次都需要判断 m 是否在未被旋转的部分上（右部），如果在，则向左搜索，否则向右搜索 当 nums[m] &lt; nums[h] 时可以确定在右部，由于存在重复数字，当 m 指向的数字和 h 指向的相同时，可以直接收缩搜索范围(h -= 1），反正他们所代表的数字还有至少一个在搜索范围内349. 两个数组的交集123class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: return [*set(nums1) &amp; set(nums2)] 经过 set 之后，重复的元素被删除 与运算对于集合来说就是求交集350. 两个数组的交集 II123class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: return [*(collections.Counter(nums1) &amp; collections.Counter(nums2)).elements()] 对于两个 Counter 对象，与操作意味着取两者都有的key, value取小的那一个 参考：Python Counter 计数工具12345678910111213141516class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: nums1.sort() nums2.sort() r = [] i = j = 0 while i &lt; len(nums1) and j &lt; len(nums2): if nums1[i] == nums2[j]: r.append(nums1[i]) i += 1 j += 1 elif nums1[i] &lt; nums2[j]: i += 1 else: j += 1 return r 进阶解法 ↑ 使用双指针将两个列表中共同的元素抠下来，因为已经排序，所以遇到不同元素时数值小的那个列表的指针向前移动167. 两数之和 II - 输入有序数组123456789class Solution: def twoSum(self, numbers: List[int], target: int) -&gt; List[int]: i, j = 0, len(numbers) - 1 while numbers[i] + numbers[j] != target: if numbers[i] + numbers[j] &gt; target: j -= 1 else: i += 1 return [i+1, j+1] ☄ 更多练习 II 287. 寻找重复数12345678910class Solution: def findDuplicate(self, nums: List[int]) -&gt; int: l, h = 0, len(nums) - 1 while l &lt; h: m = (l + h) &gt;&gt; 1 if sum(n &lt;= m for n in nums) &gt; m: h = m else: l = m + 1 return l 本题可用二分查找，整个算法时间复杂度为 O(NlogN)，由题意可知搜索范围在 1 到 n 之间，那么如何缩小范围？只需判断数组中不超过中间数 m 的元素数量是否大于 m 即可，若大于，则表示范围 1 到 m 内肯定包含重复的数字 搜索范围为 [1, n]，向左（包括target）搜索的条件为：不大于 n 的数字在 nums 存在超过 m 个，即搜索范围可以被缩小为 [1, m]1234class Solution: def findDuplicate(self, nums: List[int]) -&gt; int: self.__class__.__getitem__ = lambda sef, m: sum(n &lt;= m for n in nums) &gt; m return bisect.bisect_left(self, True, 1, len(nums) - 1) 套路B4. 寻找两个有序数组的中位数123456789101112131415161718class Solution: def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float: if len(nums1) &lt; len(nums2): a, b = nums1, nums2 else: a, b = nums2, nums1 m = (len(nums1) + len(nums2) - 1) &gt;&gt; 1 l, h = 0, len(a) while l &lt; h: i = (l + h) &gt;&gt; 1 if m-i-1 &lt; 0 or a[i] &gt;= b[m-i-1]: h = i else: l = i + 1 r = sorted(a[l: l + 2] + b[m - l: m - l + 2]) return (r[0] + r[1 - (len(a) + len(b)) % 2]) / 2 1234567class Solution: def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float: a, b, m = *sorted((nums1, nums2), key=len), (len(nums1) + len(nums2) - 1) // 2 self.__class__.__getitem__ = lambda self, i: m-i-1 &lt; 0 or a[i] &gt;= b[m-i-1] i = bisect.bisect_left(self, True, 0, len(a)) r = sorted(a[i:i+2] + b[m-i:m-i+2]) return (r[0] + r[1 - (len(a) + len(b)) % 2]) / 2 本题思路与官方题解类似，时间复杂度O(log(min(m, n)))，没看过的话建议先大体了解一下 python 中 bisect 模块针对的是 list, 如果直接构造 list，时间复杂度为 O(min(m, n))，因此我们修改当前类的魔法方法伪造 list 在一个有序递增数列中，中位数左边的那部分的最大值一定小于或等于右边部分的最小值 如果总数组长度为奇数，m 代表中位数的索引，否则 m 代表用于计算中位数的那两个数字的左边一个。比如输入为[1,2]，[3]，那么m应该为[1,2,3]中位数2的索引1，如果输入为[1,3]，[2,4]，那么m应该为[1,2,3,4]中2的索引1 使用二分搜索找到 m 对应的值在a或b中对应的索引，也就是说，我们要找的中位数或中位数左部应该是 a[i] 或者 b[m-i] bisect.bisect_left 搜索列表中保持列表升序的情况下，True应该插入的位置（从左侧），比如 [F,F,T] 返回 2，[F,F] 返回 2 这里保证 a 是 nums1 和 nums2 中较短的那个，是为了防止二分搜索的时候索引越界 sorted返回一个list，假设返回值是 [nums1, nums2]，那么前面加个 * 号就代表取出列表的所有内容，相当于一个迭代器，结果相当于直接写 nums1, nums2719. 找出第 k 小的距离对1234567891011121314151617181920class Solution: def smallestDistancePair(self, nums: List[int], k: int) -&gt; int: nums.sort() l, h = 0, max(nums) - min(nums) while l &lt; h: m = (l + h) &gt;&gt; 1 # 滑动窗口求小于 m 的对数 c = j = 0 for i, n in enumerate(nums[:-1]): while j &lt; len(nums) and nums[j] - nums[i] &lt;= m: j += 1 c += j - i - 1 if c &gt;= k: h = m else: l = m + 1 return l 二分搜索，总时间复杂度为 O(Nlog(max(nums) - min(nums))) m 搜索范围为[0, max(nums) - min(nums)] 只要满足所有数对中距离小于等于 m 的对数大于等于 k 即可向左搜索 判断以上条件时使用双指针滑窗，时间复杂度为 O(N)410. 分割数组的最大值12345678910111213141516171819202122class Solution: def splitArray(self, nums: List[int], m: int) -&gt; int: l, h = 0, sum(nums) while l &lt; h: mid = (l + h) &gt;&gt; 1 # 贪心试错 c = 1; r = s = 0 for i, n in enumerate(nums): if s + n &gt; mid: c += 1 r = max(r, s) s = n else: s += n r = max(r, s) if c &lt;= m and r &lt;= mid: h = mid else: l = mid + 1 return l 本题是二分搜索试错法的又一经典案例，总时间复杂度为 O(Nlog(sum(nums))) 我们寻求的答案（最小的子数组各自和最大值）mid 被限制于一个有序的区间 [0, sum(nums)] 之内 向左搜索（包括 target）的条件为：nums 可以被划分为不超过 m 个和不超过 mid 的子数组 判断条件成立使用了贪心算法：计数 c：nums 可以被划分为至少多少个和不超过 mid 的子数组（注意如果单个数字已经超过 mid 将被单独划分，所以最后需要判断最大子数组和 r 是否满足条件）🌠 二叉树 ☄ 树的遍历 144. 二叉树的前序遍历12345678910# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: return root and sum(([root.val], *map(self.preorderTraversal, [root.left, root.right])), []) or [] 递归遍历12345678910111213141516# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: r, stack = [], root and [root] or [] while stack: root = stack.pop() r.append(root.val) stack += root.right and [root.right] or [] stack += root.left and [root.left] or [] return r DFS 就是前序遍历94. 二叉树的中序遍历12345678910111213141516171819202122232425# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def inorderTraversal(self, root: TreeNode) -&gt; List[int]: r = [] # 初始化栈 stack = [] # 进入堆栈循环 while stack or root: if root: # 入栈条件 stack.append(root) root = root.left else: # 出栈条件 root = stack.pop() r.append(root.val) root = root.right return r 本题需使用栈来解决，关键点在于入栈条件和出栈条件的确定145. 二叉树的后序遍历12345678910# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def postorderTraversal(self, root: TreeNode) -&gt; List[int]: return root and sum((*map(self.postorderTraversal, [root.left, root.right]), [root.val]), []) or [] 递归12345678910111213141516# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def postorderTraversal(self, root: TreeNode) -&gt; List[int]: r, stack = [], root and [root] or [] while stack: root = stack.pop() r.append(root.val) stack += root.left and [root.left] or [] stack += root.right and [root.right] or [] return r[::-1] 迭代 DFS的输出顺序为 根-右-左，我们的目标（后序遍历）为 左-右-根，因此只需对调整后的 DFS 逆序输出即为后序遍历102. 二叉树的层次遍历12345678910111213141516171819202122232425# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: q = root and collections.deque([(root, 0)]) r = [] while q: node, layer = q.popleft() if len(r) &lt; layer + 1: r.append([]) r[layer].append(node.val) if node.left: q.append((node.left, layer + 1)) if node.right: q.append((node.right, layer + 1)) return r 使用 BFS 遍历二叉树，队列同时记录节点与层次 ☄ 运用递归解决树的问题 💡【一般思路】什么时候应该使用递归？ 递归可以看作是四维空间中的逻辑，也就是相比普通的一个函数多了一个时间维度，当下一次的结果需要以上一次的结果作为输入时使用递归函数 简单来说，对于一个输入，一般的函数执行一次即可得到答案并返回，递归函数重复执行多次后返回 💡【一般思路】如何使用递归？ 考虑初始状态 考虑两条支路： 返回的结果还需要再次递归的结果：考虑如何连接不同时间上的俩个结果 返回的结果不需要再次递归的结果：通过其他条件判断后直接返回 【套路】树形递归 树形递归类题目一般将目光集中在某个节点上，考虑节点、左子节点、右子节点之间的关系，一般递归子节点 通常选择一个3层完美二叉树的第2层左子节点作为参考目标，然后设计递归思路104. 二叉树的最大深度1234567891011121314151617# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def maxDepth(self, root: TreeNode) -&gt; int: if not root: return 0 f = self.maxDepth l = f(root.left) r = f(root.right) return max(l, r) + 1 101. 对称二叉树123456789101112131415161718192021# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isSymmetric(self, root: TreeNode) -&gt; bool: if not root or root.left is root.right: return True l, r = root.left, root.right if (l and l.val) != (r and r.val): return False i, o = TreeNode(0), TreeNode(0) i.left, i.right = l.left, r.right o.left, o.right = l.right, r.left return self.isSymmetric(i) and self.isSymmetric(o) 一棵树对称意味着： 左节点 == 右节点 左节点的左子树与右节点右子树对称 左节点的右子树与右节点左子树对称 前6行处理特殊情况：root为None或root无子节点直接返回True，root只有一个子节点或root两个子节点不相等直接返回False 第一个条件在前6行处理过了，对于第二和第三个条件，我们分别构造两个假树i(inner)和o(outer)，i代表内假树，对应条件二，o代表外假树，对应条件三。递归内外假树即可112. 路径总和123456789101112131415161718# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def hasPathSum(self, root: TreeNode, sum: int) -&gt; bool: if root: if root.left is root.right: return sum == root.val else: l = root.left and self.hasPathSum(root.left, sum - root.val) r = root.right and self.hasPathSum(root.right, sum - root.val) return l or r else: return False 考虑初始状态：当树不存在时直接返回 False 考虑支路1：当前节点为叶节点时直接判断总和是否达到要求 考虑支路2：当前节点为非叶节点时将总和缩小并继续递归，判断左右节点是否存在满足条件的 当递归函数到达叶节点时，sum 已经被削减了多次，此时 sum - node.val 即为 原始的sum - 整条路径的总和 ☄ 总结 106. 从中序与后序遍历序列构造二叉树12345678910111213141516171819# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def buildTree(self, inorder: List[int], postorder: List[int]) -&gt; TreeNode: if not postorder: return None root = TreeNode(postorder[-1]) n = inorder.index(root.val) root.left = self.buildTree(inorder[:n],postorder[:n]) root.right = self.buildTree(inorder[n+1:],postorder[n:-1]) return root 后序遍历顺序为 左, 右, 根，因此后序遍历的末尾一定为根节点 中序列表为 [左子树中序序列, 根节点, 右子树中序序列] 后序列表为 [左子树后序序列, 右子树后序序列, 根节点] 由于树中没有重复元素，我们可以通过 index 函数确定根节点在中序列表的位置，进而确定左右子树各自包含的节点总数，将中序与后序列表划分开 每次递归生成根节点并继续递归左右子节点即可105. 从前序与中序遍历序列构造二叉树12345678910111213141516171819# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode: if not inorder: return None root = TreeNode(preorder[0]) n = inorder.index(root.val) root.left = self.buildTree(preorder[1:n+1], inorder[:n]) root.right = self.buildTree(preorder[n+1:], inorder[n+1:]) return root 前序遍历顺序为 根, 左, 右，因此前序遍历的开端一定为根节点 中序列表为 [左子树中序序列, 根节点, 右子树中序序列] 前序列表为 [根节点, 左子树后序序列, 右子树后序序列] 由于树中没有重复元素，我们可以通过 index 函数确定根节点在中序列表的位置，进而确定左右子树各自包含的节点总数，将中序与前序列表划分开 每次递归生成根节点并继续递归左右子节点即可116. 填充每个节点的下一个右侧节点指针123456789101112131415161718192021&quot;&quot;&quot;# Definition for a Node.class Node: def __init__(self, val, left, right, next): self.val = val self.left = left self.right = right self.next = next&quot;&quot;&quot;class Solution: def connect(self, root: &#x27;Node&#x27;) -&gt; &#x27;Node&#x27;: if root and root.left: root.left.next = root.right if root.next: root.right.next = root.next.left self.connect(root.left) self.connect(root.right) return root 对于任意一次递归，只需要考虑如何设置子节点的 next 属性： 将左子节点连接到右子节点 将右子节点连接到 root.next 的左子节点 递归左右节点117. 填充每个节点的下一个右侧节点指针 II12345678910111213141516171819202122232425&quot;&quot;&quot;# Definition for a Node.class Node: def __init__(self, val, left, right, next): self.val = val self.left = left self.right = right self.next = next&quot;&quot;&quot;class Solution: def connect(self, root: &#x27;Node&#x27;) -&gt; &#x27;Node&#x27;: if root and (root.left or root.right): if root.left and root.right: root.left.next = root.right node = root.right or root.left head = root.next while head and not (head.left or head.right): head = head.next node.next = head and (head.left or head.right) self.connect(root.right) self.connect(root.left) return root 对于任意一次递归，只考虑如何设置子节点的 next 属性,分为三种情况： 没有子节点：直接返回 有一个子节点：将这个子节点的 next 属性设置为同层的下一个节点，即为 root.next 的最左边的一个节点，如果 root.next 没有子节点，则考虑 root.next.next，依次类推 有两个节点：左子节点指向右子节点，然后右子节点同第二种情况的做法 注意递归的顺序需要从右到左236. 二叉树的最近公共祖先123456789101112# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def lowestCommonAncestor(self, root: &#x27;TreeNode&#x27;, p: &#x27;TreeNode&#x27;, q: &#x27;TreeNode&#x27;) -&gt; &#x27;TreeNode&#x27;: l = root.left and self.lowestCommonAncestor(root.left, p, q) r = root.right and self.lowestCommonAncestor(root.right, p, q) return root if root in (p, q) or l and r else l or r 递归全部节点，p 的祖先节点全部返回 p，q 的祖先节点全部返回 q，如果它同时是俩个节点的最近祖先，那么返回自身，否则返回 None297. 二叉树的序列化与反序列化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Codec: def serialize(self, root): &quot;&quot;&quot;Encodes a tree to a single string. :type root: TreeNode :rtype: str &quot;&quot;&quot; l = [] q = collections.deque([root]) while q: root = q.popleft() if root: l.append(root.val) q.extend([root.left, root.right]) else: l.append(None) return str(l) def deserialize(self, data): &quot;&quot;&quot;Decodes your encoded data to tree. :type data: str :rtype: TreeNode &quot;&quot;&quot; l = eval(data) head = TreeNode(l[0]) if l[0] is not None else None q = collections.deque([head]) i = 1 while q: root = q.popleft() if root is not None: root.left = TreeNode(l[i]) if l[i] is not None else None root.right = TreeNode(l[i + 1]) if l[i + 1] is not None else None i += 2 q.extend([root.left, root.right]) return head # Your Codec object will be instantiated and called as such:# codec = Codec()# codec.deserialize(codec.serialize(root)) BFS扫描，记录所有节点和他们的子节点（包括 子None） 利用队列记录待还原节点，每次生成新节点后初始化其子节点并投入队列🌠 二叉搜索树 ☄ 二叉搜索树简介 98. 验证二叉搜索树12345678910111213141516# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isValidBST(self, root: TreeNode, first=True) -&gt; bool: if not root: return first or [] f = self.isValidBST l = f(root.left, 0) + [root.val] + f(root.right, 0) return all([a &gt; b for a, b in zip(l[1:], l)]) if first else l 搜索二叉树的中序遍历结果呈升序 若当前递归节点为根（first 为 True）则判断遍历结果是否呈升序，否则返回中序遍历列表用于拼接173. 二叉搜索树迭代器12345678910111213141516171819202122232425262728293031323334353637# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass BSTIterator: def __init__(self, root: TreeNode): self.s = [] while root: self.s.append(root) root = root.left def next(self) -&gt; int: &quot;&quot;&quot; @return the next smallest number &quot;&quot;&quot; r = self.s.pop() root = r.right while root: self.s.append(root) root = root.left return r.val def hasNext(self) -&gt; bool: &quot;&quot;&quot; @return whether we have a next smallest number &quot;&quot;&quot; return bool(self.s)# Your BSTIterator object will be instantiated and called as such:# obj = BSTIterator(root)# param_1 = obj.next()# param_2 = obj.hasNext() 模拟中序遍历的迭代过程，使用堆栈 self.s 进行深度优先搜索 空间复杂度为 O(树的高度) 平均时间复杂度 = 循环总次数（N） / 迭代器长度（N） = O(1) ☄ 在二叉搜索树中实现搜索操作 700. 二叉搜索树中的搜索1234567891011121314# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def searchBST(self, root: TreeNode, val: int) -&gt; TreeNode: if not root or root.val == val: return root else: root = root.right if root.val &lt; val else root.left return self.searchBST(root, val) 根据BST的特性，对于每个节点： 如果目标值等于节点的值，则返回节点; 如果目标值小于节点的值，则继续在左子树中搜索; 如果目标值大于节点的值，则继续在右子树中搜索。701. 二叉搜索树中的插入操作123456789101112131415161718192021222324252627# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def insertIntoBST(self, root: TreeNode, val: int) -&gt; TreeNode: root = copy.deepcopy(root) stack = [root] while stack: node = stack.pop() if node.val &gt; val: if node.left: stack.append(node.left) else: node.left = TreeNode(val) else: if node.right: stack.append(node.right) else: node.right = TreeNode(val) return root 此处遵循经典插入方法，种使整体操作变化最小 寻找到合适的叶位置后插入新节点，这样的操作只需要在原树的某个叶节点处延伸一个节点 这里可以直接深拷贝构造新树，然后修改450. 删除二叉搜索树中的节点1234567891011121314151617181920212223242526272829303132333435# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def deleteNode(self, root: TreeNode, key: int) -&gt; TreeNode: dummy = TreeNode(float(&#x27;-inf&#x27;)) dummy.right = root root = dummy while root: child_str = &#x27;root.left&#x27; if root.val &gt; key else &#x27;root.right&#x27; child = eval(child_str) if not child or child.val != key: # 继续搜索删除目标的父节点 root = child else: # 已经找到删除目标的父节点 root 和目标 child if child.left is child.right: # 情况1.目标没有子节点 exec(f&#x27;&#123;child_str&#125; = None&#x27;) elif not (child.left and child.right): # 情况2.目标只有左子或右子 exec(f&#x27;&#123;child_str&#125; = child.left or child.right&#x27;) else: # 情况3.目标有左子和右子 parent = child root = parent.right while root and root.left: # 搜索中序后继节点 parent, root = root, root.left child.val = root.val side = &#x27;right&#x27; if parent is child else &#x27;left&#x27; exec(f&#x27;parent.&#123;side&#125; = root.right&#x27;) return dummy.right 此类题目细节比较多，建议罗列所有情况后再写代码 本段代码为迭代流，涉及复杂知识点 eval, exec, 中序后继节点，主要思想同探索介绍的，尽量保持原树结构 首先可以分为俩类情况，删除目标为 root 或不为 root，构建一个虚拟节点连接上原来的 root，即可把所有情况归为删除目标不为 root 类 细分有3种情况： 目标没有子节点：直接删除 目标只有左子或右子：用目标唯一的子节点替换目标 目标有左子和右子：替换目标的值为中序后继节点的值并删除后继节点 ☄ 小结 703. 数据流中的第K大元素12345678910111213class KthLargest: def __init__(self, k: int, nums): self.k, self.nums = k, heapq.nlargest(k, nums + [float(&#x27;-inf&#x27;)]) heapq.heapify(self.nums) def add(self, val: int) -&gt; int: heapq.heappushpop(self.nums,val) return self.nums[0]# Your KthLargest object will be instantiated and called as such:# obj = KthLargest(k, nums)# param_1 = obj.add(val) 题目中提到 len(nums) &gt;= k-1，因此我们加入一个无穷小使得 len(nums) &gt;= k，以便构造一个 k 尺寸的小根堆 堆中的数据意味着从第 k 大的数字到最大的数字 维护堆的时间复杂度为 O(Tlogk)236. 二叉树的最近公共祖先12345678910111213141516# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def lowestCommonAncestor(self, root: &#x27;TreeNode&#x27;, p: &#x27;TreeNode&#x27;, q: &#x27;TreeNode&#x27;) -&gt; &#x27;TreeNode&#x27;: l = root.left and self.lowestCommonAncestor(root.left, p, q) r = root.right and self.lowestCommonAncestor(root.right, p, q) if root in (p, q) or l and r: return root else: return l or r 递归全部节点，p 的祖先节点返回 p，q 的祖先节点返回 q，否则返回 None 如果同时是俩个节点的最近祖先，也就是 p，q 分别位于左右子树，或者本身是 p、q 中的一个，那么返回自身220. 存在重复元素 III1234567891011121314class Solution: def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -&gt; bool: l = [] for j, n in enumerate(nums): if j &gt; k: # 滑动窗口 del l[bisect.bisect_left(l, nums[j - k - 1], 0, len(l))] i = bisect.bisect_left(l, n, 0, len(l)) l.insert(i, n) if i and abs(l[i] - l[i - 1]) &lt;= t or i &lt; len(l) - 1 and abs(l[i] - l[i + 1]) &lt;= t: return True return False k 实际上限制了滑动窗口的大小，对于每个数字，我们只需要检查其前面的 k-1 个数字中是否存在与当前数字距离不超过 t 的数字即可 检查的方法是在升序的列表中检查当前数字所在索引的左右两侧是否波动不超过 t 因为使用了窗口，所以维护排序只需在之前已经排好序的数组 l 的基础上保持升序得插入新数字即可，这里使用二分查找搜索插入位置 时间复杂度为 O(Nlog(min(N, K))) 空间复杂度为 O(min(N, K)) ☄ 附录：高度平衡的二叉搜索树 110. 平衡二叉树12345678910111213141516171819# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isBalanced(self, root: TreeNode, first=True) -&gt; bool: if not root: return True if first else 0 l = self.isBalanced(root.left, False) r = self.isBalanced(root.right, False) if l is False or r is False: return False return abs(l - r) &lt;= 1 and max(l, r) + 1 DFS递归每个节点 如果这个节点不平衡，那么这棵树肯定不平衡，它和它的所有父节点都返回 False 如果节点平衡，则返回当前树的高度 + 1（如果是根节点，直接返回True）108. 将有序数组转换为二叉搜索树1234567891011121314# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def sortedArrayToBST(self, nums: List[int]) -&gt; TreeNode: if nums: m = len(nums) // 2 r = TreeNode(nums[m]) r.left, r.right = map(self.sortedArrayToBST, [nums[:m], nums[m+1:]]) return r 平衡二叉搜索树需要保证俩点： 根节点大于左子树任意节点，小于右子树任意节点 左右子数高度相差不超过 1 由以上性质，一个可行的递归条件可以得出： 每次返回的根节点处于数组中间，以其左右半数组分别递归构造左右子树 那么就意味着左子小于根，右子大于根，且所有节点左右子树节点数相差不超过 1 （由于递归的构树方式相同，所有节点都满足高度平衡） 🌠 N叉树☄ 遍历 589. N叉树的前序遍历123456789101112131415161718&quot;&quot;&quot;# Definition for a Node.class Node: def __init__(self, val=None, children): self.val = val self.children = children&quot;&quot;&quot;class Solution: def preorder(self, root: &#x27;Node&#x27;) -&gt; List[int]: s = bool(root) * [root] r = [] while s: root = s.pop() r.append(root.val) s += root.children[::-1] return r root 为 [] 时 bool 值为 False 同 0，乘法结果为 []，即可跳过 while root 非空时 dfs 栈式迭代 逆转 children 是由于栈的 FILO(先入后出) 特性590. N-ary Tree Postorder Traversal123456789101112131415161718&quot;&quot;&quot;# Definition for a Node.class Node: def __init__(self, val=None, children=None): self.val = val self.children = children&quot;&quot;&quot;class Solution: def postorder(self, root: &#x27;Node&#x27;) -&gt; List[int]: s = bool(root) * [root] r = [] while s: root = s.pop() r.append(root.val) s += root.children return r[::-1] 后序遍历为 左右根，只需将前序遍历 根左右 的子节点遍历顺序逆转并倒序输出即可，大体做法同前一题429. N叉树的层序遍历12345678910111213141516171819202122&quot;&quot;&quot;# Definition for a Node.class Node: def __init__(self, val, children): self.val = val self.children = children&quot;&quot;&quot;class Solution: def levelOrder(self, root: &#x27;Node&#x27;) -&gt; List[List[int]]: q = root and collections.deque([(root, 0)]) r = [] while q: root, layer = q.pop() if len(r) &lt; layer + 1: r.append([]) r[layer].append((root.val)) q.extendleft([(child, layer + 1) for child in root.children]) return r 使用队列 BFS 遍历 在队列中多保留一个层次序号记录相应层索引 ☄ 递归 559. N叉树的最大深度12345678910&quot;&quot;&quot;# Definition for a Node.class Node: def __init__(self, val=None, children=None): self.val = val self.children = children&quot;&quot;&quot;class Solution: def maxDepth(self, root: &#x27;Node&#x27;) -&gt; int: return root and 1 + max(map(self.maxDepth, root.children or [None])) or 0 Bottom Up 递归 精选🌠 递归 I☄ 递归原理 344. 反转字符串1234567class Solution: def reverseString(self, s: List[str]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify s in-place instead. &quot;&quot;&quot; for i in range(len(s) - 1, 0, -1): s.insert(i, s.pop(0)) 取出来，插到对应位置24. 两两交换链表中的节点1234567891011121314# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def swapPairs(self, head: ListNode) -&gt; ListNode: if head and head.next: seco = head.next head.next = self.swapPairs(seco.next) seco.next = head return seco return head 交换列表中的前两个节点，也就是 head 和 head.next(seco) seco 指向 head，head 指向递归 seco.next 后返回的后序链表的头结点 返回新的头结点 seco ☄ 递推关系 118. 杨辉三角123456789class Solution: def generate(self, numRows: int) -&gt; List[List[int]]: if numRows &lt;= 1: return numRows * [[1]] prev = self.generate(numRows - 1) last = [sum(prev[-1][j-1:j+1]) for j in range(1, numRows-1)] prev.append([1, *last, 1]) return prev 首先判断特殊情况，numRows 为 0 则返回 []，为 1 返回 [[1]] 通过递归获得前几层结果 prev 通过上一层结果计算新的最后一层结果 last，f(i,j) = f(i−1, j−1) + f(i−1, j) （两边的 1 会在下一行代码中另外加） 加入新行并返回119. 杨辉三角 II12345678class Solution: def getRow(self, rowIndex: int) -&gt; List[int]: if rowIndex == 0: return [1] prev = self.getRow(rowIndex - 1) last = [sum(prev[j-1:j+1]) for j in range(1, rowIndex)] return [1, *last, 1] 和前一题基本一致206. 反转链表123456789101112# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def reverseList(self, head: ListNode, tail=None) -&gt; ListNode: if head: head.next, tail, head = tail, head, head.next return self.reverseList(head, tail) return tail 对于每一次递归，将当前节点的 next 属性指向前一个节点，然后递归调用下一个节点 如果当前节点为 None 则返回上一个节点，否则返回递归一下个节点的结果 ☄ Memoization（记忆化）技术 递归 + 记忆 = 动态规划509. 斐波那契数12345678class Solution: cache = &#123;0:0, 1:1&#125; def fib(self, N: int) -&gt; int: if N not in self.cache: self.cache[N] = sum(map(self.fib, [N - 1, N - 2])) return self.cache[N] 使用哈希记忆进行剪枝70. 爬楼梯12345678class Solution: d = &#123;0:0, 1:1, 2:2&#125; def climbStairs(self, n: int) -&gt; int: if n not in self.d: self.d[n] = sum(map(self.climbStairs, [n - 1, n - 2])) return self.d[n] 到这一层的方法数 = 到前二层方法数的总和 ☄ 复杂度分析 104. 二叉树的最大深度1234567891011121314151617# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def maxDepth(self, root: TreeNode, prev=0) -&gt; int: if not root: return 0 f = self.maxDepth l = f(root.left) r = f(root.right) return max(l, r) + 1 时间复杂度：O(N)，每次递归访问一个节点，总共N个节点 空间复杂度：O(N)，最糟糕的情况是树完全不平衡，递归开栈消耗 O(N) 空间50. Pow(x, n)1234567class Solution: def myPow(self, x: float, n: int) -&gt; float: if abs(n) &lt;= 1: return (1, x, 1/x)[n] root = self.myPow(x, n // 2) return (1, x)[n % 2] * root * root 时间复杂度：$O(\\log N)$ 空间复杂度：$O(\\log N)$ $x^4 = x^2 * x^2$， $x^5 = x^2 * x^2 * x$， 借此方法可以缩减计算量 ☄ 总结 21. 合并两个有序链表123456789101112# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode: if l1 and l2: if l1.val &gt; l2.val: l1, l2 = l2, l1 l1.next = self.mergeTwoLists(l1.next, l2) return l1 or l2 779. 第K个语法符号123class Solution: def kthGrammar(self, N: int, K: int) -&gt; int: return 0 if N == 1 else (K + 1) % 2 ^ self.kthGrammar(N - 1, (K + 1) // 2); 由于递推关系式可知第 N 行的第 K 个数计算自第 N - 1 行的第 (K + 1) // 2 个数 我们称第 N 行的第 K 个数为C，第 N - 1 行的第 (K + 1) // 2 个数为 P 0 → 01，1 → 10，可见变换后实际上是在原来的数字后加了相对的数（这里称 0 与 1 相对），那么如果 K 为奇数则 C = P，否则 C = P 的相对数95. 不同的二叉搜索树 II1234567891011121314151617# Definition for a binary tree node.class TreeNode: def __init__(self, x, l=None, r=None): self.val = x self.left = l self.right = rclass Solution: def generateTrees(self, n: int) -&gt; List[TreeNode]: def gen(num): if not num: yield None for i, n in enumerate(num): for l in gen(num[:i]): for r in gen(num[i + 1:]): yield TreeNode(n, l, r) return bool(n) * [*gen([*range(1, 1 + n)])] 构建递归生成器 gen，输入是一系列升序的数字，返回这些数字可能构成的所有二叉树结构 首先，所有数字都有可能作为根，因此遍历 num 作为根 根据二叉搜索树的特性（左子树所有节点小于根，右子树大于），可知根的左子树由比根小的数字构成，递归 num[:i] 就是左子树所有的可能结构，同理可获得右子树所有可能的结构 左右递归结果的笛卡尔积 + root，即为整棵树所有可能的结构 常用技巧总结 set 中的 in 操作时间复杂度为 O(1) dict.get 可以设置预设值，避免取到不存在的 key 时报错 遇到关于数组的问题，不妨先想想是否应该先排序 最短路径搜索问题通常使用 bfs 迭代器是缩小 space efficiency 的利器 让数字在一定范围内循环递增常常使用 % 操作 a &lt;&lt; b 相当于 a * 2**b，a &gt;&gt; b 相当于 a // 2**b a, b = a + b, a - b 的计算顺序为： a + b a - b 赋值 a 赋值 b a = b = 1 + 1 的计算顺序为： 1 + 1 赋值 a 赋值 b 隐藏的坑 遍历 set 时，输出是无序的，输出顺序可能随着计算机环境而改变 [True, False, 0].index(0) 输出为 1，因为 False == 0 为真，但 False is 0 为假 / 为浮点数除法，// 为整数除法。eg. 8 / 2.5 = 3.2, 8 // 2.5 = 3.0，注意 // 的结果不一定为整数型，a//b 的结果值等价于 math.floor(a / b) 使用记忆化技术时，字典在多个 case 之间共享，应该考虑不同 case 的 key 是否相互影响 解法汇总贡献者注：此处贡献名单仅代表汇总搜集贡献，不代表全部原创，欢迎所有更短的解法🤓 此处排名不分先后，仅以首次参与时间记录，感谢所有贡献者🤟 Knife丶[QQ1272068154 微信ly18597591102] zdylzdyl ajin grg909 Lebhoryi","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://hwame.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://hwame.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"Python捕获异常后如何对try语句重试","slug":"retry-from-try-clause-when-catch-error-in-python","date":"2020-05-27T02:11:54.000Z","updated":"2020-05-27T07:03:37.000Z","comments":true,"path":"20200527/retry-from-try-clause-when-catch-error-in-python.html","link":"","permalink":"https://hwame.top/20200527/retry-from-try-clause-when-catch-error-in-python.html","excerpt":"摘要：开发Python爬虫程序捕获异常后，如何对try语句重试，同时还需要满足对爬取数据 不重不漏 的要求。","text":"摘要：开发Python爬虫程序捕获异常后，如何对try语句重试，同时还需要满足对爬取数据 不重不漏 的要求。 文章说明文章说明：本文首发于2019-09-27@segmentfault，更新于2020-05-27@hwame.top。另请参考：segmentfault：Python中try-except出错后如何从try出错地方继续执行？另请参考：segmentfault：在python中处理错误时，在执行完except语句下的内容后是否有办法回跳到代码出错的地方继续执行文章作者：如果我可以忘记创建时间：2019-09-27更新时间：2020-05-27 1.问题背景最近在写一个爬虫程序，数据和页面很简单，没有乱七八糟的反爬措施，但是数据量很大（每页5条记录，共12w页，总记录达61w），因此会出现网络连接的问题。本着学习的目的，不借助其他爬虫框架，仅使用必需的库，包括： requests，http请求库； lxml，用于解析网页内容和结构； re，正则表达式的Python标准库，处理字符串； csv，将爬取的数据存入csv文件。 2.题目描述🌹原始方案123456789for n in range(2, pages + 1): url = base_url + &#x27;?pageSize=10&amp;pageNo=&#123;&#125;&#x27;.format(n) text = requests.get(url, headers=header).text html = etree.HTML(text) with open(filename, &quot;a&quot;, newline=&#x27;&#x27;, encoding=&#x27;GB2312&#x27;) as file: csv_file = csv.DictWriter(file, fieldnames=table_head) for row in range(1, 6): data = html.xpath(&#x27;//tbody/tr[&#x27; + str(row) + &#x27;]/td/@data-value&#x27;) csv_file.writerow(&#123;&#x27;key1&#x27;: value1, &#x27;key2&#x27;: value2, &#x27;key3&#x27;: value3,...&#125;) 这段代码对于少量数据的爬取可以完成，但是本次12w+的页面，没办法在网络断开后重试，因此需要改进。 🌹改进思路为了使其完整爬取12w+的页面，需要使用try—except语句进行异常处理。设想使其在 $[2, \\; pages + 1]$ 中的某一页（如 $i=99$ ）出错（即TimeOut连接超时）时，except捕获到这个异常，同时使程序能正确的重新爬取这一页（ $i=99$ ）。 思路1： for循环包括整个try—except语句1234567# 思路1for n in range(2, pages + 1): try: append_data_to_csv(filepath, n) print(&quot;Page &#123;&#125; finished...&quot;.format(n)) except TimeoutError as err: print(&quot;Page &#123;0&#125; failed: &#123;1&#125;&quot;.format(n, err)) 思路2： for循环只在try子句中，函数function_restarting(start_point)中有一个for循环123456789101112# 思路2def function_restarting(args): for n in range(pages + 1): parse_HTML() append_data_to_csv()start_point = 2while start_point &lt; numbers: try: function_restarting(start_point) except TimeoutError as err: print(&quot;\\tCurrent page failed: &#123;&#125;&quot;.format(err)) 3.问题描述🌷思路1存在的问题如上思路1所示，如果for循环包括了整个try—except语句，那么虽然可以继续循环，但是是从 $i=100$ 开始的， $i=99$ 被跳过了，这将导致爬取数据的缺失，不符合预期。 🌷思路2存在的问题如上思路2所示，for循环只在try里面，从起始页（start_point = 2）开始，假设仍在第99页（ $i=99$ ）出错，控制台输出信息如下：1234567.............（省略）.............Page 98 collecting...............Page 99 collecting............... Current page failed: （省略TimeoutError具体信息）Page 2 collecting...............Page 3 collecting............................（省略）.............报错打印错误信息后仍从start_point（= 2），相当于重新运行了整个程序，并没有继续从99开始，不符合预期。 🌷问题提炼问题1：怎样让他重试一次 $i=99$ 而不是直接跳过？问题2：Page 99失败后怎样继续Page 99而不是重新开始从Page 2运行？ 4.解决方案🍀思路及途径✉ 如何将发生异常时的页码记录下来并可被使用呢？ ✉ 将try—except作为函数体、页码值作为返回值！ 当except语句捕获异常时，将此时的页码 $i$ 返回，将再将该返回值赋值给start_point，以此来更新起始页，从而避免思路2中的问题。 完整的程序代码如下。 🍀完整代码12345678910111213141516171819202122232425262728293031323334353637383940import requests, re, csv, timefrom lxml import etreehead = &#123;&#x27;Cookie&#x27;: &#x27;*&#x27;, &#x27;User-Agent&#x27;: &#x27;*&#x27;&#125;url = &#x27;http://www.*.cn/**/***&#x27; # base URLpath = &#x27;D:/data/**.csv&#x27; # 爬取数据存储到csv文件的路径pages = 122422 # 总页数为12w+items = pages * 5 # 每页5条def restarting(start_point): try: for i in range(start_point, pages + 1): print(&quot;Page &#123;&#125; collecting............&quot;.format(i)) urls = url + &#x27;?searchType=simple&amp;rnum=0&amp;pageSize=10&amp;pageNo=&#123;&#125;&#x27;.format(i) text = requests.get(urls, headers=head).text html = etree.HTML(text) with open(path, &quot;a&quot;, newline=&#x27;&#x27;, encoding=&#x27;GB2312&#x27;) as file: tbhead = [&#x27;key1&#x27;, &#x27;key2&#x27;, &#x27;key3&#x27;, ...] csv_file = csv.DictWriter(file, fieldnames=tbhead) # 爬取第一个页面时，将表头写入csv文件 if i == 1: csv_file.writeheader() for n in range(1, 6): data = html.xpath(&#x27;//tbody/tr[&#x27; + str(n) + &#x27;]/td/@data-value&#x27;) csv_file.writerow(&#123;&#x27;key1&#x27;: value1, &#x27;key2&#x27;: value2, &#x27;key3&#x27;: value3, ...&#125;) except TimeoutError as err: # 打印异常信息，用正则表达式过滤字符串 print(&quot;ERROR info: &quot; + str(re.sub(r&#x27;:\\s/[a-z]&#123;5&#125;/.*&gt;&#x27;, &#x27;&#x27;, str(err)))) print(&quot;Page &#123;&#125; failed, retry in 10 seconds............\\n&quot;.format(i)) # 避免因短时间内的重试而导致同样的异常 time.sleep(10) # 记录并返回出错的页码 return i# main entranceif __name__ == &quot;__main__&quot;: start_point = 1 while start_point &lt; pages: error_at = restarting(start_point) start_point = error_at 5.后记若直接使用爬虫框架，例如scrapy等，其对异常处理有完整的处理机制。本文仅为学习之用，抱着学习的态度提供一种可行的思路。程序运行结果如下，当第10562页出错抛出异常时，能正确地重试，并使得程序继续运行。","categories":[{"name":"python","slug":"python","permalink":"https://hwame.top/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://hwame.top/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://hwame.top/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Windows使用PyCharm远程连接Linux的python环境","slug":"pycharm-connect-linux-from-windows","date":"2020-05-25T05:22:14.000Z","updated":"2020-08-28T05:59:51.000Z","comments":true,"path":"20200525/pycharm-connect-linux-from-windows.html","link":"","permalink":"https://hwame.top/20200525/pycharm-connect-linux-from-windows.html","excerpt":"摘要：由于开发需要，本地使用IDE编写代码时可能要求不同的Python环境，虚拟环境有时也不是最佳选项，如何在本地pycharm中直接连接远程服务器环境呢？","text":"摘要：由于开发需要，本地使用IDE编写代码时可能要求不同的Python环境，虚拟环境有时也不是最佳选项，如何在本地pycharm中直接连接远程服务器环境呢？ 文章说明文章来源：鴻塵文章作者：鴻塵原文链接：https://hwame.top/20200525/pycharm-connect-linux-from-windows.html 1.背景Linux服务器集群搭建在虚拟机中，阿里云服务器配置也很低，所以都没有安装GUI图形界面，要想使项目跑在Linux集群上，必须先将项目代码打包上传，然后才能运行。但是存在以下问题： 由于硬件和经济的限制，Linux虚拟机和阿里云服务器的配置都不高，没有安装图形界面，更别说IDE了 而且由于Windows和Linux本身的区别，开发调试过程中会出现不可预料的问题 Windows打包上传、Linux运行测试，流程繁琐，效率低下 因此，如果能直接在Windows的IDE中使用Linux环境，问题就会迎刃而解。注意：可能因为PyCharm专业版和社区免费版的原因而无法使用，本文使用的是PyCharm 2019.1 (Professional Edition)。 2.操作步骤 虚拟机开机。 PyCharm中新建或打开一个项目，点击“File”→“Settings”，展开至“Project: xxx”→“Project Interpreter”，可以看到所有可用的编译器以及安装的第三方库，如图所示。其中Project Interpreter为当前项目的编译器，Path mappings为当前项目路径的映射，亦即本地Windows文件与远程Linux文件的路径对应关系。并且可以有多个映射。 在配置之前只有本地的python环境和虚拟环境，当连接远程服务器后才有Linux的python环境。 点击Project Interpreter右边的设置按钮，选择Add添加Python Interpreter，可以看到能配置的编译器共有9种，我们选择SSH Interpreter，填写主机IP和用户名，如图所示。 认证方式可以选择密码或密钥对。填写正确密码或者选择密钥文件后点击next。 设置python编译器及项目文件夹映射，Interpreter选择需要使用的位于服务器上的python编译器，Sync folders为本地项目路径与远程项目路径的映射关系。详细设置及含义见后文，如图所示。 点击完成即可看到添加好的Interpreter。点击Project Interpreter右边的设置按钮，选择Show All...即可查看所有可用编译器，如图所示。 选择需要的Interpreter，点击Apply即可愉快的开发了。 3.设置python编译器及项目路径映射🌸pytho编译器服务器上运行如下命令以查看pytho编译器的位置，选择需要的： 12345678which python# /usr/bin/pythonwhich python3# /usr/bin/python3which python2# /usr/bin/python2 注意：/usr/bin/python本身也是一个软连接，指向了实际的python可执行文件路径。注意：`如果需要使用虚拟环境，则需具体到虚拟环境位置及对应的可执行文件。123456# 查看python可执行文件路径ls -lh /usr/bin | grep python# 由图可以看到：# python → python3 → python3.6# python2 → python2.7 因此，只要保证能指向正确的可执行文件即可。 🌸项目路径映射Sync folders中的&lt;Project root&gt;为本地项目的根路径，箭头右边为远程项目路径，默认为/tmp/pycharm_project_xxx，点击“右侧文件夹图标”可进行修改，如图所示。注意：可添加多对映射。 🌸文件自动上传服务器设置好python编译器和项目路径映射后，勾选“自动上传项目文件至服务器（Automatically upload project files to the server）”。当本地文件有变更时，只要有保存操作就能自动上传服务器，如图所示。 🌸关于部署配置当配置完远程python编译器后，就默认创建了部署环境，在Event Log中可以看到14:35 Deployment configuration to 39.xxx.xxx.xxx has been created.点击“File”→“Settings”，展开至“Build, Execution, Deployment”→“Deployment”，可以看到已自动设置好部署环境，可以自行修改或删除。 4.运行和调试运行和调试时，PyCharm会自动ssh连接然后运行：1234ssh://root@192.168.xx.xx:22/bin/python -u /tmp/pycharm_project_xxx/test.py******Process finished with exit code 0","categories":[{"name":"python","slug":"python","permalink":"https://hwame.top/categories/python/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://hwame.top/tags/Linux/"},{"name":"python","slug":"python","permalink":"https://hwame.top/tags/python/"}]},{"title":"CentOS7 环境变量详解","slug":"centos7-environment-variables","date":"2020-05-23T02:39:58.000Z","updated":"2020-05-23T04:34:56.000Z","comments":true,"path":"20200523/centos7-environment-variables.html","link":"","permalink":"https://hwame.top/20200523/centos7-environment-variables.html","excerpt":"摘要：文章介绍了CentOS7环境变量的相关知识，以及具体配置环境变量时的注意事项及建议。","text":"摘要：文章介绍了CentOS7环境变量的相关知识，以及具体配置环境变量时的注意事项及建议。 参考文章文章来源：C语言技术网文章作者：码农有道原文链接：https://www.cnblogs.com/wucongzhou/p/12579468.html 一、环境变量的概念1、环境变量的含义程序（操作系统命令和应用程序）的执行都需要运行环境，这个环境是由多个环境变量组成的。 2、环境变量的分类 按生效的范围分类。系统环境变量：公共的，对全部的用户都生效。用户环境变量：用户私有的、自定义的个性化设置，只对该用户生效。 按生存周期分类。永久环境变量：在环境变量脚本文件中配置，用户每次登录时会自动执行这些脚本，相当于永久生效。临时环境变量：使用时在Shell中临时定义，退出Shell后失效。 3、Linux环境变量Linux环境变量也称之为Shell环境量变，以下划线和字母打头，由下划线、字母（区分大小写）和数字组成，习惯上使用大写字母，例如PATH、HOSTNAME、LANG等。 二、常用的环境变量1、查看环境变量 env命令 echo命令 2、常用的环境变量 PATH：可执行程序的搜索目录，可执行程序包括Linux系统命令和用户的应用程序，PATH变量的具体用法本文后面的章节中有详细的介绍。 LANG：Linux系统的语言、地区、字符集，LANG变量的具体用法本文后面的章节中有详细的介绍。 HOSTNAME：服务器的主机名。 SHELL：用户当前使用的Shell解析器。 HISTSIZE：保存历史命令的数目。 USER：当前登录用户的用户名。 HOME：当前登录用户的主目录。 PWD：当前工作目录。 LD_LIBRARY_PATH：C/C++语言动态链接库文件搜索的目录，它不是Linux缺省的环境变量，但对C/C++程序员来说非常重要，具体用法本文后面的章节中有详细的介绍。 CLASSPATH：JAVA语言库文件搜索的目录，它也不是Linux缺省的环境变量，但对JAVA程序员来说非常重要，具体用法本文后面的章节中有详细的介绍。 三、设置环境量如果环境变量的值没有空格等特殊符号，可以不用单引号包含。采用export设置的环境变量，在退出Shell后就会失效，下次登录时需要重新设置。如果希望环境变量永久生效，需要在登录脚本文件中配置。 1、系统环境变量系统环境变量对全部的用户生效，设置系统环境变量有三种方法。1）在/etc/profile文件中设置。用户登录时执行/etc/profile文件中设置系统的环境变量。但是，Linux不建议在/etc/profile文件中设置系统环境变量。2）在/etc/profile.d目录中增加环境变量脚本文件，这是Linux推荐的方法。/etc/profile在每次启动时会执行/etc/profile.d下全部的脚本文件。/etc/profile.d比/etc/profile好维护，不想要什么变量直接删除/etc/profile.d下对应的shell脚本即可。3）在/etc/bashrc文件中设置环境变量。该文件配置的环境变量将会影响全部用户使用的bash shell。但是，Linux也不建议在/etc/bashrc文件中设置系统环境变量。 2、用户环境变量用户环境变量只对当前用户生效，设置用户环境变量也有多种方法。在用户的主目录，有几个特别的文件，用ls是看不见的，用ls .bash_*可以看见。1）.bash_profile（推荐首选）当用户登录时执行，每个用户都可以使用该文件来配置专属于自己的环境变量。 2）.bashrc当用户登录时以及每次打开新的Shell时该文件都将被读取，不推荐在里面配置用户专用的环境变量，因为每开一个Shell，该文件都会被读取一次，效率肯定受影响。 3）.bash_logout当每次退出系统（退出bash shell）时执行该文件。 4）.bash_history保存了当前用户使用过的历史命令。 3、环境变量脚本文件的执行顺序环境变量脚本文件的执行顺序（由上到下）如下：12345/etc/profile/etc/profile.d/etc/bashrc用户的.bash_profile用户的.bashrc同名的环境变量，如果在多个脚本中有配置，以最后执行的脚本中的配置为准。还有一个问题需要注意，在/etc/profile中执行了/etc/profile.d的脚本，所以，/etc/profile.d和/etc/profile的执行顺序还要看代码怎么写。代码如下：123456789for i in /etc/profile.d/*.sh ; do if [ -r &quot;$i&quot; ]; then if [ &quot;$&#123;-#*i&#125;&quot; != &quot;$-&quot; ]; then . &quot;$i&quot; else . &quot;$i&quot; &gt;/dev/null fi fidone 四、重要环境变量的详解1、PATH环境变量可执行程序的搜索目录，可执行程序包括Linux系统命令和用户的应用程序。如果可执行程序的目录不在PATH指定的目录中，执行时需要指定目录。1）PATH环境变量存放的是目录列表，目录之间用冒号:分隔，最后的圆点.表示当前目录。1export PATH=目录1:目录2:目录3:......目录n:.2）PATH缺省包含了Linux系统命令所在的目录/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin，如果不包含这些目录，Linux的常用命令也无法执行（要输入绝对路径才能执行）。3）在用户的.bash_profile文件中，会对PATH进行扩充，如下：1export PATH=$PATH:$HOME/bin4）如果PATH变量中没有包含圆点.，执行当前目录下的程序需要加./或使用绝对路径。 2、LANG环境变量LANG环境变量存放的是Linux系统的语言、地区、字符集，它不需要系统管理员手工设置，/etc/profile会调用/etc/profile.d/lang.sh脚本完成对PATH的设置。 CentOS6.x 字符集配置文件在/etc/syscconfig/i18n文件中。 CentOS7.x 字符集配置文件在/etc/locale.conf文件中，内容如下：1234-bash-4.2# cat /etc/locale. confLANG=zh_CN.gbk#LANG=zh_CN.utf8#LANG=zh_CN.gb18030 3、LD_LIBRARY_PATH环境变量C/C++语言动态链接库文件搜索的目录，它不是Linux缺省的环境变量，但对C/C++程序员来说非常重要。LD_LIBRARY_PATH环境变量存放的也是目录列表，目录之间用冒号:分隔，最后的圆点.表示当前目录，与PATH的格式相同。1export LD_LIBRARY_PATH=目录1:目录2:目录3:......目录n:. 4、CLASSPATHJAVA语言库文件搜索的目录，它也不是Linux缺省的环境变量，但对JAVA程序员来说非常重要。CLASSPATH环境变量存放的也是目录列表，目录之间用冒号:分隔，最后的圆点.表示当前目录，与PATH的格式相同。 五、环境变量的生效1）在Shell下，用export设置的环境变量对当前Shell立即生效，Shell退出后失效。2）在脚本文件中设置的环境变量不会立即生效，退出Shell后重新登录时才生效，或者用source命令让它立即生效，例如：1source /etc/profile 六、应用经验虽然设置环境变量的方法有多种，但是建议系统环境变量建议在/etc/profile.d目录中配置，用户环境变量在用户的.bash_profile中配置，不建议在其它脚本文件中配置环境变，会增加运维的麻烦，容易出错。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hwame.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://hwame.top/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"https://hwame.top/tags/CentOS/"}]},{"title":"Hadoop集群搭建详细步骤","slug":"bigdata-cluster-with-hadoop-scala-spark","date":"2020-05-22T09:04:39.000Z","updated":"2020-05-28T01:36:41.000Z","comments":true,"path":"20200522/bigdata-cluster-with-hadoop-scala-spark.html","link":"","permalink":"https://hwame.top/20200522/bigdata-cluster-with-hadoop-scala-spark.html","excerpt":"摘要：史上最详细的Hadoop-Spark集群搭建采坑过程，包括VMware、Linux-CentOS-7、Java/JDK、Hadoop、Scala以及Spark的安装配置，图文并茂，每一个坑都填满。","text":"摘要：史上最详细的Hadoop-Spark集群搭建采坑过程，包括VMware、Linux-CentOS-7、Java/JDK、Hadoop、Scala以及Spark的安装配置，图文并茂，每一个坑都填满。 文章说明文章来源：本文由Word文件转换而来，因此保留了原始样式，字体为宋体＋Times New Roman＋Consolas。文章说明：史上最详细的Hadoop集群搭建过程，包括VMware、Linux-CentOS-7、Java/JDK、Hadoop、Scala，以及Spark。原文共87页，字数共12497，合计29460字符，13章，段落数865，行数1335行，图片共113张。本文源码MarkDown文件字数共计47w+字符，行数2235行。更新说明：(1)原文创建于2019-12-24，更新于2020-05-22，由于时间较久，其中CentOS-7已无1908版；(2)物理机安装环境为Windows 10 1503版，升级为Windows 10 1909版后无法使用VMware Workstation 15 Pro，应升级至15.5+，安装包和注册机网盘链接为【天翼云盘，点我下载】；(3)图片足有113张，加载速度较慢，请耐心等待～～文章作者：鴻塵 1.概述1.1.软件环境1. 软件环境：VMware Workstation 15 Pro； 2. 虚拟机操作系统（清华大学开源软件镜像站-CentOS7下载），下载链接地址：https://mirrors.tuna.tsinghua.edu.cn/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1908.iso 表1.1 虚拟机中主机名及使用的镜像文件 名称 系统及文件名 master CentOS-7-x86_64-Minimal-1908.iso slave1 CentOS-7-x86_64-Minimal-1908.iso slave2 CentOS-7-x86_64-Minimal-1908.iso 3. 网络：我们实验室使用校园网有以下两种方法： 1.连接xxxx_WIRELESS，然后在弹出的网页中登陆； 2.插入网线，然后在弹出的网页中登陆。在这种情况下，如果安装的虚拟机需要联网，必须装桌面版，然后在自带的FireFox中登陆。 图1.1 登陆网络的两种方式 4. 虚拟网络采用NAT模式，详见后文。踩过的坑有很多，试过桥接模式，在Windows物理主机、Master、Slave1、Slave2四台机器之间互ping，不能保证相互ping通。 2.安装VMware Workstation安装最新版的VMware Workstation 15 Pro，注意不能直接双击安装包，而要右键“以管理员方式运行”（因为安装过程中需要创建相关VMware服务，可能会有权限的问题）。 基本是傻瓜式安装，一路下一步即可。 文件名：VMware Workstation 15 Pro 网盘链接：https://pan.baidu.com/s/1G-Z4r2sLisuYwJbuHsmPPA，提取码：gf7q 许可证密钥：YG5H2-ANZ0H-M8ERY-TXZZZ-YKRV8 文件名：VMware-workstation-full-15.5.0-14665864 网盘链接：https://pan.baidu.com/s/1ObkjLqzlY5KbAUYMErQN4g，提取码：1314 许可证密钥：GF7TA-2VGD3-08EZZ-15XGG-X7KF2（若错误则需使用注册机KeyGen.exe激活，下载地址见顶部《文章说明》） 建议：1. 尽量不要安装在C盘，更改到其他盘符；2. 取消勾选“启动时检查产品更新”和“加入客户体验提升计划”；3. 显示“VMware Workstation Pro安装向导已完成”时不要点击“完成”，应该点击“许可证”，输入上面的许可证密钥后再点击“输入”。 3.网络配置准备工作3.1.VMware设置在VMware中点击“编辑” → “虚拟网络编辑器”，点击“更改设置”，如下图。 图3.1 编辑虚拟网络 选择VMnet8（即NAT模式），如下图，点击“NAT设置”出现右图。其中，子网IP和子网掩码默认即可，网关IP将最后一位随意修改一下（与IP不同）。记住下图中的三个值： 图3.2 设置NAT模式 表3.1 虚拟机中主机名及使用的镜像文件 名称 IP地址 备注 子网IP 192.168.176.0 默认值 子网掩码 255.255.255.0 默认值 网关IP 192.168.176.x 修改x，此处的值为x=2 3.2.控制面板网络设置3.2.1.查看网卡打开控制面板 → 网络和共享中心 → 更改适配器设置，如下图。 图3.3 控制面板网络连接情况 注1：之前安装的VMware版本为VM10，出现的不是“已启用”而是“未识别的网络”，通过安装最新版本VM15解决； 注2：可以发现，上图中没有VMnet0（桥接模式），这个问题应该是打开VMware时没有选择以管理员方式运行。 3.2.2.配置虚拟网卡VMnet8双击VMnet8（NAT模式），点击“属性”，先选中“Internet协议版本4(TCP/IPv4”然后点击“属性”，选择“使用下面的IP地址”和“使用下面的DNS服务器地址”，如图所示。 图3.4 设置虚拟网卡IP段 &#xa0; 其中子网掩码和默认网关的地址和2.1节VMware设置中一致，但IP地址不和子网IP相同，比如我在这里设置为20。 3.3.查看物理主机信息按“Windows键＋R”输入“cmd”打开命令行，输入ipconfig /all，查看物理主机的Windows IP设置，如图所示。 图3.5 查看Windows物理主机IP信息 &#xa0; 可以看到，物理主机信息和VMware默认的值很不一样。这是因为Windows物理机本身是处于校园网中，获得的IP地址也是自动分配的，如果使用WiFi连接登陆则IP又不一样。此处的IP是插入网线获得的，保证IP不变。 表3.2 Windows物理主机IP信息 Windows物理主机 IP地址 备注 IPv4地址 222.20.82.252 不同于VMware及VMnet 子网掩码 255.255.252.0 不同于VMware及VMnet 默认网关 222.20.83.254 不同于VMware及VMnet DNS服务器1 202.114.0.131 默认值 DNS服务器2 202.114.0.242 默认值 &#xa0; 4.安装虚拟机4.1.安装Master4.1.1.说明1. 必须在网络配置完成后才可进行接下来的步骤。 2. 为保证以下顺利进行，需要保证VMware服务已全部开启（VM15应该无需考虑），查看是否启动步骤：此电脑右键 → 管理 → 双击服务和应用程序 → 双击服务，确保VMware相关服务的状态为“正在运行”（至少保证①Authorization Service、②NAT Service、③Workstation Server三者正在运行），如下图。 图4.1 启动VMware相关的服务 4.1.2.新建虚拟机打开“新建虚拟机向导” → 选择自定义，下一步 → 硬件兼容性默认，下一步 → 选择“稍后安装操作系统”，下一步 → 操作系统选择Linux，版本选择CentOS 7 64位，下一步 → 修改虚拟机名称【默认位置可在“编辑” → “首选项”修改，默认C盘，也可手动指定，但必须先修改位置然后命名虚拟机名称】，如下图。 图4.2 新建虚拟机向导 &#xa0; 处理器配置默认即可 → 虚拟机内存选择2048MB（如果自己电脑内存小于8G，建议默认1024MB） → 网络类型选择“网络地址转换NAT”，下一步 → I/O控制器类型和磁盘类型默认 → 选择“创建新虚拟磁盘” → 磁盘大小默认20.0GB，选择“拆分成多个文件”（由于拆分成多个文件，因此实际不会使用到20.0GB） → 指定磁盘文件默认 → 点击“自定义硬件”弹出硬件窗口，在“硬件”窗口中点击“新CD/DVD（IDE）”选中使用ISO映像文件并选择下载好的CentOS-7-x86_64-Minimal-1908.iso文件（如图4.3所示），然后点击关闭，最后点击完成。 图4.3 选择ISO映像文件 &#xa0; 4.1.3.安装虚拟机说明：因为我的集群已经搭建完成，下文以Tester为例。 图4.4 虚拟机新建完成 选中新建的虚拟机Tester，点击“开启此虚拟机”，如上图。进入安装界面，输入“chi”以筛选，然后选择中文，如下图。 图4.5 虚拟机安装界面选择语言 点击“安装位置”，无需更改，直接点击“完成”，然后点击“网络和主机名”，如下图。 图4.6 安装信息摘要 在弹出的“网络和主机名”中将主机名改为“master（此处以tester为例）”后点击“应用”，右边“当前主机名”会变为master（此处以tester为例），如图。 图4.7 修改主机名（以tester为例） 4.1.4.配置Master网络（1）修改主机名后，点击“配置”。在“以太网”选项卡中，将“设备”改为带有MAC地址的ens33（00:0C:29:03:C5:51），如下图所示。 图4.8 配置之“以太网”选项卡（以tester为例） （2）在“IPv4设置”选项卡中，首先将方法修改为“手动”，然后点击“Add”添加地址和DNS服务器。其中，master的IP地址设置为192.168.172.200（以tester为例，此处设置的是192.168.176.203）；子网掩码各节点相同（与VMware虚拟网络中的子网掩码一致），都是255.255.255.0，也可写为24，两种写法是等价的；DNS服务器地址有两个202.114.0.131和202.114.0.242，以英文逗号分隔，且无多余空格。 配置如下图所示。 图4.9 配置之“IPv4设置”选项卡（以tester为例） &#xa0; （3）在“IPv6设置”选项卡中，将方法改为“忽略”以禁用，配置完成点击“保存”。然后打开网络连接，可以看到配置生效，如图所示。 图4.10 打开以太网连接配置生效（以tester为例） （4）最后在“网络和主机名”页面点击完成，可以看到所有安装信息均已完成，如图所示，最后点击“开始安装”。 图4.11 安装信息摘要全部完成配置 4.1.5.设置root密码（1）由上开始安装后，界面如下图所示，此时必须设置root密码以完成带有警告图标的内容（只需要设置root密码，两处的标记即可正常）。 图4.12 CentOS7正在安装但尚未设置root密码 （2）点击设置root密码，如果密码强度太弱，则需要点击两次“完成”，如图所示。 图4.13 设置root密码 （3）完成root密码的设置，即使没有参加用户也不会有标记，点击“完成配置”，如图所示。 说明：在大数据集群搭建过程中，我们需要两个用户root和hadoop，目前只需要root管理员即可。 图4.14 设置root密码 &#xa0; （4）点击“完成配置”后继续等待其他必要配置完成，最后点击重启，从而启动虚拟机master（此处为tester），如图所示。 图4.15 启动CentOS虚拟机Master（此处为Tester） 4.2.安装Slave1同4.1节，将虚拟机名称设置为“Slave1”，同时将主机名修改为“slave1”，且网络配置中slave1的IP地址设置为192.168.172.201。 4.3.安装Slave2同4.1节，将虚拟机名称设置为“Slave2”，同时将主机名修改为“slave2”，且网络配置中slave2的IP地址设置为192.168.172.202。 至此，一主二次的虚拟机安装完成，如图所示（未删除测试机Tester）。 图4.16 一主二次的集群Master＋Slave1＋Slave2 &#xa0; 5.虚拟机配置5.1.设置各节点名称以Tester为例，输入并回车，按“I”键进入编辑模式。 输： [root@ tester ~] # vi /etc/sysconfig/network &#xa0; 旧：# Created by anaconda &#xa0; 新：# Created by anaconda &nbsp&nbsp&nbsp&nbspNETWORKING=yes &nbsp&nbsp&nbsp&nbspHOSTNAME=master &nbsp&nbsp&nbsp&nbspGATEWAY=192.168.176.2 编辑完成后，按“Esc”键退出编辑模式，然后按“Shift＋：”，最后输入“wq”（必须小写）并回车保存退出。 注：①内容编辑过，需要保存并退出，则输入“wq”； ②内容编辑过，不保存强制退出，则输入“q!”； ③内容未编辑过，直接退出，则输入“q”。 设置完成后各节点名称如下图所示。 图5.1 设置Master节点名称 &#xa0; 图5.2 设置Slave1节点名称 &#xa0; 图5.3 设置Slave2节点名称 &#xa0; 5.2.配置hosts以Tester为例，配置hosts。 输：[root@tester ~]#vi /etc/hosts &#xa0; 修改前原hosts文件内容为： 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 ::1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localhost localhost.localdomain localhost4 localhost4.localdomain4 修改后的hosts文件内容为： 127.0.0.1localhost localhost.localdomain localhost4 localhost4.localdomain4 ::1&nbsp;&nbsp;&nbsp;localhostlocalhost.localdomainlocalhost4localhost4.localdomain4 192.168.176.203tester 192.168.176.201slave1 192.168.176.202slave2 &#xa0; 保存之后，在Master上将该文件分别拷贝至另外两个子节点，如图5.4所示。 输：[root@master ~]#scp /etc/hosts root@192.168.176.201:/etc/ 输：[root@master ~]#scp /etc/hosts root@192.168.176.202:/etc/ 图5.4 远程拷贝hosts配置文件 &#xa0; 设置完成后各节点hosts文件都是一样的，如下图所示。 图5.5 各主机的hosts配置（Master，Slave1，Slave2相同） &#xa0; 5.3.配置各节点网卡以Tester为例，配置网卡ens33。由于在安装虚拟机的过程中已经基本配置好网络，因此只需要修改为静态IP即可（理论上，这一步也不需要，默认值是BOOTPROTO=”none”）。 查看原始网卡信息如图所示： 输：[root@tester ~]#cat /etc/sysconfig/network-scripts/ifcfg-ens33 图5.6 Tester网卡ens33信息 vi编辑此文件，将BOOTPROTO=”none”修改为BOOTPROTO=”static”，保存后重启网络： 输：[root@tester ~]#systemctl restart network &#xa0; 5.4.关闭防火墙5.4.1.以Tester为例以Tester为例，首先查看防火墙状态（status），如图所示（默认状态为开启）： 输：[root@tester ~]#systemctl status firewalld 图5.7 查看防火墙状态 说明：我们需要禁用（永久关闭）防火墙，操作operation为“disable”；如果是临时关闭，则操作operation为“stop”；开启防火墙的操作operation为“start”。 禁用后需要重启网络并重启虚拟机（或者关闭&lt;stop&gt;防火墙即可，而不需要重启虚拟机）使之生效，再次查看状态，可以发现已经禁用，如图所示。 输：[root@tester ~]#systemctl disable firewalld &#xa0; 输：[root@tester ~]#systemctl restart network &#xa0; 输：[root@tester ~]#reboot（或者）systemctl stop firewalld &#xa0; 输：[root@tester ~]#systemctl status firewalld &#xa0; 图5.8 reboot重启后再次查看防火墙状态 &#xa0; 说明：该步骤分别在Master、Slave1和Slave2上进行，禁用所有节点的防火墙。 &#xa0; 5.4.2.Master关闭防火墙截图以Tester为例，首先查看防火墙状态（status）为active（running）（因为防火墙默认是开启的），然后禁用防火墙服务，此时防火墙依然是运行状态（因为在防火墙已经是开启的状态下禁用服务，只能影响下一次，所以需要重启生效或者手动关闭防火墙）。关闭（stop）防火墙后再次查看防火墙状态，可以看到其状态为inactive（dead）。如图所示： 图5.9 Master关闭防火墙 5.5.互ping测试5.5.1.Windows物理主机打开cmd窗口，分别ping四台虚拟机（包括Tester），如图所示： 物理主机ping主节点Master： 输：C:\\Users\\鴻塵&gt;ping 192.168.176.200 &#xa0; 物理主机ping从节点Slave1： 输：C:\\Users\\鴻塵&gt;ping 192.168.176.201 &#xa0; 物理主机ping从节点Slave2： 输：C:\\Users\\鴻塵&gt;ping 192.168.176.202 &#xa0; 物理主机ping测试机Tester： 输：C:\\Users\\鴻塵&gt;ping 192.168.176.203 图5.10 Windows物理主机 5.5.2.Mater虚拟机虚拟机Mater分别ping物理主机、虚拟机Slave1、虚拟机Slave2和测试机Tester（此处未截图，实际能ping通），以及外网（百度），如图所示： 图5.11 Mater虚拟机 &#xa0; 5.5.3.Slave1虚拟机虚拟机Slave1分别ping物理主机、虚拟机Mater、虚拟机Slave2和测试机Tester（此处未截图，实际能ping通），以及外网（百度），如图所示： 图5.12 Slave1虚拟机 &#xa0; 5.5.4.Slave2虚拟机虚拟机Slave2分别ping物理主机、虚拟机Mater、虚拟机Slave1和测试机Tester（此处未截图，实际能ping通），以及外网（百度），如图所示： 图5.13 Slave2虚拟机 &#xa0; 由上，集群内三台虚拟机可以相互通信，也可以和Windows物理主机相互通信，并且可访问外网。 &#xa0; 6.JDK的安装与配置由于Hadoop的编译及MapReduce的运行都需要使用JDK，所以需要在集群中的每一台机器上提前安装好能够满足Hadoop最低版本要求的JDK。 参考文章：https://blog.csdn.net/github_38336924/article/details/82221258 6.1.检查是否已安装JDK及卸载测试机Tester未安装过Java，故以Tester为例。 检查是否已安装JDK（中括号选其一），如下图（图中没有输出信息即代表没有相关的安装文件）： 输：[root@tester ~]#yum list installed | grep [java][jdk] &#xa0; 查询已安装的包文件（中括号选其一），如下图（图中没有输出信息即代表没有相关的安装文件）： 输：[root@tester ~]#rpm -qa | grep [java][jdk][gcj] &#xa0; 图6.1 检查是否已安装JDK &#xa0; 没有Java相关的文件，因此不需要卸载。安装过程省略。 &#xa0; 6.2.Master安装JDK6.2.1.查看JDK软件包列表查看JDK软件包列表，如图所示： 输：[root@master ~]#yum search java-1.8.0 | grep –i --color jdk 图6.2 查看JDK软件包列表 &#xa0; 6.2.2安装openjdk在上图JDK软件包列表中，不需要安装所有包，只需要安装其中java-1.8.0-openjdk和java-1.8.0-openjdk-devel即可，如图所示： 输：[root@master ~]#yum install –y java-1.8.0-openjdk java-1.8.0-openjdk –devel &#xa0; 说明：yum选项加入“-y”是对所有的提问都回答“yes”，可以避免在安装过程中出现的反复确认，从而加快安装速度。java-1.8.0-openjdk和java-1.8.0-openjdk-devel两个包将被一起安装，同时所需的依赖也会被安装，如下图所示。 &#xa0; 图6.3 安装JDK 等待安装完成，可以看到java-1.8.0-openjdk和java-1.8.0-openjdk-devel已经安装，并且5个依赖包也一并被安装。 6.2.3.查看是否安装成功 输：[root@master ~]#java -version &#xa0; 输：[root@master ~]#javac -version 图6.4 成功安装JDK 说明：yum方式安装JDK，其默认路径是/usr/lib/jvm，如图所示。 图6.5 JDK安装路径 &#xa0; 6.2.4.配置环境变量编辑/etc/profile文件 输：[root@master ~]#vi /etc/profile &#xa0; 末尾处添加如下内容（文件中 # 代表注释）： JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.232.b09-0.el7_7.x86_64 PATH=\\$PATH:\\$JAVA_HOME/bin CLASSPATH=.:\\$JAVA_HOME/lib/dt.jar:\\$JAVA_HOME/lib/tools.jar export JAVA_HOME CLASSPATH PATH &#xa0; 使配置生效（也可重启虚拟机）： 输：[root@master ~]#source /etc/profile &#xa0; 使用echo命令查看JDK变量： 输：[root@master ~]#echo $JAVA_HOME &#xa0; 输：[root@master ~]#echo $PATH &#xa0; 输：[root@master ~]#echo $CLASSPATH &#xa0; 设置完成后如图所示： 图6.6 配置JDK环境变量 6.3.Slave1和Slave2安装JDK安装步骤和Master相同，也可将Master安装文件夹远程拷贝至Slave1和Slave2节点（不推荐，因为采用yum安装不仅仅在/usr/lib/jvm文件夹下，如图），按6.2节步骤即可。 图6.7 JDK安装文件位置 7.配置SSH免密码登录在 Hadoop 集群中的各个节点之间需要使用 SSH 频繁地进行通信，为了避免每次的通信都要求输入密码，需要对各个节点进行 SSH 免密码登录配置。 7.1.开启sshd密钥认证在进行SSH免密码登录配置之前，需要先开启 sshd密钥认证。编辑每一台机器（以Tester为例）的 /etc/ssh/sshd_config 文件，去掉原文件下面这3行前的“#”注释。 旧：①# RSAAuthentication &nbsp;&nbsp;&nbsp;&nbsp;yes &nbsp;&nbsp;②# PubkeyAuthentication &nbsp;yes &nbsp;&nbsp;③# AuthorizedKeysFile.ssh/authorized_keys 注意：/etc/ssh/sshd_config文件内容如图所示，可以看到只有上述三行中的②③行，并没有①# RSAAuthentication yes。这是因为第1代ssh通讯协议使用的配置项RSA认证（RSAAuthentication）已废除，第2代ssh通讯协议的密钥验证是PubkeyAuthentication。而且第③行默认是开启的（如图第47行），故只需去掉上述第②行的注释（对应文件第43行，如图所示）。参考文章：https://www.cnblogs.com/Leroscox/p/9627809.html 图7.1 sshd配置文件 &#xa0; 综上所述，编辑 /etc/ssh/sshd_config 文件，去掉第43行注释即可，如上图①处。另外，按上述文章，还应允许root认证登陆（PermitRootLogin），去掉第38行注释即可，如上图③处。 输：[root@tester ~]#vi /etc/ssh/sshd_config &#xa0; 设置完成保存后，重启sshd服务： 输：[root@tester ~]#systemctl restart sshd 注：每个节点都需要配置。 &#xa0; 7.2.创建免密码登录账户由于Hadoop 集群中的各节点默认会使用当前的账号SSH免密码登录其它节点，所以需要在每个节点中创建一个相同的供 Hadoop 集群专用的账户，我们使用的账户为 hadoop 。 注：每个节点都需要创建hadoop用户，至此每个节点拥有root和hadoop两个用户。 创建用户： 输：[root@tester ~]#useradd hadoop &#xa0; 设置密码： 输：[root@tester ~]#passwd hadoop &#xa0; 如图所示： 图7.2 创建hadoop用户并设置密码 &#xa0; 7.3.生成公钥密钥对在每个节点上分别执行（以Tester为例）： 首先切换到hadoop用户（注意提示符，# 表示root用户，$ 表示一般用户）： 输：[root@tester ~]#su hadoop &#xa0; 然后输入以下命令，根据提示按三次回车键直到生成结束，如图所示。 输：[hadoop@tester root]$ ssh-keygen -t rsa &#xa0; 图7.3 Tester节点上生成公钥密钥对 &#xa0; 在Master、Slave1和Slave2三个节点上分别都执行上述步骤后（以hadoop用户身份），会在每个节点的/home/hadoop/.ssh目录下自动生成两个文件id_rsa和id_rsa.pub，其中前者为私钥，后者为公钥，如上图所示。 Slave1节点上生成公钥密钥对如下图所示。 图7.4 Slave1节点上创建hadoop用户并生成公钥密钥对 &#xa0; Slave2节点上生成公钥密钥对如下图所示。 图7.5 Slave2节点上创建hadoop用户并生成公钥密钥对 7.4.将公钥导入认证文件密钥生成之后，需要将每台机器的公钥都拷贝到主节点的认证文件 authorized_keys 中，以下操作都在主节点Master上由hadoop用户完成（如图7-6所示）。 ①将Master的公钥导入主节点的认证文件中： 输：[hadoop@master ~]$ cat /home/hadoop/.ssh/id_rsa.pub &gt;&gt; /home/hadoop/.ssh/authorized_keys ②将Slave1的公钥导入主节点的认证文件中（根据提示输入“yes”及密码）： 输：[hadoop@master ~]$ ssh hadoop@slave1 cat /home/hadoop/.ssh/id_rsa.pub &gt;&gt; /home/hadoop/.ssh/authorized_keys ③将Slave2的公钥导入主节点的认证文件中（根据提示输入“yes”及密码）： 输：[hadoop@master ~]$ ssh hadoop@slave2 cat /home/hadoop/.ssh/id_rsa.pub &gt;&gt; /home/hadoop/.ssh/authorized_keys ④各节点的公钥导入完成后，查看认证文件内容，可以看到各个节点的hadoop用户的公钥信息，如图7-6所示。 输：[hadoop@master ~]$ cat /home/hadoop/.ssh/authorized_keys 图7.6 将每台机器的公钥都拷贝到主节点的认证文件中 7.5.设置权限并补全Master信息在 Master 主机上执行如下命令，对认证文件的操作权限进行设置，如图7.7所示： 输：[hadoop@master ~]$ chmod 700 /home/hadoop/.ssh 输：[hadoop@master ~]$ chmod 600 /home/hadoop/.ssh/authorized_keys 查看known_hosts文件中主机列表，发现只有Slave1和Slave2而没有Master自身（如图7.7所示箭头处），所以需要在Master主机上ssh免密登录自己，将自身的主机信息添加到known_hosts列表中。 输：[hadoop@master ~]$ ssh master 注意：登陆成功后的状态是以hadoop@master的身份ssh登陆hadoop@master，所以提示符都是[hadoop@master ~]$。登陆成功后即将其信息写入到known_hosts文件中（注意ssh登陆时的警告），所以还要输入exit退出远程登陆回到当前的hadoop@master身份。 退出后，再次查看known_hosts文件中，可以看到已成功将Master节点信息写入其主机列表中，如图所示。 图7.7 设置认证文件权限并在known_hosts中补全Master信息 &#xa0; 7.6.将认证文件复制到slave节点在 Master 主机上执行以下命令将生成的 authorized_keys 文件从 Master 主机复制到 Slave1 和 Slave2 节点，如图7.8所示。 输：[hadoop@master ~]$ scp /home/hadoop/.ssh/authorized_keys hadoop@slave1:/home/hadoop/.ssh/authorized_keys 输：[hadoop@master ~]$ scp /home/hadoop/.ssh/authorized_keys hadoop@slave2:/home/hadoop/.ssh/authorized_keys 在 Master 主机上测试ssh远程登陆Slave1 和 Slave2 节点，如图7.8所示，可以发现不需要登陆密码了。 输：[hadoop@master ~]$ ssh slave1 输：[hadoop@master ~]$ ssh slave2 图7.8 将认证文件复制到其他节点并远程登陆测试 &#xa0; 在 Master 主机上执行以下命令将生成的 known_hosts 文件从 Master 主机复制到 Slave1 和 Slave2 节点。 输：[hadoop@master ~]$ scp /home/hadoop/.ssh/known_hosts hadoop@slave1:/home/hadoop/.ssh/known_hosts 输：[hadoop@master ~]$ scp /home/hadoop/.ssh/ known_hosts hadoop@slave2:/home/hadoop/.ssh/known_hosts &#xa0; 7.7.设置从节点认证文件权限设置从节点Slave1认证文件权限： 输：[hadoop@slave1 ~]$ chmod 700 /home/hadoop/.ssh 输：[hadoop@slave1 ~]$ chmod 600 /home/hadoop/.ssh/authorized_keys &#xa0; 设置从节点Slave2认证文件权限： 输：[hadoop@slave2 ~]$ chmod 700 /home/hadoop/.ssh 输：[hadoop@slave2 ~]$ chmod 600 /home/hadoop/.ssh/authorized_keys 7.8.三节点互相ssh登陆测试Master登陆Slave1及Slave2，如下图所示： 图7.9 Master登陆Slave1及Slave2 Slave1登陆Master及Slave2，如下图所示： 图7.10 Slave1登陆Master及Slave2 Slave2登陆Master及Slave1，如下图所示： 图7.11 Slave2登陆Master及Slave1 &#xa0; 8.安装HadoopHadoop安装其实就是一个将下载好的Hadoop压缩包解压到所有服务器上并进行配置的过程，推荐将Hadoop安装在各个节点服务器的相同目录下方便配置。 我们使用的Hadoop版本是hadoop-2.7.7，指定的Hadoop的安装目录（以root身份安装）是/usr/local/hadoop-2.7.7。 8.1.下载压缩包可从官网下载压缩包，下载地址： https://www-us.apache.org/dist/hadoop/common/hadoop-2.7.7/hadoop-2.7.7.tar.gz 推荐从本地镜像站点下载，不仅稳定而且下载速度比较快。可从清华大学镜像站下载压缩包（耗时38s），下载地址： https://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-2.7.7/hadoop-2.7.7.tar.gz &#xa0; 利用wget下载，必须首先安装wget（以测试机Tester为例）： 输：[root@tester ~]# yum –y install wget &#xa0; 注意：利用wget下载是将文件下载到当前目录，因此要先进入 /usr/local 目录，然后执行下载命令，如下图所示。 输：[root@tester ~]# cd /usr/local &#xa0; 输：[root@tester local]# wget https://mirrors.tuna.tsinghua.edu.cn/apache/ hadoop/common/hadoop-2.7.7/hadoop-2.7.7.tar.gz &#xa0; 下载完成后，在/usr/local路径下就有了该压缩包，如下图所示。 图8.1 Tester下载Hadoop压缩包 &#xa0; 8.2.解压Hadoop压缩包执行以下命令解压Hadoop压缩包： 输：[root@tester local]# tar zxvf hadoop-2.7.7.tar.gz &#xa0; 等待解压完成，会在当前目录/usr/local多出一个hadoop-2.7.7文件夹，里面即为解压的内容，如下图所示。 图8.2 解压Hadoop压缩包 &#xa0; 8.3.更改用户组由于解压时使用的是 root 账户，所以还需要执行以下命令将Hadoop的安装目录的所有者和所属组改为 hadoop，如下图所示： 输：[root@tester local]# chown -R hadoop:hadoop /usr/local/hadoop-2.7.7 &#xa0; 注①：在图8.3中，查看文件详细信息中的所有者和所属组，第一个root为所属用户（User），第二个root为所属组（Group）。 注②：安装Hadoop、Scala和Spark时，都是以root用户的身份安装，但在实际中操作Hadoop是以hadoop用户的身份运行的，因此在Hadoop、Scala和Spark安装完成后都需要更改用户组（后文也有说明）。 图8.3 更改用户组 8.4.配置环境变量编辑配置文件 /etc/profile 以配置环境变量： 输：[root@tester local]# vi /etc/profile 在末尾处加入以下内容： export HADOOP_HOME=/usr/local/hadoop-2.7.7 PATH=\\$PATH:\\$HOME/.local/bin:\\$HOME/bin:\\$HADOOP_HOME/bin:$HADOOP_HOME/sbin export PATH 保存退出后，使之生效： 输：[root@tester local]# source /etc/profile 由此完成安装，查看Hadoop版本信息： 输：[root@tester local]# hadoop version 说明：由于Tester未安装java环境（见6.1），因此看不到Hadoop版本信息，输出错误信息：Error: JAVA_HOME is not set and could not be found，如图所示。 图8.4 配置hadoop环境变量 &#xa0; 8.5.实际安装Hadoop的说明8.5.1.安装位置的问题Master安装Hadoop时，在 /usr/local 目录下新建了一个文件夹 hadoop-2.7.7，使得将压缩包放到了/usr/local/hadoop-2.7.7下而不是 /usr/local，导致解压后变成了/usr/local/hadoop-2.7.7/hadoop-2.7.7，而不是/usr/local/hadoop-2.7.7，如图所示（图中应该是创建/usr/local文件夹）。 图8.5 Master下载Hadoop压缩包（标注有误） 利用scp远程拷贝文件时也犯了同样的错误，都是拷贝到了/usr/local/hadoop-2.7.7下，如图所示： 图8.6 Master远程上传Hadoop压缩包至Slave1及Slave2（位置错误） &#xa0; 图8.7 Slave1节点传输前后（位置错误） &#xa0; 图8.8 Slave2节点传输前后（位置错误） &#xa0; 8.5.2解决安装位置的问题对于每个节点，首先将位于/usr/local/hadoop-2.7.7下的压缩包移动到/usr/local，然后删除hadoop-2.7.7文件夹，如下图所示（截图为Slave2）： 图8.9 解决安装位置的问题 解压完成后删除压缩包，如图所示（截图为Slave2）： 图8.10 解压完成后删除压缩包 &#xa0; 8.5.3.各个节点①更改位置，如上8.5.2节； ②解压hadoop-2.7.7.tar.gz文件，完成后删除压缩包； ③更改用户组为hadoop； ④配置环境变量并使之生效； ⑤查看Hadoop版本。 设置完成后如图8.11~8.13所示： 图8.11 Master节点 图8.12 Slave1节点 图8.13 Slave2节点 &#xa0; 8.5.4.从节点Hadoop的安装当主节点Master安装完成后，可以直接利用scp将整个/usr/local/hadoop-2.7.7文件夹传到从节点Slave1和Slave2，而不需要再次安装。 &#xa0; 9.配置Hadoop集群Hadoop集群的配置文件位于/usr/local/hadoop-2.7.7/etc/hadoop文件夹下，默认配置不需要修改，主要配置节点的个性配置，即①core-site.xml，②hdfs-site.xml，③mapred-site.xml.template和④yarn-site.xml四个文件，以及⑤slaves和⑥hadoop-env.sh两个文件，如下图所示。 图9.1 需要配置的6个文件 9.1.配置core-site.xml编辑Hadoop配置文件/usr/local/hadoop-2.7.7/etc/hadoop/core-site.xml，在&lt;configuration&gt;和&lt;/configuration&gt;之间加入以下配置内容，如图所示（其中，按“Tab”键缩进，&lt;!— xxx —&gt;的内容为注释）： &lt;configuration&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- The name of the default file system --&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;property&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.defaultFS&lt;/name&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;hdfs://master:9000&lt;/value&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- The size of buffer for use in sequence files --&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;property&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;io.file.buffer.size&lt;/name&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;131072&lt;/value&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- A base for other temporary directories --&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;property&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;file:/usr/local/hadoop-2.7.7/tmp&lt;/value&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt; &lt;/configuration&gt; 图9.2 配置core-site.xml文件 &#xa0; 9.2.配置hdfs-site.xml编辑/usr/local/hadoop-2.7.7/etc/hadoop/hdfs-site.xml文件，加入以下配置内容，如图9.3所示： &lt;configuration&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;property&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;file:/usr/local/hadoop-2.7.7/data/namespace&lt;/value&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;final&gt;true&lt;/final&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;Path on the local filesystem where the NameNode stores&lt;/description&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt; &#xa0; &nbsp;&nbsp;&nbsp;&nbsp;&lt;property&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;/usr/local/hadoop-2.7.7/data/dataspace&lt;/value&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;final&gt;true&lt;/final&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;Path on the local filesystem where the DataNode stores Data&lt;/description&gt;/span> &nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt; &#xa0; &nbsp;&nbsp;&nbsp;&nbsp;&lt;property&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt;/span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;slave1:50090&lt;/value&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;final&gt;true&lt;/final&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;The secondary namenode http server address and port&lt;/description&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt; &#xa0; &nbsp;&nbsp;&nbsp;&nbsp;&lt;property&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;dfs.webhdfs.enabled&lt;/name&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;true&lt;/value&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;final&gt;true&lt;/final&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;Enable WebHDFS (REST API) in Namenodes and Datanodes&lt;/description&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt; &#xa0; &nbsp;&nbsp;&nbsp;&nbsp;&lt;property&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;dfs.permissions&lt;/name&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;false&lt;/value&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;final&gt;true&lt;/final&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;Disable permission checking in HDFS&lt;/description&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt; &#xa0; &nbsp;&nbsp;&nbsp;&nbsp;&lt;property&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;dfs.replication&lt;/name&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;2&lt;/value&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;final&gt;true&lt;/final&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;Default block replication&lt;/description&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt; &lt;/configuration&gt; 图9.3 配置hdfs-site.xml文件 &#xa0; 9.3.配置mapred-site.xml编辑/usr/local/hadoop-2.7.7/etc/hadoop/mapred-site.xml.template文件，加入以下配置内容，如图9.4所示： 说明：此模板文件mapred-site.xml.template应将其重命名为mapred-site.xml。 &lt;configuration&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;property&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;mapreduce.framework.name&lt;/name&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;yarn&lt;/value&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;final&gt;true&lt;/final&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;The runtime framework for executing MapReduce jobs&lt;/description&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt; &lt;/configuration&gt; 图9.4 配置mapred-site.xml.template文件 &#xa0; 9.4.配置yarn-site.xml编辑/usr/local/hadoop-2.7.7/etc/hadoop/yarn-site.xml文件，加入以下配置内容，如图9.5所示： &lt;configuration&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;property&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;slave2:8030&lt;/value&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;final&gt;true&lt;/final&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;The address of the scheduler interface&lt;/description&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt; &#xa0; &nbsp;&nbsp;&nbsp;&nbsp;&lt;property&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;yarn.resourcemanager.resource-tracker.address&lt;/name&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;slave2:8031&lt;/value&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;final&gt;true&lt;/final&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;The address and port of Resource Manager of YARN at Slave2&lt;/description&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt; &#xa0; &nbsp;&nbsp;&nbsp;&nbsp;&lt;property&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;yarn.resourcemanager.address&lt;/name&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;slave2:8032&lt;/value&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;final&gt;true&lt;/final&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;The address of the applications manager interface in the RM&lt;/description&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt; &#xa0; &nbsp;&nbsp;&nbsp;&nbsp;&lt;property&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;yarn.resourcemanager.admin.address&lt;/name&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;slave2:8033&lt;/value&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;final&gt;true&lt;/final&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;The address of the RM admin interface&lt;/description&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt; &#xa0; &nbsp;&nbsp;&nbsp;&nbsp;&lt;property&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;slave2:8088&lt;/value&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;final&gt;true&lt;/final&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;The http address of the RM web application&lt;/description&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt; &#xa0; &nbsp;&nbsp;&nbsp;&nbsp;&lt;property&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;mapreduce_shuffle&lt;/value&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;final&gt;true&lt;/final&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;Node Manager of YARN&lt;/description&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt; &lt;/configuration&gt; 图9.5 配置yarn-site.xml文件 &#xa0; 9.5.配置slaves编辑/usr/local/hadoop-2.7.7/etc/hadoop/slaves文件，删除原有的localhost（也可以直接注释掉）加入以下内容，如下图所示： 输：[root@master ~]#vi /usr/local/hadoop-2.7.7/etc/hadoop/slaves &#xa0; 旧：localhost &#xa0; 新：master &nbsp;&nbsp;&nbsp;&nbsp;slave1 &nbsp;&nbsp;&nbsp;&nbsp;slave2 图9.6 配置slaves文件 &#xa0; 9.6.配置hadoop-env.sh编辑/usr/local/hadoop-2.7.7/etc/hadoop/hadoop-env.sh文件，将“# The java implementation to use.”下的“export JAVA_HOME=${JAVA_HOME}”修改为：export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.232.b09-0.el7_7.x86_64。 其中，路径/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.232.b09-0.el7_7.x86_64为安装Java时设置的环境变量（见6.2.4节），如下图所示。 图9.7 配置hadoop-env.sh文件 &#xa0; 9.7.将配置分发到其他节点上述9.1~9.6都是在主节点Master上配置，因此需要将其分发到Slave1和Slave2两个从节点，如图所示。 输：[root@master ~]#scp -r /usr/local/hadoop-2.7.7/etc/hadoop/* slave1:/usr/local/hadoop-2.7.7/etc/hadoop/ &#xa0; 输：[root@master ~]#scp -r /usr/local/hadoop-2.7.7/etc/hadoop/* slave2:/usr/local/hadoop-2.7.7/etc/hadoop/ 图9.8 将Master配置分发到Slave1和Slave2节点 &#xa0; 说明：上图中，尚未配置/usr/local/hadoop-2.7.7/etc/hadoop/hadoop-env.sh文件，因此scp后需要对每个节点的hadoop-env.sh文件进行配置。若先将Master上的此文件配置好，然后scp到从节点，则不需在从节点上配置该文件。 &#xa0; 10.操作Hadoop集群说明：以下操作Hadoop集群都是使用hadoop用户，提示符为[hadoop@master ~]$。 10.1.格式化NameNode第一次启动HDFS需要先进行格式化，使用格式为“$HADOOP_PREFIX/bin/hdfs namenode -format &lt;cluster_name&gt;”的如下命令： 输：[hadoop@master ~]$ hdfs namenode -format master &#xa0; 等待Master格式化完成，出现Exiting with status 0的信息即为格式化成功，如图10.1所示。 图10.1 格式化NameNode 10.2.启动HDFS集群HDFS格式化完成后，使用格式为“$HADOOP_PREFIX/sbin/start-dfs.sh”的如下命令来启动HDFS集群，如图所示： 输：[hadoop@master ~]$ start-dfs.sh 说明：使用该命令启动HDFS集群时，在集群的任意节点上执行都能够启动集群。 图10.2 在Master上启动HDFS集群 此时，各节点jps进程如表10.1所示，如图10.2、图10.3、图10.4所示。 图10.3 Slave1上jps进程 &#xa0; 图10.4 Slave2上jps进程 &#xa0; 表10.1 Master启动HDFS集群后各节点上jps进程 名称 jps进程 master Jps，NameNode，DataNode slave1 Jps，SecondaryNameNode，DataNode slave2 Jps，DataNode 此时可在浏览器中打开http://192.168.176.200:50070查看HDFS的管理界面，如图所示。 图10.5 浏览器查看HDFS的管理界面 10.3.启动YARN启动HDFS后，使用格式为“$HADOOP_PREFIX/sbin/start-yarn.sh”的如下命令来启动YARN，如图所示： 输：[hadoop@slave2 ~]$ start-yarn.sh 说明：在使用 start-yarn.sh 命令启动YARN集群时，必须在ResourceManager所在节点Slave2上执行该命令才能够启动 ResourceManager；当 Namenode和ResourceManger不在同一台主机时，就不能在NameNode上启动 YARN了，应该在ResouceManager所在的机器Slave2上启动YARN。 图10.6 在Slave2上启动YARN集群 &#xa0; 此时，各节点jps进程如表10.2所示，如图10.6、图10.7、图10.8所示。 表10.2 Master启动HDFS集群后各节点上jps进程（红色表示新增） 名称 jps进程 master Jps，NameNode，DataNode，NodeManager slave1 Jps，SecondaryNameNode，DataNode，NodeManager slave2 Jps，DataNode，ResourceManager，NodeManager &#xa0; 图10.7 Master上jps进程 &#xa0; 图10.8 Slave1上jps进程 &#xa0; 此时可在浏览器中打开http://192.168.176.202:8088查看YARN的管理界面，如图所示。 图10.9 浏览器查看YARN的管理界面 11.各节点scala安装11.1.主节点Master上安装scala11.1.1下载scala打开scala官网：http://www.scala-lang.org/download/2.12.10.html，找到对应版本，如图所示，对应的下载链接为：https://downloads.lightbend.com/scala/2.12.10/scala-2.12.10.tgz。 图11.1 scala官网 scala安装路径是/usr/local/scala-2.12.10。首先进入安装目录/usr/local，使用wget下载，如图所示： 输：[root@master ~]# cd /usr/local &#xa0; 输：[root@master local]# wget https://downloads.lightbend.com/scala/2.12.10/scala-2.12.10.tgz &#xa0; 图11.2 下载scala &#xa0; 由于没有采用镜像站点资源下载，因此下载速度较慢，耐心等待下载完成。下载完成后会在当前目录生成scala文件：/usr/local/scala-2.12.10.tgz。 &#xa0; 11.1.2解压scala压缩包解压scala到当前文件夹，如下图11.3所示： 输：[root@master local]# tar –zvxf scala-2.12.10.tgz &#xa0; 解压完成后，会在当前目录创建文件夹/usr/local/scala-2.12.10，scala压缩包内的所有文件都被解压到该目录。 解压完成后，删除原压缩包，执行如下命令： 输：[root@master local]# rm –f scala-2.12.10.tgz 说明：删除命令选项“–f”表示强制删除，删除过程中没有“是否确认删除”的提示。慎用此选项，尽量只在删除有很多子文件夹时配合“–r”（递归处理）使用。 图11.3 解压scala &#xa0; 11.1.3配置scala环境变量配置scala环境变量，加入export PATH=$PATH:/usr/local/scala-2.12.10/bin，如图所示： 输：[root@master local]# vi /etc/profile &#xa0; scala环境变量配置完成后，使之生效，如图所示： 输：[root@master local]# source /etc/profile &#xa0; 至此，Master上scala安装完成，查看scala版本，如图所示： 输：[root@master local]# scala -version 图11.4 配置scala环境变量 &#xa0; 11.2从节点上安装scala11.2.1.scp传输scala安装文件将主节点Master上安装好的scala文件夹利用scp传到从节点Slave1和Slave2上，如下图11.5所示： 输：[root@master local]# scp –r scala-2.12.10 slave1:/usr/local &#xa0; 输：[root@master local]# scp –r scala-2.12.10 slave2:/usr/local 注意：此处使用的是相对路径，因为当前目录为/usr/local，也可使用如下命令（绝对路径）来传输，二者没有区别： 输：[root@master local]# scp –r /usr/local/scala-2.12.10 slave1:/usr/local &#xa0; 输：[root@master local]# scp –r /usr/local/scala-2.12.10 slave2:/usr/local 图11.5 Master上scp传输scala到从节点Slave1和Slave2 11.2.2配置环境变量scp传输完成后，在Slave1上配置scala环境变量，步骤同11.1.3节，如图所示： 图11.6 Slave1配置scala环境变量 scp传输完成后，在Slave2上配置scala环境变量，步骤同11.1.3节，如图所示： 图11.7 Slave2配置scala环境变量 &#xa0; 12.Spark安装及配置12.1.主节点Master上安装spark12.1.1下载spark压缩包清华大学镜像站下载spark-2.4.4-bin-hadoop2.7.tgz文件，如图所示，其下载链接为：https://mirrors.tuna.tsinghua.edu.cn/apache/spark/spark-2.4.4/spark-2.4.4-bin-hadoop2.7.tgz。 spark的安装路径是/usr/local/ spark-2.4.4-bin-hadoop2.7。首先进入安装目录/usr/local，使用wget下载，如图所示： 输：[root@master ~]# cd /usr/local &#xa0; 输：[root@master local]# wget https://mirrors.tuna.tsinghua.edu.cn/apache/spark/spark-2.4.4/spark-2.4.4-bin-hadoop2.7.tgz 图12.1 下载spark 12.1.2.解压spark压缩包解压spark到当前文件夹，如图所示： 输：[root@master local]# tar –zvxf spark-2.4.4-bin-hadoop2.7.tgz 图12.2 解压spark 解压完成后，删除原压缩包。 &#xa0; 12.1.3.修改spark配置文件配置文件路径为/usr/local/spark-2.4.4-bin-hadoop2.7/conf，如图所示，并且将spark-env.sh.template重命名为spark-env.sh。 图12.3 spark配置文件 &#xa0; 然后修改配置文件spark-env.sh，如图12.4所示。 输：[root@master ~]# vi /usr/local/spark-2.4.4-bin-hadoop2.7/conf/spark- env.sh 图12.4 修改spark配置文件spark-env.sh &#xa0; 在末尾加上如下红色字体内容（其中JAVA_HOME应与java安装时的配置保持一致，黑色字体为注释），如图12.4所示： # 配置JAVA_HOME，一般来说，不配置也可以，但是可能会出现问题，最好还是配上 # 配置JAVA_HOME应与java安装时的配置保持一致，见6.2.4节 export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.232.b09-0.el7_7.x86_64&#xa0; # 一般来说，spark任务有很大可能性需要去HDFS上读取文件，所以配置上 # 如果说你的spark就读取本地文件，也不需要yarn管理，则不用配 export HADOOP_CONF_DIR=/usr/local/hadoop-2.7.7/etc/hadoop &#xa0; # 设置Master的主机名 export SPARK_MASTER_HOST=master &#xa0; # 提交Application的端口，默认就是这个，万一要改就改这里 export SPARK_MASTER_PORT=7077 &#xa0; # 每一个Worker最多可以使用的cpu core的个数，我虚拟机就一个... # 真实服务器如果有32个，你可以设置为32个 export SPARK_WORKER_CORES=1 &#xa0; # 每一个Worker最多可以使用的内存，虚拟机设置的是2G # 真实服务器如果有128G，你可以设置为100G export SPARK_WORKER_MEMORY=1g &#xa0; 12.1.4.修改slaves文件如图12.3，首先将slaves.template重命名为slaves，然后修改slaves文件，删除或注释掉“localhost”，加入三台节点的主机名，如图所示。 图12.5 修改slaves文件内容 12.1.5.配置spark环境变量配置spark环境变量： 输：[root@master ~]# vi /etc/profile&#xa0; 加入如下内容： export SPARK_HOME=/usr/local/spark-2.4.4-bin-hadoop2.7 export PATH=\\$PATH:\\$SPARK_HOME/bin:\\$SPARK_HOME/sbin &#xa0; spark环境变量配置完成后，使之生效，如图12.6所示： 输：[root@master ~]# source /etc/profile&#xa0; 图12.6 配置spark环境变量并启动 &#xa0; 输入以下命令启动Spark，如图12.6所示： 输：[root@master local]# spark-shell&#xa0; 12.2.从节点上安装spark12.2.1.scp传输spark安装文件将主节点Master上安装好的spark利用scp传到从节点Slave1和Slave2上，如图所示： 输：[root@master local]# scp –r spark-2.4.4-bin-hadoop2.7 slave1:/usr/local&#xa0; 输：[root@master local]# scp –r spark-2.4.4-bin-hadoop2.7 slave2:/usr/local 注意：此处使用的是相对路径，因为当前目录为/usr/local，也可使用绝对路径。 &#xa0; 图12.7 Master上scp传输spark到从节点Slave1和Slave2 &#xa0; &#xa0; &#xa0; 12.2.2.配置spark环境变量（1）Slave1节点配置spark环境变量 scp传输完成后，在Slave1上配置spark环境变量，步骤同12.1.5节。 Slave1节点上spark环境变量配置完成后，输入以下命令启动Spark，如图所示： 输：[root@slave1 local]# spark-shell&#xa0; 图12.8 Slave1配置spark环境变量并启动 &#xa0; （2）Slave2节点配置spark环境变量 scp传输完成后，在Slave2上配置spark环境变量，步骤同12.1.5节。 Slave2节点上spark环境变量配置完成后，输入以下命令启动Spark，如图12.9所示： 输：[root@slave2 local]# spark-shell&#xa0; 图12.9 Slave2配置spark环境变量并启动 说明：退出scala时需输入“:quit”，上图是spark-shell下的命令行，界面与scala下的命令行不同，如图所示。 图12.10 scala下的命令行 &#xa0; 12.3.修改spark-env.sh在每个节点上改正spark-env.sh的错误（如图12.4），将最后一行“ecport”修改为“export”。 配置文件路径为/usr/local/spark-2.4.4-bin-hadoop2.7/conf/spark-env.sh，如下图所示。 图12.11 改正spark-env.sh配置文件 &#xa0; 13.启动Spark集群参考：https://www.cnblogs.com/ZJdiem/p/11664634.html 13.1.说明Hadoop、Scala和Spark都是安装在/usr/local文件夹下，如图13.1~13.3所示。 由于安装时是以root身份安装的，但操作Hadoop相关的东西时是以hadoop用户，因此会产生权限的问题，所以需要登陆root账号，更改用户组为hadoop用户，见8.3节。 从图中可以看到，Hadoop的所有者和用户组正常（因为安装Hadoop时已经修改过），而Scala和Spark的所有者和用户组则不对，后文修改。 图13.1 主节点Master的Hadoop、Scala和Spark信息 图13.2 从节点Slave1的Hadoop、Scala和Spark信息 图13.3 从节点Slave2的Hadoop、Scala和Spark信息 &#xa0; 13.2.更改Scala和Spark的用户组13.2.1.主节点Master在Master上执行以下命令将Scala和Spark的安装目录的所有者和所属组改为hadoop用户，如图13.4所示： 输：[root@master local]# chown -R hadoop:hadoop /usr/local/scala-2.12.10&#xa0; 输：[root@master local]# chown -R hadoop:hadoop /usr/local/spark-2.4.4-bin-hadoop2.7&#xa0; 说明：由于前面安装Spark时已经更改过，因此只需要更改Scala安装目录的所有者和所属组，如图13.4所示。由图可知，修改前，scala的用户组为2000、spark的用户组为hadoop；修改后，scala的用户组为hadoop、spark的用户组为hadoop。 图13.4 Master的Scala和Spark的用户组 &#xa0; 13.2.2.从节点Slave1在Slave1上执行以下命令将Scala和Spark的安装目录的所有者和所属组改为hadoop用户，如图13.5所示： 输：[root@slave1 local]# chown -R hadoop:hadoop /usr/local/scala-2.12.10&#xa0; 输：[root@slave1 local]# chown -R hadoop:hadoop /usr/local/spark-2.4.4-bin-hadoop2.7&#xa0; 由图可知，修改前，scala和spark的用户组均为root；修改后，scala和spark的用户组为hadoop。 图13.5 Slave1的Scala和Spark的用户组 &#xa0; 13.2.3.从节点Slave2在Slave2上执行以下命令（此处使用的是相对路径）将Scala和Spark的安装目录的所有者和所属组改为hadoop用户，如图13.6所示： 输：[root@slave2 local]# chown -R hadoop:hadoop scala-2.12.10 &#xa0; 输：[root@slave2 local]# chown -R hadoop:hadoop spark-2.4.4-bin-hadoop2.7 &#xa0; 由图可知，修改前，scala和spark的用户组均为root；修改后，scala和spark的用户组为hadoop。 图13.6 Slave2的Scala和Spark的用户组 &#xa0; 13.3.启动Hadoop集群注意：启动Spark集群之前必须先启动Hadoop集群。 首先以hadoop用户身份登陆，然后在主节点Master上运行start-dfs.sh启动HDFS集群（此时各节点jps进程如表13.1所示），最后在从节点Slave2上运行start-yarn.sh启动YARN集群（此时各节点jps进程如表13.1所示），如图所示。 图13.7 Master启动HDFS集群 图13.8 Slave2启动YARN集群 &#xa0; 13.4.启动Spark集群注意：启动Spark集群之前必须先启动Hadoop集群。 Hadoop集群启动后，首先在Master节点进入spark目录，然后启动Spark集群，如图： 输：[hadoop@master ~]$ cd /usr/local/spark-2.4.4-bin-hadoop2.7 &#xa0; 输：[hadoop@master spark-2.4.4-bin-hadoop2.7]$sbin/start-master.sh &#xa0; 输：[hadoop@master spark-2.4.4-bin-hadoop2.7]$sbin/start-slaves.sh 图13.9 Master启动Spark集群 至此，Spark集群启动完成，此时主节点Master上jps进程如图13.9所示，从节点Slave1和Slave2上jps进程如图13.10所示，各节点集群启动前后jps进程如表13.1所示。 图13.10 从节点Slave1和Slave2上jps进程 &#xa0; 表13.1 启动集群后各节点上jps进程 节点名称 Master启动HDFS Slave2启动YARN Master启动Spark master Jps，NameNode，DataNode Jps，NameNode，DataNode NodeManager Jps，NameNode，DataNode NodeManager Master，Worker slave1 Jps，SecondaryNameNode，DataNode Jps，SecondaryNameNode，DataNode NodeManager Jps，SecondaryNameNode，DataNode NodeManager Worker slave2 Jps，DataNode Jps，DataNode ResourceManager，NodeManager Jps，DataNode ResourceManager，NodeManager Worker 注：表中不同颜色代表启动不同集群后增加的jps进程，其中绿色为Master启动HDFS集群后增加的进程，洋红为Slave2启动YARN集群后增加的进程，绿色为Master启动Spark集群后增加的进程；单元格内容为启动不同集群后各节点所有的jps进程。 &#xa0; 此时可在浏览器中打开http://192.168.176.200:8080，查看Spark集群的管理界面，如下图13.11所示。 同时，HDFS的管理界面为http://192.168.176.200:50070，见10.2节图10.5；YARN的管理界面为http://192.168.176.202:8088，见10.3节图10.9。 图13.11 浏览器查看Spark的管理界面 &#xa0;&#xa0;至此，集群搭建完毕。&#xa0;","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hwame.top/categories/Linux/"}],"tags":[{"name":"Spark","slug":"Spark","permalink":"https://hwame.top/tags/Spark/"},{"name":"大数据","slug":"大数据","permalink":"https://hwame.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"Nginx配置与uWSGI配置详解","slug":"configuration-of-nginx-and-uwsgi","date":"2020-05-22T00:18:48.000Z","updated":"2020-07-02T09:29:09.000Z","comments":true,"path":"20200522/configuration-of-nginx-and-uwsgi.html","link":"","permalink":"https://hwame.top/20200522/configuration-of-nginx-and-uwsgi.html","excerpt":"摘要：文章介绍了Nginx与uWSGI的知识，并依具体的例子对Web应用进行详细配置。","text":"摘要：文章介绍了Nginx与uWSGI的知识，并依具体的例子对Web应用进行详细配置。 文章说明文章作者：鴻塵文章链接：https://hwame.top/20200522/configuration-of-nginx-and-uwsgi.html 一、Nginx配置文件1.指令Nginx配置文件包含指定指令控制的模块，指令分为 简单指令 和 块指令 ，如果块指令大括号内有其他指令，就被称为一个 上下文 ，比如events, http, server, location等。 简单指令：由名称和参数组成，以空格分隔，并以分号结尾；块指令：具有和简单指令相同的结构，以大括号包围的一堆附加指令结束。指令： nginx -t不运行，仅测试配置文件；nginx -c config_path从指定路径加载配置文件；nginx -t -c config_path测试指定配置文件。 2.控制命令启动Nginx：nginx [-c config_path]，默认配置目录为/etc/nginx/nginx.conf。查看信息：nginx -v，查看版本信息；nginx -V，查看详细信息。查看进程：ps -ef | grep nginx，利用管道命令查看进程，ps命令用法参见：【Linux命令大全】控制Nginx：nginx -s signal，参数signal有stop, quit, reload，分别表示快速关闭、优雅关闭、重载配置系统管理：systemctl option nginx，参数option有status, start, stop, enable, disable，分别表示查看状态、启动服务、关闭服务、设置开机自启、禁止开机自启 3.文件详情nginx.conf文件位置：默认位于/etc/nginx/nginx.conf，此乃默认配置文件，服务启动基于该文件。原文内容：12345678910111213141516171819202122232425262728user nginx;worker_processes 1;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;events &#123; worker-connections 1024 ; &#125;http &#123; include /etc/nginx/mime.types; default_type appplication/octet-stream; log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; &#125; 文件结构： 为结构清晰，特删掉大括号，······处表示块指令。 1234567891011main 【全局设置】events 【指定工作模式，连接配置上限】 ······http 【http的配置】 ······ upstream xxx 【负载均衡配置】 ······ server 【主机设置】 ······ location 【URL匹配】 ······ 参数详解： main user：worker进程运行的用户和组 worker_processes：指定开启的子进程数，建议设置为与CPU数相等 error_log：用来定义全局错误日志文件，如原文中路径为/var/log/nginx/error.log，级别level有debug, info, notice, warn, error, crit pid：指定进程ID的存储文件位置 events use：指定Nginx工作模式，①epoll=高效工作模式，Linux，默认，②kqueue=高效工作模式，BSD，③poll=标准模式，④epoll=标准模式 worker_connections：每个进程的最大连接数，其中$正向代理=连接数×进程数$，$反向代理=\\frac{1}{4}\\times\\text{连接数}\\times\\text{进程数}$【Linux系统限制最多能同时打开$65535=2^{16}$个文件，亦即默认上限，能以ulimit -n 65535解除】 http最核心的模块，主要负责http服务器相关配置，包含server和upstream子模块，见后文 include：第12行include mime.types设置文件的mime类型为/etc/nginx/mime.types所定义的类型，第27行xxx.config包含其他配置文件（分开规划解耦作用）的server default_type：设置默认类型，当文件类型未知时将使用默认（注：octet-stream=八进制字节流） log_format：设置日志格式 access_log：访问日志，中间为日志路径，最后main为日志格式log_format中的main sendfile：设置高效文件传输模式 keepalive_timeout：设置客户端连接活跃超时 gzip：gzip压缩 核心模块http： upstream子模块，负载均衡，多服务器反向代理 server ip:port weight=1：指定反向代理服务器及分流权重 server子模块，用来指定虚拟主机 listen 80;：指定虚拟主机监听的端口，80端口表示http server_name localhost;：指定ip地址或域名，多个域名以空格分隔 charset utf-8：指定网页的默认编码格式 error_page 500 502 /50x.html;：指定错误页面，见/etc/nginx/conf.d/*.conf即default.conf access_log xxx main;：指定虚拟主机的访问日志存放路径 error_log xxx main;：指定虚拟主机的错误日志存放路径 root xxx;：指定虚拟主机的根目录 index xxx;：指定默认主页 location：核心【server】中的核心【location】，后面主要就是配置这里，支持正则匹配和条件，其主要功能是定位和解析URL、实现动静分离。语法格式：location [modifier] uri &#123;指令 xxx&#125;，可选修饰符modifier表示定位URL的方式：①=，使用精确匹配并且终止搜索②~，区分大小写的正则③~*，不区分大小写的正则④^~，最佳匹配通常用来匹配目录（非正则匹配）；常用指令为alias，alias定义了location的别名（需要在文件系统中能够找到），如果location指定了正则表达式，alias将会应用正则表达式中的捕获，alias替代location中匹配的部分，没有匹配的部分将在文件系统中搜索 default.conf文件位置：位于/etc/nginx/conf.d/nginx.conf，只包含一个server模块。Nginx服务启动时由nginx.conf通过include /etc/nginx/conf.d/*.conf;引用其内容（即server），从而实现解耦。原文内容：123456789101112131415161718192021222324252627282930313233343536373839404142434445server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log /var/log/nginx/host.access.log main; location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&#x27;s document root # concurs with nginx&#x27;s one # #location ~ /\\.ht &#123; # deny all; #&#125;&#125; 二、uwsgi配置文件1.命令启动：uwsgi --ini uwsgi.ini，当前目录（项目目录）下新建ini文件停止：uwsgi --stop uwsgi.pid，uWSGI服务器启动后在当前目录自动生成pid文件，无需新建 2.文件详情文件位置：位于[Project_Dir]/uwsgi.ini，此乃用户建立的配置文件，uwsgi服务启动基于该文件。文件内容：123456789101112131415161718192021222324252627[uwsgi]# 用于nginx与uwsgi对接时的uwsgi配置# (1)使用nginx连接时，使用socketsocket = ip:port# (2)直接作为web服务器使用(相当于测试，(1)(2)二选一)#http = ip:port# (3)配置工程目录，wsgi-file为入口文件，此用于Flaskchdir = [Project_Absolute_dir]wsgi-file = app.py# routercallable = app_flask_instance# (4)配置项目的wsgi目录，相对于工程目录(3)，此用于Django#chdir = [Project_Absolute_dir]#wsgi-file = Project_name/wsgi.py#Note: unlike Flask, wsgi.py generated by Django automaticly# (5)配置进程和线程信息processes = 4threads = 10enable-threads = Truemaster = Truepidfile = uwsgi.piddaemonize = uwsgi.log 三、项目部署1.项目描述项目位置：位于/usr/local/flask_covid/项目文件：主要包括app.py，spider.py，static/css+js/，templates/main.html，以及测试静态路由的文本文件static/mmdd.md。 2.配置准备 将Nginx默认的配置文件/etc/nginx/nginx.conf和/etc/nginx/conf.d/default.conf复制到项目根目录下，default.conf用处不大（只需用到少量内容） 编辑配置文件/usr/local/flask_covid/nginx.conf【若因非root用户修改而出现权限问题，则需修改文件权限】，将default.conf内容去注释后复制到nginx.conf中的include /etc/nginx/conf.d/*.conf;处【由于将default配置转移过来了，所以不需要include语句来引用，删除之】，nginx.conf内容为： 1234567891011121314151617···omit text above···#include /etc/nginx/conf.d/*.conf;#Copy &quot;server &#123;...&#125;&quot; from file=&quot;default.conf&quot;server &#123; listen 80; server_name localhost; #charset koi8-r; location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125; location = /50x.html &#123; root /usr/share/nginx/html; &#125; &#125; #Copy and replace over. 继续编辑配置文件/usr/local/flask_covid/nginx.conf，文件如上，修改如下： (1)修改字符集：charset utf-8; (2)将root移动到上一级server下，并修改路径为项目的绝对路径：root /usr/local/flask_covid; (3)修改URL静态路由的解析：首先将location / &#123;···&#125;修改为location /static &#123;···&#125;，以便于访问./static静态资源【注：ppt18，当client请求发出请求时，由Nginx直接提供静态资源，由uwsgi通过Nginx提供动态资源，后者才是真正意义上的代理】，然后为其内容设置别名alias [Project_Absolute_dir]/static; (4)由于默认用户为user nginx;时进程master_process = root, worker_process = nginx，为了避免请求静态资源时出现的因权限不够而请求失败的问题，故需修改用户：user root; 此时在项目目录下执行nginx -c /usr/local/flask_covid/nginx.conf启动Nginx服务器，于是可以在浏览器中输入http://ip/static/file_name（不加端口号）访问到静态资源，就如同操作文件夹一样【实测成功，直接下载到了./static/mmdd.md文件，并且./static文件夹下的所有资源皆可访问到】。修改后nginx.conf内容为： 123456789101112131415161718192021222324252627282930313233343536373839user root;worker_processes 1;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;events &#123; worker-connections 1024 ; &#125;http &#123; include /etc/nginx/mime.types; default_type appplication/octet-stream; log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; #include /etc/nginx/conf.d/*.conf; # ********** VERY IMPORTANT PARAGRAPH ********** #Copy &quot;server &#123;...&#125;&quot; from file=&quot;default.conf&quot; server &#123; listen 80; server_name localhost; charset utf-8; root /usr/local/flask_covid; location /static &#123; alias /usr/local/flask_covid/static; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125; &#125; #Copy and replace over. &#125; 至此测试成功 3.uWSGI配置 安装uwsgi：pip install uwsgi 工程目录下创建uwsgi.ini配置文件并添加配置信息，见2.2 个性化修改如下： 部署时用(1)，测试时用(2)，ip设置为0.0.0.0保证所有人可以访问，端口号与app.py相同； Flask项目用(3)，Django项目用(4)，配置工程目录chdir为项目完整绝对路径，并与nginx.conf的server → root相同：chdir = /usr/local/flask_covid；wsgi-file为项目启动文件【注：Django项目会自动生成./[Project_Name/wsgi.py]】； 配置进程和线程，其中enable-threads表示线程可用 修改完成后uwsgi.ini内容为： 12345678910111213141516171819202122232425[uwsgi]# 用于nginx与uwsgi对接时的uwsgi配置# (1)使用nginx连接时，使用socketsocket = 0.0.0.0:5000# (2)直接作为web服务器使用(相当于测试，部署时与(1)二选一)#http = 0.0.0.0:5000# (3)配置工程目录，wsgi-file为入口文件，callable为flask实例，此用于Flaskchdir = /usr/local/flask_covidwsgi-file = app.py# routercallable = app# (4)配置项目的wsgi目录，相对于工程目录(3)，此用于Django#chdir = /usr/local/flask_covid#wsgi-file = flask_covid/wsgi.py#Note: unlike flask, wsgi.py generated by Django automaticly# (5)配置进程和线程信息processes = 2threads = 4enable-threads = Truemaster = Truepidfile = uwsgi.piddaemonize = uwsgi.log 使用uWSGI服务器： 启动：uwsgi --ini uwsgi.ini，不能加sudo 停止：uwsgi --stop uwsgi.pid，uWSGI服务器启动后在当前目录自动生成pid文件，无需新建 测试（打开(2)、关闭(1)）：启动 Nginx和uWSGI服务器，出现[uWSGI] getting INI configuration from /usr/local/flask_covid/uwsgi.ini的信息表明 uWSGI配置成功，此时可以在浏览器中输入http://ip:port（加端口号）访问 部署（打开(1)、关闭(2)）：见3.2 4.Nginx配置 首先停止3.3的测试：uwsgi --stop /usr/local/flask_covid/uwsgi.pid【注：如果无法停止并报错：signal_pidfile()/kill(): No such process [core/uwsgi.c line 1693]，首先利用ps -ef | grep uwsgi查询其进程号，然后将uwsgi.pid文件修改为相应进程号，最后执行停止命令】 部署时，uWSGI与 Nginx的对接依赖于/etc/nginx/uwsgi_params文件，该文件在安装uwsgi时自动生成，其定义了一系列的uwsgi参数 编辑配置文件/usr/local/flask_covid/nginx.conf，在原来配置好了的静态文件下配置首页目录，location定位和解析的URL/就表示首页，然后利用include去对接uwsgi_params文件，uwsgi_pass去关联localhost【因为uWSGI与 服务器同属一个地方】，端口号port必须与3.3uwsgi.ini的socket一致，如下所示： 1234567location /static &#123; alias xxx/static/; &#125;location / &#123; include /etc/nginx/uwsgi_params; uwsgi_pass localhost:5000; &#125; 由于修改了Nginx配置，因此需要先关闭服务nginx -s quit，然后重新启动：nginx -c /usr/local/flask_covid/nginx.conf 启动uWSGI服务器：uwsgi --ini /usr/local/flask_covid/uwsgi.ini 此时nginx与uwsgi便对接成功，可以在浏览器中输入http://ip（不加端口号）进行访问【由于location /&#123;...&#125;下面有uwsgi_pass localhost:8000进行转发代理，自动加上port，因此不能加端口号】 四、总结建议不建议改变Nginx默认的配置文件/etc/nginx/nginx.conf的位置，当部署大型项目时，或有多个服务需要同时运行，则将导致配置文件的混乱，且难以使用系统服务管理工具systemctl，建议的做法是针对具体的项目，在/etc/nginx/conf.d/目录下创建具有标识性的独用于本项目的配置文件myproject.conf，便于维护。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hwame.top/categories/Linux/"}],"tags":[{"name":"Linux部署","slug":"Linux部署","permalink":"https://hwame.top/tags/Linux%E9%83%A8%E7%BD%B2/"}]},{"title":"如何使matplotlib同时使用宋体和Times New Roman","slug":"customize-matplotlib-fonts","date":"2020-05-21T02:38:22.000Z","updated":"2020-05-21T12:20:05.000Z","comments":true,"path":"20200521/customize-matplotlib-fonts.html","link":"","permalink":"https://hwame.top/20200521/customize-matplotlib-fonts.html","excerpt":"摘要：一般论文要求中文宋体、西文Times New Roman，因此为了规范排版，有必要解决它。然而对于matplotlib的绘图网上并没有完美的解决方案，所谓的办法都是清一色的「黑体」，因此本文寻求了一种替代方案作为折中。","text":"摘要：一般论文要求中文宋体、西文Times New Roman，因此为了规范排版，有必要解决它。然而对于matplotlib的绘图网上并没有完美的解决方案，所谓的办法都是清一色的「黑体」，因此本文寻求了一种替代方案作为折中。 文章说明文章说明：本文首发于2019-12-15@知乎，更新于2020-05-21@GitPages。另请参考：知乎：用Python的matplotlib画图，怎么保证xlabel中中文用宋体，英文用新罗马？另请参考：知乎：Matplotlib 中英文及公式字体设置——【文章作者：cherichy@知乎】文章作者：如果我可以忘记创建时间：2019-12-15更新时间：2020-05-21 写在前面写在前面：抱着对自己说话负责的态度：此题无解。 但是，我们真的对他没辙儿了吗？非也。两种思路：①找到一种字体TimesSong.ttf；②寻找一种替代品，退而求其次。 作为一枚标准处女座，这个问题也困扰了我好久。一般论文中字体中文要求宋体、西文［英文＋数字］要求Times New Roman，因此为了规范排版，有必要解决它。 说明：下文配置中的步骤尽量简写，默认为大家知道如何修改配置文件matplotlibrc，大家可以看看我在SegmentFault思否提问的帖子：SegmentFault问答：matplotlib字体配置问题。 以下详谈。 不想看的直接拉到末尾&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 思路一：找到一种字体TimesSong.ttf（随意取名）这种思路是有根据的，因为经我测试（见下文），matplotlib只能同时支持一种字体，而宋体和Times New Roman是“不兼容”（描述不准，意会即可）的，我们能否将宋体和Times New Roman这两种字体合并为新的字体TimesSong.ttf呢？ 获得TimesSong.ttf字体后，将其添加到D:\\Python3.7.3\\Lib\\site-packages\\matplotlib\\mpl-data\\fonts\\ttf文件夹、写入matplotlibrc文件，保存后删除缓存C:\\Users\\鴻塵.matplotlib即可。 此法理论可行，但是我不知道怎么合并字体（据说违法，版权什么的…），有兴趣的小伙伴可以试试［其实我试过，但那个软件无法激活］。 思路二：寻找一种替代品：STSong话不多说，先上图看看： 代码如下：123&gt;&gt;&gt; import matplotlib.pyplot as plt &gt;&gt;&gt; plt.title(u&#x27;今天是2019.12.14，Saturday&#x27;) &gt;&gt;&gt; plt.xlabel(r&#x27;LaTex公式$+\\sum_&#123;n=0&#125;^&#123;\\infty&#125;\\frac&#123;1&#125;&#123;(2n+1)^2&#125;=\\frac&#123;\\pi^2&#125;&#123;8&#125;$&#x27;)不仅能中英混输，而且连LaTex公式都可以。 同样，人应该对自己说的话负责： ①公式显示我修改过配置文件：mathtext.fontset : stix ［备注： Should be ‘dejavusans’ (default), ‘dejavuserif’, ‘cm’ (Computer Modern), ‘stix’, ‘stixsans’ or ‘custom’］； ②公式中的西文字体可正常显示，因为stix字体集就是适配Times（可能是Times New Roman，记不清）字体的，但是中文不行，所以我在上图里中文是没有包含在美元符号里的，如果置于$$内将报错：Font ‘rm’ does not have a glyph for ‘\\u5417’ [U+5417], substituting with a dummy symbol。理论上，可修改字体集为自定义custom然后修改每一个特定字体，但我偷懒直接改的整个字体集。 回到正文，图中可以看出，STSong字体还是比较符合我们的预期的，所谓“退而求其次”嘛，总比网上清一色的“SimHei”的敷衍式的不负责任的回答要好得多。 所以推荐大家采用和我相同的配置（见下）。 回答完毕，下文填坑。 1. 测试字体列表由于我修改过配置文件matplotlibrc，所以说行数可能不准确，因此以官网A sample matplotlibrc file为准：matplotlib官方教程。 文件169行说： The font.family property has five values: xx, xx, xx, xx, and xx. Each of these font families has a default list of font names in decreasing order of priority associated with them. When text.usetex is False, font.family may also be one or more concrete font names. 翻译：font.family属性有五个值。这些字体系列中的每一个都有一个默认的字体名称列表，按照与其相关联的优先级的降序排列。当text.usetex属性为False时，font.family也可以是一个或多个具体的字体名称。 这段话告诉我们，指定font.family的属性值（一般为sans-serif&lt;默认&gt;或serif）后，就可以将209行font.serif或210行font.sans-serif对应的字体名默认列表default list of font names调整顺序（优先级priority），使得优先显示前面的字体。但是这段话也误导了我：是不是意味着当第一个字体失败时自动使用第二种字体呢？ 插句题外话，根据百度百科的解释，Sans-serif是专指西文中没有衬线的字体，与汉字字体中的黑体相对应。 原来如此，这么看就能对应上了。 首先，将198行的#font.family : sans-serif改为font.family : serif（没有行内代码很难受），根据百科的话中文应为衬线字体。 然后，将209行#font.serif : DejaVu Serif, Bitstream Vera Serif, Computer Modern Roman, New Century Schoolbook, Century Schoolbook L, Utopia, ITC Bookman, Bookman, Nimbus Roman No9 L, Times New Roman, Times, Palatino, Charter, serif（看到没，本来就有Times New Roman的）改为font.serif : STSong, SimSun, Times New Roman, Times,DejaVu Serif, Bitstream Vera Serif, Computer Modern Roman, New Century Schoolbook, Century Schoolbook L, Utopia, ITC Bookman, Bookman, Nimbus Roman No9 L, Palatino, Charter, serif，调整顺序嘛，STSong优先级最高，应为它是唯一能最大程度满足要求的字体。 注意：修改配置文件是一劳永逸的办法，启动Python即可用，如果在Python里以1&gt;&gt;&gt; plt.rcParams[&#x27;font.serif&#x27;] = [&#x27;STSong&#x27;]的方式修改，只能影响当前环境，退出Python即失效。 经我测试，无法使两种字体同时生效，但优先级确实可以解决部分问题。 单个字体：①Times New Roman；②Times；③SimSun；④STSong 123456789101112131415161718&gt;&gt;&gt; plt.rcParams[&#x27;font.serif&#x27;] = [&#x27;Times New Roman&#x27;] &gt;&gt;&gt; plt.title(u&#x27;字体Python2019&#x27;) &gt;&gt;&gt; # 不报错，但中文显示异常（显示为□□），西文正常且符合要求 &gt;&gt;&gt; plt.rcParams[&#x27;font.serif&#x27;] = [&#x27;Times&#x27;] &gt;&gt;&gt; plt.title(u&#x27;字体Python2019&#x27;) &gt;&gt;&gt; # 报错：findfont: Font family [&#x27;serif&#x27;] not found. Falling back to DejaVu Sans. &gt;&gt;&gt; # 中英文显示均异常，不属于上述四种之一（Times字体？不认识，有点像加粗的黑体） &gt;&gt;&gt; # 第二次也没有报错，不知为何 &gt;&gt;&gt; plt.rcParams[&#x27;font.serif&#x27;] = [&#x27;SimSun&#x27;] &gt;&gt;&gt; plt.title(u&#x27;字体Python2019&#x27;) &gt;&gt;&gt; # 不报错，中英文皆为宋体 &gt;&gt;&gt; plt.rcParams[&#x27;font.serif&#x27;] = [&#x27;STSong&#x27;] &gt;&gt;&gt; plt.title(u&#x27;字体Python2019&#x27;) &gt;&gt;&gt; # 不报错，中英文皆为STSong &gt;&gt;&gt; # 此为最佳方案 两种字体：①Times New Roman＋SimSun；②Times New Roman＋STSong；③Times＋SimSun；④Times＋STSong。 1234567891011121314151617&gt;&gt;&gt; plt.rcParams[&#x27;font.serif&#x27;] = [&#x27;Times New Roman&#x27;,&#x27;SimSun&#x27;] &gt;&gt;&gt; plt.title(u&#x27;字体Python2019&#x27;) &gt;&gt;&gt; # 第一次报错：RuntimeWarning: Glyph 20307 missing from current font. &gt;&gt;&gt; # 第二次没有报错，两次显示效果一样 &gt;&gt;&gt; # 但中文显示异常（显示为□□），西文正常为Times New Roman &gt;&gt;&gt; plt.rcParams[&#x27;font.serif&#x27;] = [&#x27;Times New Roman&#x27;,&#x27;STSong&#x27;] &gt;&gt;&gt; plt.title(u&#x27;字体Python2019&#x27;) &gt;&gt;&gt; # 不报错，中文异常、西文正常 &gt;&gt;&gt; plt.rcParams[&#x27;font.serif&#x27;] = [&#x27;Times&#x27;,&#x27;SimSun&#x27;] &gt;&gt;&gt; plt.title(u&#x27;字体Python2019&#x27;) &gt;&gt;&gt; # 不报错，中英文皆为宋体 &gt;&gt;&gt; plt.rcParams[&#x27;font.serif&#x27;] = [&#x27;Times&#x27;,&#x27;STSong&#x27;] &gt;&gt;&gt; plt.title(u&#x27;字体Python2019&#x27;) &gt;&gt;&gt; # 不报错，中英文皆为STSong 由上测试可知，不论是两种字体还是一种字体，好像都取决于列表中的第一个。但是上述两种字体的后两种测试又似乎说明了“优先级”的问题：单[‘Times’]时报错了一次，双[‘Times’,’SimSun/STSong’]时按第二个。能否理解为Times失效继而采用SimSun/STSong呢？ 2.LaTex公式文件264行说： The following settings allow you to select the fonts in math mode. They map from a TeX font name to a fontconfig font pattern. These settings are only used if mathtext.fontset is ‘custom’. 翻译：以下设置允许你在数学模式中选择字体，它们从TeX字体名称映射到fontconfig字体模式。这些设置仅在mathtext.fontset为“自定义”时使用。 这段话告诉我们，最好别乱改以下这几个属性（含义参考LaTeX 各种命令，符号）： cal＝手写体；rm＝罗马体；tt＝打字机字体；it＝意大利斜体；bf＝正粗体；sf＝无衬线字体。123456#mathtext.cal : cursive #mathtext.rm : sans #mathtext.tt : monospace #mathtext.it : sans:italic #mathtext.bf : sans:bold #mathtext.sf : sans若非必要，请勿更改，直接将fontset改为stix即可。 3.其他上文中的STSong字体即华文宋体，有知友有没有一种组合字体，中文是宋体，英文是times new roman？ - 知乎用户的回答说： 华文宋体、方正书宋、方正新书宋、思源宋体、Adobe宋体，这些都是原生搭配好的。 经我在Word里测试，与“宋体＋Times New Roman”最接近的只有华文宋体（注意：由于电脑没有安装方正宋体、方正新书宋和思源宋体，故以黑体代替并填充绿色；另Adobe宋体名称为Adobe宋体StdL）。 除上述修改外，文件329行的axes.unicode_minus属性应改为False以正常显示符号。 4.总结 退出Python，删除用户目录下的缓存文件（C:\\Users\\鴻塵.matplotlib整个文件夹）； 修改配置文件matplotlibrc（D:\\Python3.7.3\\Lib\\site-packages\\matplotlib\\mpl-data\\matplotlibrc）； 第198行：原文#font.family : sans-serif，修改font.family : serif； 第209行：原文#font.serif : DejaVu Serif, Bitstream Vera Serif, Computer Modern Roman, New Century Schoolbook, Century Schoolbook L, Utopia, ITC Bookman, Bookman, Nimbus Roman No9 L, Times New Roman, Times, Palatino, Charter, serif，修改font.serif : STSong, SimSun, Times New Roman, Times, DejaVu Serif, Bitstream Vera Serif, Computer Modern Roman, New Century Schoolbook, Century Schoolbook L, Utopia, ITC Bookman, Bookman, Nimbus Roman No9 L, Palatino, Charter, serif； 第275行：原文#mathtext.fontset : dejavusans，修改mathtext.fontset : stix； 第329行：原文#axes.unicode_minus : True，修改axes.unicode_minus : False； 保存退出（上述四个位置修改时切记去掉注释符）。 说明： 此方法修改是基于配置文件matplotlibrc的，一经修改永久生效且影响全局字体，但仍可在具体应用时plt.rcParams[‘xxx’]=[‘xxx’]动态修改； 公式字体是独立的，不受其他设置影响，公式字体不支持中文（stix集不支持），应用时若有需要可以将中文放在美元号外，若中文必须在$$内，可尝试mathtext.fontset = custom后再修改类似于mathtext.rm : sans的相关属性（根据报错提示修改）； 除修改matplotlibrc文件外，我还拷了Times New Roman、宋体等好几种字体到D:\\Python3.7.3\\Lib\\site-packages\\matplotlib\\mpl-data\\fonts\\ttf文件夹下，但似乎这一步不需要（未经考证）； matplotlib版本为3.1.0，Python版本为3.7.3，有知友说需要修改D:\\Python3.7.3\\Lib\\site-packages\\matplotlib\\font_manager.py文件 上述办法只算是蒙混过关，不算解决方案，后续若有更好的再来更新； 知乎首答，比较混乱，有很多重复，大家能看懂就行。","categories":[{"name":"python","slug":"python","permalink":"https://hwame.top/categories/python/"}],"tags":[{"name":"matplotlib","slug":"matplotlib","permalink":"https://hwame.top/tags/matplotlib/"},{"name":"python","slug":"python","permalink":"https://hwame.top/tags/python/"}]},{"title":"Hexo博客搭建(4)——常见问题","slug":"hello-hexo-troubleshooting","date":"2020-05-20T12:20:05.000Z","updated":"2020-11-30T05:22:28.000Z","comments":true,"path":"20200520/hello-hexo-troubleshooting.html","link":"","permalink":"https://hwame.top/20200520/hello-hexo-troubleshooting.html","excerpt":"摘要：这部分内容主要对博客做最后的完善，包括魔改部分页面和拯救强迫症。","text":"摘要：这部分内容主要对博客做最后的完善，包括魔改部分页面和拯救强迫症。 Hexo博客搭建博客系列：Hexo博客搭建(1)——建站及部署，环境搭建并部署至Github。博客系列：Hexo博客搭建(2)——主题配置，针对pure主题进行个性化配置。博客系列：Hexo博客搭建(3)——优化评论系统，主要对Valine评论系统进行优化。博客系列：Hexo博客搭建(4)——常见问题，修复了pure主题的系列小bug。文章作者：鴻塵 1.如何使其支持Mathjax参考文章：如何在 hexo 中支持 Mathjax？注： Mathjax公式中*号表示斜体，\\times才表示乘号× 1.使用Kramed代替MarkedHexo默认的渲染引擎是marked，但是marked不支持mathjax公式，kramed是在marked的基础上进行修改。执行以下命令卸载marked、安装kramed： 12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 然后修改./node_modules/hexo-renderer-kramed/lib/renderer.js第65行函数的return部分： 123456// Change inline math rulefunction formatText(text) &#123; // Fit kramed&#x27;s rule: $$ + \\1 + $$ // return text.replace(/`\\$(.*?)\\$`/g, &#x27;$$$$$1$$$$&#x27;); return text;&#125; 2.停用hexo-math卸载hexo-math，安装hexo-renderer-mathjax【GitHub地址】： 12npm uninstall hexo-math --savenpm install hexo-renderer-mathjax --save 3.更新Mathjax的 CDN 链接修改./node_modules/hexo-renderer-mathjax/mathjax.html最后一行的&lt;script&gt;标签的src属性： 1&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt; 4.更改默认转义规则因为Hexo默认的转义规则会将一些字符进行转义，比如_转为&lt;em&gt;，所以我们需要对默认的规则进行修改，文件路径为./node_modules/kramed/lib/rules/inline.js： 1234567# 第11行（上为原文，下为修改）escape: /^\\\\([\\\\`*&#123;&#125;\\[\\]()#$+\\-.!_&gt;])/,escape: /^\\\\([`*\\[\\]()# +\\-.!_&gt;])/,# 第20行（上为原文，下为修改）em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 5.开启Mathjax 在站点配置文件_config.yml中开启Mathjax，在文件末尾添加如下代码：12mathjax: enable: true 在已发布的文章*.md文件的Front-matter中开启mathjax：123456---title: xxxcategory: xxxdate: 2020-10-14 21:24:15mathjax: true--- 可修改./scaffolds/post.md模板文件，在Front-matter中开启Mathjax：mathjax: true。 6.重新生成页面修改完成后清除缓存、重新生成页面、部署，「一键三连」即可。 2.如何更改左侧IconFont 图标 主题配置文件默认的有github，微博，twitter，facebook等，但可能与自己需求不同，故需定制需要就加上，不需要就注释，4~6个为宜可用参考：适配IconFont 图标 第一步：vi ./themes/pure/_config.yml第二步：profile → social → links层级下对应修改：123456789101112131415161718192021222324# profileprofile: ...... social: links: github: https://github.com/hwame weibo: https://weibo.com/hwamei # twitter: https://twitter.com # facebook: https://facebook.com zhihu: https://www.zhihu.com/people/hwame # dribbble: / # behance: https://www.behance.net # rss: atom.xml segmentfault: https://segmentfault.com/u/hwame gitee: https://gitee.com/hwame # qzone: https://qzone.qq.com/ # email: mailto:user@qq.com # qq: https://im.qq.com/ # wechat: https://wx.qq.com/ # alipay: https://www.alipay.com/ # juejin: https://juejin.im/ stackoverflow: https://stackoverflow.com/questions # friendship: https:// ......例如，我开启了「github」、「weibo」、「zhihu」、「segmentfault」、「gitee」、「stackoverflow」六个，效果如图： 3.如何取消文章目录的自动编号 有时我们文章的展开目录不需要自动编号，而是希望和*.md保持一致但是Hexo默认会加上编号，这会导致①在有编号的地方重复编号；②在不需要编号（譬如某些三级目录）的地方也会编号所以需要修改源码：./node_modules/hexo/lib/plugins/helper/toc.js 第一步：vi ./node_modules/hexo/lib/plugins/helper/toc.js第二步：修改其中list_number: true的属性值，默认true为使用自动编号，如下第六行 1234567function tocHelper(str, options = &#123;&#125;) &#123; options = Object.assign(&#123; min_depth: 1, max_depth: 6, class: &#x27;toc&#x27;, list_number: true // 自行修改，true/false &#125;, options); 注意：在主题配置文件修改无效： 123456789# 原文：config: toc: true # 是否开启文章章节目录导航# 无效的修改：config: toc: enable: true # 是否开启文章章节目录导航 number: false 关于目录的特别说明有的小伙伴不知道怎样开启目录，在这里一并说明： 此部分是「如何取消文章目录的自动编号」，是对于「已经开启了目录显示」而言的。那如何开启目录显示呢？ ①主题配置文件./themes/pure/_config.yml里开启目录功能：config: toc: true; ②文章里必须有目录（一级目录#，二级目录##等等），然后在文章的Front-matter（就是.md文件顶部的两个---之间的部分）中添加toc: true，如图； ③上述条件缺一不可。 因为「目录的展开/折叠」是主题自带的，只需自行开启不涉及魔改，所以没有特意写。 另外在手机上浏览时，只显示一个「」图标，所以加一个「温馨提示」。直接在&lt;div class=&quot;article-meta&quot;&gt;···&lt;/div&gt;后添加即可，样式自行修改，文件位置./themes/pure/layout/_partial/article.ejs：1234&lt;div class=&quot;article-header&quot;&gt;***省略***&lt;/div&gt;&lt;div style=&quot;background-color:#D7BDE2;border:1px solid #D7BDE2;border-radius:10px;padding:5px&quot;&gt; &lt;b&gt;温馨提示&lt;/b&gt;：点击页面下方&lt;i style=&quot;color:red&quot; class=&quot;icon icon-anchor&quot;&gt;&lt;/i&gt;以展开或折叠目录~&lt;/div&gt; 4.如何修改代码字体及图片居中此部分参考Hexo博客搭建——CSS样式修改，文件位置为./themes/pure/source/css/style.css，修改了三个部分（可能由于添加过注释，代码行数会有所偏差）： 行内代码颜色，原始颜色和正文接近，对比度区分不够明显，修改为橙黄色； 代码字体，原始代码字体为「宋体」，修改经典的「Consolas」； 文章图片居中，文章图片默认为左对齐，修改为居中。 4.1.行内代码颜色第一步：vi ./themes/pure/source/css/style.css第二步：5549行code修改color和background：123456789code &#123; text-shadow: 0 1px #fff; padding: 0.2em 0.4em; margin: 0 0.3em; color: #FF4500; /* 行内代码颜色及背景 */ background: #F0FFFF; border-radius: 3px; font-size: 85%; 4.2.代码字体第一步：vi ./themes/pure/source/css/style.css第二步：155行samp添加Consolas字体：1234samp &#123; font-family: consolas,monospace; font-size: 1em;&#125; 4.3.如何使文章图片居中第一步：vi ./themes/pure/source/css/style.css第二步：125行img修改：12345678img &#123; border: 0; box-sizing: border-box; margin: auto; padding: 3px; text-align: center; display: block;&#125; 5.如何添加文章描述参考文章：如何添加文章描述-首页截断设置在md文章写一个摘要，结尾加上&lt;!-- more --&gt;即可。例如12345678910111213---title: Hexo博客搭建(2)——优化及完善date: 2020-05-20 13:14:52tags: - Hexocategories: - Hexotoc: true---文章描述测试&lt;!-- more --&gt;以下是正文…… 首页效果如图 6.如何实现点击图片放大 主题配置文件./themes/pure/_config.yml自带了一个选项fancybox: false，其默认是关闭的，打开之后即可实现「点击图片查看大图」的功能。然而，在我们不需要的地方也会这样，比如，「友情链接」板块，fancybox: true时点击头像并没有跳转，而是当做图片打开，并且也并没有打开图片。因为图片（头像）对应的超链接是「小伙伴个人主页」，头像本身的链接是「图床上的图片」。所以要修改源码：./themes/pure/layout/_partial/archive-link.ejs。 其核心部分为for (var link in site.data.links) &#123;&#125;这个循环，获取每一个友链name，对应的item为每个友链的三个值item.link、item.avatar、item.desc，分别渲染。第一步，href=&quot;&lt;%= item.link %&gt;&quot;改为href=&quot;&lt;%= item.avatar %&gt;&quot;。既然点击头像既不能查看大图，也不能跳转，那我们修改为查看大图吧。只需要将图片的超链接还给头像自己即可，如下第7行，将&lt;a href=&quot;&lt;%= item.link %&gt;&quot; target=&quot;_blank&quot; class=&quot;img-burn thumb-md media-middle&quot;&gt;修改为&lt;a href=&quot;&lt;%= item.avatar %&gt;&quot; target=&quot;_blank&quot; class=&quot;img-burn thumb-md media-middle&quot;&gt;。第二步，alt=&quot;&quot;改为alt=&quot;&lt;%= item.desc %&gt;&quot;。现在只让他变图片了，好人做到底，加个图片描述吧，就用那个desc：第8行，将&lt;img src=&quot;&lt;%= item.avatar %&gt;&quot; class=&quot;w-full&quot; alt=&quot;&quot;&gt;修改为&lt;img src=&quot;&lt;%= item.avatar %&gt;&quot; class=&quot;w-full&quot; alt=&quot;&lt;%= item.desc %&gt;&quot;&gt;。第三步，其实就已经好了，但是友链跳转是点击那个「名字」，默认是黑色（class=&quot;text-dark&quot;），不够明显，希望换个颜色表示超链接。将h4下的&lt;span&gt;修改为&lt;span style=&quot;color:#9932CC&quot; title=&quot;点击跳转&quot;&gt;&lt;%= name %&gt;&lt;/span&gt;。 修改完成后的核心循环部分如下： 12345678910111213141516171819202122&lt;% for (var name in site.data.links) &#123; %&gt; &lt;% var item = site.data.links[name]; %&gt; &lt;div class=&quot;col-sm-6 col-md-4&quot;&gt; &lt;div class=&quot;panel panel-default hover-shadow hover-grow&quot;&gt; &lt;figure class=&quot;media media-middle&quot;&gt; &lt;div class=&quot;media-left pr-no&quot;&gt; &lt;a href=&quot;&lt;%= item.avatar %&gt;&quot; target=&quot;_blank&quot; class=&quot;img-burn thumb-md media-middle&quot;&gt; &lt;img src=&quot;&lt;%= item.avatar %&gt;&quot; class=&quot;w-full&quot; alt=&quot;&lt;%= item.desc %&gt;&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;media-body p-0x&quot;&gt; &lt;h4 class=&quot;media-heading&quot;&gt;&lt;a href=&quot;&lt;%= item.link %&gt;&quot; target=&quot;_blank&quot;&gt; &lt;span style=&quot;color:#9932CC&quot; title=&quot;点击跳转&quot;&gt;&lt;%= name %&gt;&lt;/span&gt;&lt;/a&gt; &lt;/h4&gt; &lt;div class=&quot;text-muted&quot;&gt; &lt;%= item.desc %&gt; &lt;/div&gt; &lt;/div&gt; &lt;/figure&gt; &lt;/div&gt; &lt;/div&gt; &lt;% &#125; %&gt; 7.添加「相册」页面由于博主没有豆瓣账号，主题自带的「豆瓣书单」页面一直用不上，因此想着改成其他实用的。最初修改为「留言板」，奈何无人回应😂😂（尴尬.jpg），受第6部分【6.如何实现点击图片放大】的启发，最终决定修改为分享摄影作品的「相册」页面。 7.1.重命名相关文件此部分是魔改相册，代码及文件（夹）原本是以book(s)命名的，既然现在是「相册」了，就得改名叫「gallery」了。将./themes/pure/下的文件或文件内容中所有的book(s)改为gallery： 序号 类型 原文件名 修改后文件名 1 文件夹 ./themes/pure/_source/books/ ./themes/pure/_source/gallery/ 2 文件 ./themes/pure/layout/books.ejs ./themes/pure/layout/gallery.ejs 3 文件 ./themes/pure/layout/_partial/archive-book.ejs ./themes/pure/layout/_partial/archive-gallery.ejs 7.2.修改源代码 ./themes/pure/layout/gallery.ejs，文件路径改为&#39;_partial/archive-gallery&#39;即可。 ./themes/pure/layout/_partial/archive-gallery.ejs，代码参考第6部分【6.如何实现点击图片放大】，修改后完整内容如下：1234567891011121314151617181920212223242526272829303132333435&lt;article class=&quot;article article-links article-type-list&quot; itemscope=&quot;&quot;&gt; &lt;header class=&quot;article-header&quot;&gt; &lt;h1 itemprop=&quot;title&quot;&gt;&lt;%= page.title %&gt;&lt;/h1&gt; &lt;p class=&quot;text-muted&quot;&gt; &lt;%= __(&#x27;page.gallery-desc&#x27;) %&gt; &lt;/p&gt; &lt;/header&gt; &lt;div class=&quot;article-body&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;% for (var link in site.data.gallery) &#123; %&gt; &lt;% var item = site.data.gallery[link]; %&gt; &lt;div class=&quot;col-sm-6 col-md-4&quot;&gt; &lt;div class=&quot;panel panel-default hover-shadow hover-grow&quot;&gt; &lt;figure class=&quot;media media-middle&quot;&gt; &lt;div class=&quot;media-left pr-no&quot;&gt; &lt;a href=&quot;&lt;%= item.full_link %&gt;&quot; target=&quot;_blank&quot; class=&quot;img-burn thumb-md media-middle&quot;&gt; &lt;img src=&quot;&lt;%= item.thumb_link %&gt;&quot; class=&quot;w-full&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;media-body p-0x&quot;&gt; &lt;h4 class=&quot;media-heading&quot;&gt;&lt;a href=&quot;&lt;%= item.full_link %&gt;&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;text-dark&quot;&gt;&lt;%= link %&gt;&lt;/span&gt;&lt;/a&gt;&lt;/h4&gt; &lt;div class=&quot;text-muted&quot;&gt; &lt;%= item.desc %&gt; &lt;/div&gt; &lt;/div&gt; &lt;/figure&gt; &lt;/div&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;/div&gt;&lt;/article&gt;&lt;% if (theme.comment.type &amp;&amp; !is_home()) &#123; %&gt; &lt;%- partial(&#x27;post/comment&#x27;, &#123;post: page&#125;) %&gt;&lt;% &#125; %&gt; 7.3.配置相册在./source/_data/目录下新建一个gallery.yml文件，格式如下： Name：相片名称，多张照片保证不要重名 full_link、thumb_link：原图和缩略图链接，图床上的图片直接以地址引用，./themes/pure/source/images/文件夹下的图片以/images/subdir/img.jpg的格式引用 desc：相片描述 1234Name: full_link: /path/to/img.jpg thumb_link: /path/to/thumb_img.jpg desc: &quot;photo description&quot; 7.4.修改主题相关配置 主题配置文件./themes/pure/_config.yml的菜单选项： Books: books修改为Gallery: gallery books: icon-book-fill修改为gallery: icon-delicious，图标名参考【这里】 语言配置文件./themes/pure/languages/zh-CN.yml，如果使用其他语言只需对应修改： menu：Books: 书单修改为Gallery: 相册 page：books: 书单修改为gallery: 相册，books-desc: 个人收藏的书单推荐给大家修改为gallery-desc: 摄影爱好者的个人拍摄作品 样式表文件./themes/pure/source/css/gallery.css，整理这部分内容时发现多出了这个CSS文件，但是应该不是必需的 7.5.生成页面及说明如果没有./source/gallery/或./source/gallery/index.md，则执行hexo new page &quot;gallery&quot;生成新的页面，修改./source/gallery/index.md文件的type和layout：12345678---title: 相册copyright: falsecomments: truedate: 2020-05-27 11:25:35type: gallerylayout: gallery---说明： 评论区有小伙伴提到原版gallery的问题，我在主题文件夹下查找与gallery相关的文件，如下图所示： 文件名含有gallery的文件： .themes/pure/_source/_data/gallery.yml .themes/pure/layout/_partial/post/gallery.ejs 文件内容含有gallery的文件： .themes/pure/layout/_partial/post/gallery.ejs .themes/pure/layout/_partial/article.ejs 其中gallery.yml位于_source文件夹内，暂时不用考虑；看看剩下两个.ejs文件的代码，在article.ejs里引用了gallery.ejs，所以可以看到这是「博文配图」的样式（即fancybox效果），跟「相册」没有关系。但是我们可以借鉴这个样式，来定制「相册」浏览的页面，布局呢可以借鉴「友情链接」的布局。于是就有了来自于第6部分【6.如何实现点击图片放大】的灵感。另一方面，看看gallery.yml的文件结构，是不是简直和links.yml一模一样，所以我们的照片没有必要写到HTML或.ejs里，仿照友链用循环处理多张照片，然后把照片信息添加在gallery.yml里。至此，是不是就豁然开朗了呢？ 8.如何显示「最近文章」缩略图第一步：在主题配置文件./themes/pure/_config.yml中开启：12config: thumbnail: true 第二步：在文章Front-matter中添加文章缩略图链接地址（图片地址可以是图床上的图片，也可以放在./themes/pure/source/images/文件夹下，引用方式如下）：123456---title: xxxtoc: truedate: 2020-10-15 11:18:23thumbnail: /images/avatar.jpg--- 9.部分地方中文适配由于languages中的中文配置问题，部分地方没有完全改为中文：「分类」「归档」页面的「全部」、「共xxx篇文章」、「第x页，共x页」等，只需要修改./themes/pure/languages/zh-CN.yml即可： 导航nav的all: All修改为all: 全部 分页pagination的pageof: Page %d of %s修改为pageof: 第 %d 页，共 %s 页 10.免密部署问题前文Hexo博客搭建(1)——建站及部署之部署Hexo原本部署部分设置的是repository: https://github.com/username/username.github.io.git，这种方式有时候会需要手动输入用户名和密码，有时候还会出现Error: Spawn failed的错误，参考文章《hexo发生error：spawn failed错误的解决方法》，直接修改为repository: git@github.com:username/username.github.io.git即可。 11.自定义左下角信息11.1.添加访问量和访客数原版左下角是Theme by cofess base on pure.过于单调，考虑加入「站点访问量」和「访客数」，至于文章阅读量可以通过LeanCloud并且已经实现。文件位置：./themes/pure/layout/_common/footer.ejs。 「访问量」和「访客数」可以使用「不蒜子-极简网页计数器」，该网站也提供了「网站总访问量」的示例：12&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 通过F12可以发现设置的方法： 文章阅读量：&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 站点访问量：&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; 站点访客数：&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt; 结合网站示例，将Theme by cofess base on pure.注释掉，并加入「访问量」和「访客数」，还可以通过&lt;div class=&quot;publishby&quot;&gt;标签加入「网站备案信息」，修改后如下：12345678910111213141516171819202122232425&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;&lt;footer class=&quot;footer&quot; itemscope itemtype=&quot;http://schema.org/WPFooter&quot;&gt; &lt;%- partial(&#x27;_common/social&#x27;, null, &#123;cache: !config.relative_link&#125;) %&gt; &lt;div class=&quot;copyright&quot;&gt; &lt;% if(theme.site.copyright) &#123; %&gt; &amp;copy; &lt;%= date(new Date(), &#x27;YYYY&#x27;) %&gt; &lt;%= config.author || config.title %&gt; &lt;% &#125; %&gt; &lt;div class=&quot;publishby&quot;&gt; &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 点击&lt;span id=&quot;busuanzi_value_site_pv&quot; style=&quot;font-family:Courier&quot;&gt;&lt;/span&gt;次， 访客&lt;span id=&quot;busuanzi_value_site_uv&quot; style=&quot;font-family:Courier&quot;&gt;&lt;/span&gt;人 &lt;/span&gt; &lt;/div&gt; &lt;!-- &lt;div class=&quot;publishby&quot;&gt; &lt;%= __(&#x27;copyright.theme_by&#x27;) %&gt; &lt;a href=&quot;https://github.com/cofess&quot; target=&quot;_blank&quot;&gt; cofess &lt;/a&gt; &lt;%= __(&#x27;copyright.base_on&#x27;) %&gt; &lt;a href=&quot;https://github.com/cofess/hexo-theme-pure&quot; target=&quot;_blank&quot;&gt;pure&lt;/a&gt;. &lt;/div&gt; --&gt; &lt;/div&gt;&lt;/footer&gt; 11.2.添加网站运行时间此部分内容参考moyu的文章为博客添加一些小功能以及美化之建站时间时间。 文件位置：./themes/pure/layout/_common/footer.ejs。其实现逻辑如下：123456789101112131415161718192021222324252627282930313233343536&lt;script&gt;function siteTime()&#123; window.setTimeout(&quot;siteTime()&quot;, 1000); var seconds = 1000; var minutes = seconds * 60; var hours = minutes * 60; var days = hours * 24; var years = days * 365; var today = new Date(); var todayYear = today.getFullYear(); var todayMonth = today.getMonth()+1; var todayDate = today.getDate(); var todayHour = today.getHours(); var todayMinute = today.getMinutes(); var todaySecond = today.getSeconds(); /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳) year - 作为date对象的年份，为4位年份值 month - 0-11之间的整数，做为date对象的月份 day - 1-31之间的整数，做为date对象的天数 hours - 0(午夜24点)-23之间的整数，做为date对象的小时数 minutes - 0-59之间的整数，做为date对象的分钟数 seconds - 0-59之间的整数，做为date对象的秒数 microseconds - 0-999之间的整数，做为date对象的毫秒数 */ var t1 = Date.UTC(2020,05,19,21,20,52); //t1为建站时间 var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond); var diff = t2-t1; var diffYears = Math.floor(diff/years); var diffDays = Math.floor((diff/days)-diffYears*365); var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours); var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes); var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds); document.getElementById(&quot;sitetime&quot;).innerHTML=&quot;已运行&quot;+/*diffYears+&quot; 年 &quot;+*/diffDays+&quot;天&quot;+diffHours+&quot;小时&quot;+diffMinutes+&quot;分钟&quot;+diffSeconds+&quot;秒&quot;; // 因为建站时间还没有一年，就将之注释掉了。需要的可以取消 &#125; siteTime();&lt;/script&gt;最后将标签&lt;span id=&quot;sitetime&quot;&gt;&lt;/span&gt;添加到合适的位置，例如上文11.1节添加访问量和访客数的「访问量」和「访客数」后。 可number.toString().padStart(n, &#39;0&#39;)将数字转换为「补零字符串」，效果为m:nnn:xx:yy:zz，表示运行时间为m年nnn天xx时yy分zz秒：1234567// 将「数字」转「补零字符串」var y = diffYears.toString()var d = diffDays.toString().padStart(3, &#x27;0&#x27;)var h = diffHours.toString().padStart(2, &#x27;0&#x27;)var m = diffMinutes.toString().padStart(2, &#x27;0&#x27;)var s = diffSeconds.toString().padStart(2, &#x27;0&#x27;)document.getElementById(&quot;sitetime&quot;).innerHTML = y + &quot;:&quot; + d + &quot;:&quot; + h + &quot;:&quot; + m + &quot;:&quot; + s; 12.代码块添加一键复制此部分参考kajweb大佬的文章Hexo优化记录之为代码块增加复制按钮。 由于kajweb大佬已写得很清楚，此处就不再赘述，主要步骤如下： 1.增加全局函数addLoadEvent，注意是在文件末尾，而不是在&#125;);内； 2.新增复制按钮； 3.插入到页面，主题代码&lt;%- partial(&#39;_partial/article-copy-code&#39;)%&gt;插入的位置； 4.增加语言文件，例如copy_button设置为一键复制； 5.修改主题配置文件，如果开启copyright则当一键复制代码后会加上content版权声明内容，个人不喜欢所以禁用了。 13.调整菜单栏高度由于页面较多，有时候在不同的浏览器或不同分辨率电脑上会和左下角footer重叠，因此考虑调整菜单栏的高度。 此部分及下部分如何隐藏valine版权信息都需要在CSS文件添加自定义样式，特别感谢陈园园提供的帮助。 添加后有一个小bug，menu-item的高度为35px而a标签的高度为默认值41px，即会出现重叠部分，参考文章CSS设置超链接A标签宽度和高度的第一种方案，使用display: block实现自定义a标签的高度。 文件位置：./themes/pure/source/css/style.css，直接在末尾添加如下代码：12345678910/* 调整左侧菜单栏高度 */.menu-item&#123; height: 35px;&#125;/* 调整a标签的高度 */.menu-item a&#123; display: block; height: 35px;&#125; 14.如何隐藏valine版权信息采用Valine评论系统会在评论区右下角显示Powered By Valine v1.4.14的字样，其实是否显示都无所谓，纯粹是修改上节时的举手之劳。 同上，需要在CSS文件添加自定义样式。文件位置：./themes/pure/source/css/style.css，直接在末尾添加如下代码：1234/* 隐藏valine版权信息 */.txt-right&#123; display: none;&#125; 15.添加回到顶部由于博文经常会有好几千字，尽管有目录能够快速跳转，但是对于长文来说「回到顶部」的功能还是很实用的。然而Pure主题恰巧没有，因此添加一个「回到顶部」的按钮，参考文章Hexo博客搭建之回到顶部。 文件位置：./themes/pure/layout/_common/script.ejs，在合适位置添加如下代码：123456789101112131415161718192021222324252627282930313233&lt;div id=&quot;go-top&quot;&gt;&lt;/div&gt;&lt;style type=&quot;text/css&quot;&gt;#go-top &#123; width:40px;height:36px; background-color:#DDA0DD; position:relative; border-radius:2px; position:fixed;right:10px;bottom:60px; cursor:pointer;display:none;&#125;#go-top:after &#123; content:&quot; &quot;; position:absolute;left:14px;top:14px; border-top:2px solid #fff;border-right:2px solid #fff; width:12px;height:12px; transform:rotate(-45deg);&#125;#go-top:hover &#123; background-color:#8A2BE2;&#125;&lt;/style&gt;&lt;script&gt;$(function () &#123; var top=$(&quot;#go-top&quot;); $(window).scroll(function () &#123; ($(window).scrollTop() &gt; 300) ? top.show(300) : top.hide(200); $(&quot;#go-top&quot;).click(function () &#123; $(&#x27;body,html&#x27;).animate(&#123;scrollTop:0&#125;); return false(); &#125;) &#125;);&#125;);&lt;/script&gt; 16.添加RSS订阅功能RSS简介（摘自Segmentfault用户一步的文章为hexo博客添加RSS订阅功能）： RSS(Really Simple Syndication) ，即「简易信息聚合」，在互联网上被广泛采用的内容包装和投递协。是一种描述同步网站内容的格式，使用xml格式. 当网站内容更新时，可以通过订阅RSS源在RSS阅读器上获取更新的信息。大多数内容提供的网站都会提供RSS订阅的功能，方便用户去获取最新的内容。 之前觉得现在这个时代RSS订阅就是一个鸡肋，所以在前面的配置中都是直接关闭了该功能，但是见过的别人的博客都有，还是觉得少了这一个功能不太好，因此重新开启。 第一步，安装插件：站点根目录执行：1npm install hexo-generator-feed --save 第二步，修改配置：在主题配置文件中开启rss、配置rss文件路径：12345678# rssrss: true# profileprofile: social: links: rss: atom.xml 17.设置文章置顶「博文置顶」的功能算是刚需了，但是在网上找了很多教程，都没有基于Pure主题的，尽管如此还是找到了一些思路。 此部分主要参考hexo博客优化之文章置顶+置顶标签。 第一步，安装插件：站点根目录执行：12npm uninstall hexo-generator-index --savenpm install hexo-generator-index-pin-top --save第二步，修改标题文件：其实在安装了插件之后就已经可以实现「文章置顶」功能了，但是即使文章位于顶部，如果没有置顶标志的话会比较莫名其妙就很尴尬（别问我怎么知道）。 网上文章都是定位到&lt;div class=&quot;post-meta&quot;&gt;标签，但是我们的Pure主题没有啊，它是&lt;div class=&quot;article-header&quot;&gt;，找到对应的文件是./themes/pure/layout/_partial/post/title.ejs，而不是post.xxx。分析了一下，在&lt;h1 itemprop=&quot;name&quot;&gt;后直接添加判断即可：如果设置了置顶，则显示一个「📌置顶」：1234&lt;h1 itemprop=&quot;name&quot;&gt; &lt;% if (post.top) &#123; %&gt; &lt;span class=&quot;&lt;%= class_name %&gt;&quot; style=&quot;color:#7D26CD&quot;&gt;📌置顶&lt;/span&gt; &lt;% &#125; %&gt;说明：我使用的是📌emoji作为图标，如果按参考文章写的，因为不同主题使用的图标不一样，需要自行修改（详见Pure主题图标样式），不过好像没什么合适的，例如可以改成下面这样：注意：按参考文章写的会还有一个问题，置顶标志和标题字号不一致比较突兀，所以可以使用与标题相同的class，如上class=&quot;&lt;%= class_name %&gt;&quot;；判断语句用&lt;% clause %&gt;而非&#123;% clause %&#125;。123456&lt;h1 itemprop=&quot;name&quot;&gt;&lt;% if (post.top) &#123; %&gt; &lt;i class=&quot;icon icon-map-marker&quot;&gt;&lt;/i&gt; &lt;font color=#7D26CD&gt;置顶&lt;/font&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&lt;% &#125; %&gt;至于进一步美化置顶，那就需要各位自己去调了~ 第三步，使用置顶：在需要被置顶的文章Front-matter中添加top: true或top: 999即可，置顶排序规则为：数值越大越靠上（相同则按时间）。 18.添加文章更新时间有时候一篇文章写完后，可能会多次修改反复更新，因此需要将「博文更新时间」也显示在文章上，然而小众主题可供参考的文章几乎没有。 找了一圈，发现Hiker主题和Pure主题几乎一模一样，于是参考了Hexo博客Hiker主题增加文章最后编辑时间并按照最后编辑时间排序。在此非常感谢Vientiane详细而清晰的修改教程，本文仅针对于自己的需求进行修改，若需更多配置，烦请移步原文。 Hiker主题和Pure主题layout结构是一致的，根据Vientiane的分析和网页HTML结构，需要修改的文件为./themes/pure/layout/_partial/post/date.ejs。 data.ejs这个文件在很多地方会被引用到，可谓是牵一发而动全身啊，如果你改在这个文件上，就会发现所有原本出现发布时间的地方同时还会有更新时间，看上去真的是有点丑啊。我不需要它在文章正文以外的部分出现更新时间，所以选择新建一个updated.ejs文件，就放在与date.ejs同级的post文件夹。 实际上，data.ejs只在「文章页」和「首页」出现，也没有出现在不该出现的地方，因此我们直接修改该文件，从而不需要新建updated.ejs文件，也不需要修改./themes/pure/layout/_partial/article.ejs。 直接复制一份，对应修改为post.updated和itemprop=&quot;dateUpdated&quot;，并选择合适的图标。1234567891011121314151617&lt;span class=&quot;article-date&quot;&gt; &lt;i class=&quot;icon icon-calendar&quot;&gt;&lt;/i&gt; &lt;a href=&quot;&lt;%- url_for(post.path) %&gt;&quot; class=&quot;&lt;%= class_name %&gt;&quot;&gt; &lt;time datetime=&quot;&lt;%= date_xml(post.date) %&gt;&quot; itemprop=&quot;datePublished&quot;&gt; &lt;%= date(post.date, date_format) %&gt; &lt;/time&gt; &lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;article-date&quot;&gt; &lt;i class=&quot;icon icon-calendar-check&quot;&gt;&lt;/i&gt; &lt;a href=&quot;&lt;%- url_for(post.path) %&gt;&quot; class=&quot;&lt;%= class_name %&gt;&quot;&gt; &lt;time datetime=&quot;&lt;%= date_xml(post.updated) %&gt;&quot; itemprop=&quot;dateUpdated&quot;&gt; &lt;%= date(post.updated, date_format) %&gt; &lt;/time&gt; &lt;/a&gt;&lt;/span&gt;到这里就已经改好了，重新生成页面就可以看到效果。以下是几点说明，自行取舍： ⑴如果在Front-matter中定义了updated，那么更新时间就是定义的那个值，否则就是.md文件的修改时间； ⑵首页文章排序规则和时间格式需要分别修改站点配置文件./_config.yml的index_generator: order_by: -date和date_format: YYYY-MM-DD； ⑶文章的「发布时间」和「更新时间」如果不加区别地放在一起，可能会让人迷惑，因此需要： 通过一个有辨识度的图标来区分； 在两处&lt;time&gt;标签前通过字段显式地区分： 直接写死，例如更新于&lt;time&gt;···； 也可以&lt;%= __(&#39;updated&#39;) %&gt; &lt;time&gt;···，这种方式适应多种语言环境，因此还需到语言配置文件中增加对应字段updated: 更新于（如果没有设置则显示为标签中的值updated）； ⑷如果article-meta内容过多或其他原因，只希望在「文章页」显示，则需要新建updated.ejs文件。 ⑸关于「首页」和「文章页」时间格式不一致的问题：「首页」时间格式是由archive-post.ejs（默认值为date_format: &#39;MMM D&#39;）决定，「文章页」时间格式是由article.ejs（默认值为date_format: null）决定，这两个文件都在&lt;xx class=&quot;article-meta&quot;&gt;中引入了date.ejs，在date.ejs接受配置文件_config.yml中的时间格式。分析可知： _config.yml中设置的时间格式仅能影响date.ejs，再传给另外两者解析； archive-post.ejs和article.ejs各自有时间解析的格式，因此导致了不同。如果在这两者中指定了date_format则按它来解析，否则用已有的值。 由此解决方案便显而易见了：将archive-post.ejs中的date_format: &#39;MMM D&#39;修改为date_format: null即可。 ⑹没了。 19.添加搜索引擎收录19.1.谷歌收录 谷歌收录的操作很简单，唯一的问题就是你能否打开这串神奇的字符：https://search.google.com/search-console 操作方法： 1.登陆或注册谷歌账号，如图所示： 2.添加资源：资源类型选择「网址前缀」【如果选择「网域」，则需要进行DNS验证，可能比较麻烦】，输入包含协议头的网址，例如https://hwame.top如图所示： 3.验证所有权：可使用的方法有以下几种，如图所示： HTML文件——将HTML文件上传至您的网站，如图所示，这是谷歌推荐使用的验证方法，需要将googlexxx.html文件上传到网址上，对于Hexo博客而言，直接将其放在./source/文件夹下（与CNAME文件同级）即可； HTML标记——向您网站的首页添加元标记，如图所示，这是我使用的方法，在网页中添加元标记。需要将Google提供的元标记粘贴至网页&lt;head&gt;部分。对于Hexo博客而言，可以将其添加到./themes/pure/layout/_common/head.ejs中，可以使每个页面都能被收录而不仅是首页：1234&lt;meta name=&quot;xxx&quot; content=&quot;xxx&quot;&gt;&lt;meta name=&quot;xxx&quot; content=&quot;xxx&quot;&gt;&lt;!-- 谷歌收录 --&gt;&lt;meta name=&quot;google-site-verification&quot; content=&quot;xxxxxx&quot; /&gt; 剩余三种可根据自身情况，如图所示： Google Analytics（分析）——使用您的Google Analytics（分析）帐号； Google Tag Manager——使用您的Google跟踪代码管理器帐号； 域名提供商——将DNS记录与Google关联。 4.验证完成：所有权验证完成后，如图所示： 说明：上述验证方式可以同时采用，以添加多种验证方法，从而避免验证状态丢失。 5.效果预览：由于谷歌抓取内容需要一定的时间，所以暂时还看不到内容：等一段时间即可看到效果，如图所示： 19.2.百度收录与谷歌收录相比，百度收录就麻烦多了。第一步，注册或登陆「百度搜索资源平台」：https://ziyuan.baidu.com/login/index?u=/crawl/ 第二步，添加站点，将自己博客网址添加，可设置成默认站点，如图所示： 第三步，网站验证，站点添加以后完成验证，如图所示： 第四步，资源提交，在左侧导航栏找到「资源提交」→「普通收录」进行资源的推送，推送方式包括以下四种： 「API提交」，利用推送接口http://data.zz.baidu.com/urls?site=&lt;yoursite&gt;&amp;token=&lt;yourtoken&gt;，结合推送示例进行结构化数据的提交，可根据自己的情况使用擅长的语言编写代码。这也是我所使用的方式，下文将详细展开。 「自动推送」，自动推送仅对关联过主体的站点开放，需要在左侧导航栏依次展开「搜索展现」→「站点属性」→「基础信息」→「关联主体」，由于未使用这种方式因此不再叙述，参考【关联主体使用说明】。自动推送的js代码需要在每个HTML页面中都包含，因此可以写入到./themes/pure/layout/_common/head.ejs中：1234567891011121314&lt;script&gt;(function()&#123; var bp = document.createElement(&#x27;script&#x27;); var curProtocol = window.location.protocol.split(&#x27;:&#x27;)[0]; if (curProtocol === &#x27;https&#x27;)&#123; bp.src = &#x27;https://zz.bdstatic.com/linksubmit/push.js&#x27;; &#125; else&#123; bp.src = &#x27;http://push.zhanzhang.baidu.com/push.js&#x27;; &#125; var s = document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(bp, s);&#125;)();&lt;/script&gt; 「sitemap」，根据百度百科的解释，站点地图可方便网站管理员通知搜索引擎他们网站上有哪些可供抓取的网页，一般为XML文件，例如atom.xml。直接将XML文件地址添加提交即可。注意图中的提示信息 「手动提交」，顾名思义即将文章链接地址手动填写并提交。注意图中的提示信息 19.3.API提交主动推送的API提交可以简单借助Hexo插件，可以参考Hexo插件之百度主动提交链接，以下是自己写的。 百度提供了php和ruby的推送示例，参考curl推送示例编写python代码。整个的思路就是先用Python提取网站所有文章的链接，然后将其写入urls.txt，再写一个shell脚本执行curl命令，推送完成后删除txt文件。Python主逻辑如下，利用爬虫抓取「归档」页面所有的文章链接放入列表，然后打印。123456789101112131415161718192021import requestsfrom lxml import etreedef get_article_links(site_url): # 「归档」页提取所有文章链接 archive_url = site_url.rstrip(&quot;/&quot;) + &quot;/archives/&quot; articles = [] # 第一页，若直接&quot;/archives/page/1/&quot;则报错404 text = requests.get(archive_url).text html = etree.HTML(text) data = html.xpath(&#x27;/html/body/main/article/div/section/div[2]/div/div/a/@href&#x27;) articles.extend(data) # 第二页至末尾 page = html.xpath(&#x27;/html/body/main/nav/div/div&#x27;) if len(page): for i in range(1, int(page[0].text.split(&#x27;/&#x27;)[-1])): page_url = archive_url + &quot;page/&#123;&#125;/&quot;.format(i + 1) text = requests.get(page_url).text html = etree.HTML(text) data = html.xpath(&#x27;/html/body/main/article/div/section/div[2]/div/div/a/@href&#x27;) articles.extend(data) return list(map(lambda item: site_url + item, articles))将打印的内容重定向到urls.txt，然后执行curl命令，主要命令如下：123python submit.py &gt; urls.txtcurl -H &#x27;Content-Type:text/plain&#x27; --data-binary @urls.txt &quot;http://data.zz.baidu.com/urls?site=&lt;yoursite&gt;&amp;token=&lt;yourtoken&gt;&quot;erase urls.txt执行效果如图： 说明： ①此脚本适用于Windows系统，Unix系统只需将cmd的删除命令erase替换为rm -f；②更简单简洁的办法是从站点地图里提取链接，去重后进行推送，这种方式不仅能推送文章，还可以推送页面；③cmd或shell脚本是基于curl推送的，参考百度的post推送示例，可以只需要一个Python脚本，利用requests.post()方法，主要逻辑如下：1234567891011def submit_to_baidu(articles, site, token): # articles列表为上文get_article_links()函数的返回值 baidu_url = f&quot;http://data.zz.baidu.com/urls?site=&#123;site&#125;&amp;token=&#123;token&#125;&quot; headers = &#123;&quot;User-Agent&quot;: &quot;curl/7.12.1&quot;, &quot;Host&quot;: &quot;data.zz.baidu.com&quot;, &quot;Content-Type&quot;: &quot;text/plain&quot;, &quot;Content-Length&quot;: &quot;83&quot; &#125; post_url = &quot;\\n&quot;.join(articles) res = requests.post(url=baidu_url, headers=headers, data=post_url) return res.text④通用Python脚本点我下载来了，命令行执行python submit.py，输入参数、主站网址、token即可，如图所示： 19.4.收录效果谷歌收录相对较快，大概一两天就能看到： 百度收录就很慢了，大概需要一周的时间： 上面搜索是使用关键字，所以排名比较靠后；如果精确搜索，则霸占头版，且搜索内容全部相关： 20.自定义图片大小Hexo博客中原生的Markdown语法不支持设置图片大小，如果需要指定图片大小只能通过HTML语法来设置，这未免有点麻烦。那么有没有简单的办法呢？答案是肯定的： 可以通过额外的js来对![图片描述](图片地址)进行解析， 此回答参考：Hexo中扩展Markdown语法设置图片的大小。​只需要在布局文件./themes/xxx/layout/layout.ejs中引入js文件即可：https://cdn.jsdelivr.net/gh/bobcn/hexo_resize_image.js@master/hexo_resize_image.js 引入位置在&lt;body&gt;前即可，如下所示：12&lt;script src=&quot;https://cdn.jsdelivr.net/gh/bobcn/hexo_resize_image.js@master/hexo_resize_image.js&quot;&gt;&lt;/script&gt;&lt;body class=&quot;&lt;%= bodyClass %&gt;&quot; xxx&gt;使用时在.md文件中插入图片时，只需要在图片地址后添加?&lt;width&gt;x&lt;height&gt;即可，具体有以下几种方式： 格式 示例 描述 ?widthxheight ?400x300 同时指定宽度和高度 ?widthx ?400x 指定宽度400 ?xheight ?x300 指定高度300 ?scale ?50 按比例缩放，示例表示50% 例如： ![avatar](https://cdn.jsdelivr.net/gh/hwame/pics@main/avatar.jpg?200x200) ![avatar](https://cdn.jsdelivr.net/gh/hwame/pics@main/avatar.jpg?200x) ![avatar](https://cdn.jsdelivr.net/gh/hwame/pics@main/avatar.jpg?x200) ![avatar](https://cdn.jsdelivr.net/gh/hwame/pics@main/avatar.jpg?80)","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://hwame.top/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://hwame.top/tags/Hexo/"}]},{"title":"Hexo博客搭建(3)——优化评论系统","slug":"hello-hexo-optimization","date":"2020-05-20T05:14:52.000Z","updated":"2020-09-28T02:29:51.000Z","comments":true,"path":"20200520/hello-hexo-optimization.html","link":"","permalink":"https://hwame.top/20200520/hello-hexo-optimization.html","excerpt":"摘要：博客采用Valine评论系统，其基于LeanCloud，配置较为繁琐，故单独取一篇幅记录其配置过程。","text":"摘要：博客采用Valine评论系统，其基于LeanCloud，配置较为繁琐，故单独取一篇幅记录其配置过程。 Hexo博客搭建博客系列：Hexo博客搭建(1)——建站及部署，环境搭建并部署至Github。博客系列：Hexo博客搭建(2)——主题配置，针对pure主题进行个性化配置。博客系列：Hexo博客搭建(3)——优化评论系统，主要对Valine评论系统进行优化。博客系列：Hexo博客搭建(4)——常见问题，修复了pure主题的系列小bug。文章作者：鴻塵 1.前言Hexo支持disqus、youyan、livere、gitment、gitalk及valine等多种评论系统，此部分仅用于Valine评论系统。原版的配置仅能记录评论，不能实现邮件提醒、QQ头像等个性化需求。头像倒无所谓，Valine自带的头像样式（monsterid、wavatar、robohash）其实也差不多够用了，但远不如QQ头像的辨识度高。最主要的是邮件提醒功能，比如讨论某个问题，当有了答案的时候却无法通知对方，因为别人不可能一直守着你的网站等回复吧，所以「邮件提醒」就显得极其重要且必要了。基础配置参考前文Hexo博客搭建(2)——主题配置之评论系统，下文是进阶配置。 进阶配置主要参考：①Valine评论之Valine-admin配置攻略②pure主题valine留言板添加：昵称、邮箱必填必写功能 2.部署valine-admin2.1.创建应用注册登录 LeanCloud 的官网，推荐使用「国际版」，因为附赠了一个「LeanCloud评论管理」的域名https://xxx.avosapps.us。创建应用，选择免费的「开发版」即可，创建完成如图所示。 2.2.部署项目⑴进入创建好的应用，依次点击「云引擎」→「部署」→「项目部署」，如图所示。⑵此时默认是在「命令行工具部署」的教程页面，切换到「Git部署」，点击「配置Git」，在「Git remote URL」填入https://github.com/sviptzk/Valine-Admin-Server，如图所示。⑶点击「部署项目」，回到「Git部署」选项卡，可以看到「Deploy fromhttps://github.com/sviptzk/Valine-Admin-Server」，「手动部署」下点击「部署」即可，如图所示。⑷等待部署完成即可，控制台打印部署日志如图。⑸部署过程完整动图如下，图片来源 2.3.绑定评论管理的域名说明：这一步非必须，评论管理模块可以直接在「存储」→「结构化数据」→「Comment」处操作，但是「国际版域名」对应的评论后台管理系统可以对发送邮件提醒失败的评论重新发送通知、可以标记垃圾邮件，综上还是有必要配置这一步的。 由于LeanCloud分为「国区版」和「国际版」，只有「国际版」才分配一个免费的二级域名，上文也推荐使用「国际版」，因此默认已有该域名：https://xxx.avosapps.us。 获取国际版域名：依次点击「云引擎」→「设置」→「云引擎域名」，设置自己的独立域名，例如：hwame.avosapps.us，如图所示。 2.4.设置域名白名单如果没有设置域名白名单，网页就无法加载评论，显示权限错误。每行一个域名，多个域名换行分隔。子域名需每条列出，不支持通配符。协议、域名和端口号都需严格一致（如果使用的是默认端口号可以省略，但协议头一定要写）。例如我的设置如图： 2.5.设置环境变量依次点击「云引擎」→「设置」→「自定义环境变量」，添加环境变量，此步骤非常重要，设置时务必弄清楚每一个变量的含义。下表仅为本人所设置的环境变量（按字母排序），根据需要自行增减，其他环境变量参考Valine评论之Valine-admin配置攻略。 变量名 必需 说明 示例 ADMIN_URL 可选 *评论后台的管理地址（非博客地址） https://hwame.avosapps.us/ BLOGGER_EMAIL 可选 *评论后台的管理员邮箱，默认使用SMTP_USER xxx@qq.com SENDER_NAME 必填 邮件寄件人名称 鴻塵 SITE_NAME 必填 网站名称 鴻塵的博客 SITE_URL 必填 网站地址，最后不要加/ https://hwame.top SMTP_PASS 必填 *SMTP授权码 abcdefghijklmnop SMTP_SERVICE 必填 *邮件服务提供商 QQ SMTP_USER 必填 SMTP服务用户名，一般为邮箱地址 xxx@qq.com TEMPLATE_NAME 必填 *提醒邮件的主题 rainbow TO_EMAIL 可选 博主通知收件地址，默认使用SMTP_USER xxx@qq.com 带*号字段的详细说明： ADMIN_URL：评论后台的管理地址，即上文2.3.绑定评论管理的域名设置的域名。通过该后台可以对发送邮件提醒失败的评论重新发送通知、可以标记垃圾邮件，而「结构化数据」中的「Comment」可以修改评论内容/昵称/时间、为评论添加QQ头像等，两处都可以查看邮件提醒是否成功。 BLOGGER_EMAIL：评论后台的管理员邮箱，如果设置则作为后台管理员邮箱（/sign-up页面设置），如果不设置则默认为SMTP_USER。 SMTP_PASS：SMTP授权码，注意不是邮箱的登陆密码，QQ以外的请自行查询对应邮件服务商的获取方式，以QQ邮箱为例（需要获取QQ邮箱独立密码）： 登陆QQ邮箱，点击「设置」→「账户」，下滑至「POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务」，开启「POP3/SMTP」和「IMAP/SMTP」服务，如图所示： 点击上图中的「生成授权码」，根据提示发送手机短信，完成后将生成16位字符的授权码，出于安全考虑，该授权码仅显示一次。 将授权码填入环境变量SMTP_PASS字段。 SMTP_SERVICE：邮件服务提供商，一般都是使用QQ邮箱，其他常用邮箱类型（如126，163，Gmail，Hotmail，Outlook365及Yahoo等）操作类似，可用选项参考Supported services。 TEMPLATE_NAME：评论提醒邮件的主题模板，可选值有default，rainbow（效果如图），custom1，custom2，简洁风可直接使用default或rainbow，若使用后两者，可能还需要设置附加环境变量，具体参考部署valine-admin。 2.6.重新部署环境变量设置完成后需要重新部署实例，使其生效。注意：由于每个人的需求不同，配置时务必弄清楚各变量的含义。注意：每次修改或添加环境变量后，都需要重启/重新部署实例，否则配置不生效。 2.7.初始化后台管理注意：如果你没有设置后台域名（即上文2.3.绑定评论管理的域名设置的域名），那么也可以跳过这一步。 初始化设置登陆信息，打开https://domain/sign-up，其中domain为绑定的后台管理的域名，例如使用「国际版」赠送的域名https://hwame.avosapps.us/，那么我访问的地址就是 https://hwame.avosapps.us/sign-up。 后台登陆设置登陆信息后就可以用登录名登录了，登陆后台直接使用https://hwame.avosapps.us/即可，若使用https://hwame.avosapps.us/sign-up可能会有bug。 2.8.基本配置完成到这里基本上完成了valine-admin的基本设置。 3.防止服务器休眠3.1.创建定时任务经过上述设置，基本上能满足我们的日常要求。 此部分参考：①Valine评论系统详解之防止服务器休眠②Valine-admin配置攻略之防止服务器休眠 目前最新版的Valine Admin已经可以实现自唤醒，即在 LeanCloud 云引擎中定时请求 Web 应用地址防止休眠。对于夜间休眠期漏发的邮件通知，自动在次日早上补发。注意：务必确保配置中设置了ADMIN_URL环境变量，并需要添加以下两个云函数定时任务。 目前实现了两种云函数定时任务：(1) 自动唤醒，定时访问 Web APP 二级域名防止云引擎休眠；(2) 每天定时检查 24 小时内漏发的邮件通知。 进入「云引擎」→「定时任务」中，创建定时器，创建两个定时任务。 选择self-wake云函数，Cron表达式为0 0/20 7-23 * * ?，表示每天早上 7 点到晚上 23:59 点每隔 20 分钟访问云引擎。编辑后会有提示Every 20 minutes, between 07:00 AM and 11:59 PM，如图所示： 选择resend-mails云函数，Cron表达式为0 59 7 * * *，表示每天早上 8 点检查过去 24 小时内漏发的通知邮件并补发。编辑后会有提示At 07:59 AM，如图所示： 设置完成后，就是如下两个函数，如图所示： ✉ 注意：我们在创建定时任务时的时间和提示时间（即下图「运行周期」）都是基于「零时区」，而下图的「下次执行时间」才是基于本地时区「东八区」。可以看到，邮件重发检查设置的是「早上8点」但执行时间是「下午16点」。 3.2.国际版时区问题按LeanCloud官方文档之CRON表达式最后备注的说法：Cron 表达式的时区为东八区（国内版）、UTC 零时区（国际版）。因此，我们使用的「国际版」设置的定时任务和国内时区不匹配，应减去8小时（时区转换参考百度百科-东八区）。 3.3.服务器设置自动唤醒云函数定时任务时区其实是小问题，因为「唤醒服务器」基本上用不了，而「邮件重发」任何时间都可以。所以上述定时任务的Cron表达式也可以不需要修改，且需停止「唤醒服务器」，如图所示是我停止了自动唤醒且修改了邮件重发： 查看日志发现唤醒失败：因流控原因，通过定时任务唤醒体验版实例失败，建议升级至标准版云引擎实例避免休眠，参考《Valine-admin配置攻略之防止服务器休眠》、《优雅解决LeanCloud流控问题之其他解决方案（方案二）》及《Hexo 优化—-支持邮件通知的评论Valine增强版之LeanCloud休眠策略》等文章，在我自己的服务器上利用crontab创建了定时任务：1234567891011[root@aliyun ~]# crontab -e0 0/20 7-23 * * ? curl https://hwame.avosapps.us~~&quot;/tmp/crontab.OOI2Ka&quot; 1L, 49C writtencrontab: installing new crontab&quot;/tmp/crontab.OOI2Ka&quot;:1: bad hourerrors in crontab file, can&#x27;t install.Do you want to retry the same edit? y*/20 7-23 * * * curl https://hwame.avosapps.us~注意：此crontab不是LeanCloud后台的定时任务，命令有所区别，如果按云函数的配置0 0/20 7-23 * * ?则会报错：errors in crontab file, can&#39;t install；因此按赵俊的配置*/20 7-23 * * * curl https://hwame.avosapps.us，其中URL为评论系统后台管理地址（环境变量中的ADMIN_URL，例如https://hwame.avosapps.us），如图所示： 3.4.生产环境运行效果生产环境下，「防止服务器休眠」及「定时检查漏发邮件」的运行效果如图所示： web1是在阿里云服务器设置的crontab curl，每天早上 7 点到晚上 23:59 点每隔 20 分钟访问云引擎； system是LeanCloud的定时任务云函数resend-mails，每天早上 8 点检查昨日漏发的通知邮件并补发。 4.评论系统设置必填项4.1.问题描述上文花费大量篇幅设置了「邮件提醒」功能，但是如果人家没有添加自己的邮箱呢？那岂不是我辛苦回复了，也无法联系到对方啊！所以需要给评论系统的邮箱字段增加必填的功能。既然添加必填项要涉及到修改源码，干脆一次性改好，包括上文1.前言提到的拉取QQ头像功能。所以问题总共有如下几个： 设置必填项requiredFields； 自动拉取QQ头像enableQQ； 昵称长度小于3的问题。 4.2.源码分析文件位于./themes/pure/layout/_script/_comment/valine.ejs，源码文件内容见github。可见，在verify和notify已被弃用的情况下，除了必需的appId和appKey以外，pure主题实际只设置了meta、placeholder、avatar、pageSize、visitor这5个自定义字段。然而，Valine实际是提供了这些的，详见valine配置项，我们可以仿照valine.ejs中的代码并结合Valine支持的配置项进行添加： 字符串/true/false类型：直接以theme.comment.valine.FIELD的方式获取； 列表类型：仿照meta以「,」分割：1234567var FIELD = &#x27;&lt;%= theme.comment.valine.FIELD %&gt;&#x27;;FIELD = FIELD.split(&#x27;,&#x27;);new Valine(&#123; ... FIELD: FIELD,&#125;); 4.3.修改源码及主题配置文件Valine提供了众多配置项，但并不都是我们所需要的，除去上文4.2.源码分析提到的已配置的项，我们还需要配置（按./themes/pure/_config.yml文件的配置顺序）： enableQQ：enableQQ: &#39;&lt;%= theme.comment.valine.enableQQ %&gt;&#39;, recordIP：recordIP: &#39;&lt;%= theme.comment.valine.recordIP %&gt;&#39;, requiredFields：12345var requiredFields = &#x27;&lt;%= theme.comment.valine.requiredFields %&gt;&#x27;;requiredFields = requiredFields.split(&#x27;,&#x27;);new Valine(&#123; requiredFields: requiredFields,&#125;); 上述三项已在前文Hexo博客搭建(2)——主题配置之评论系统中配置。另外可能会需要的就是emoji表情了，这里我们不需要这些花里胡哨的，可参考valine自定义表情自行配置（注意：emojiCDN和emojiMaps需要同时设置且需对应）。 4.4.昵称长度的问题最开始是希望设置必填项为「昵称」和「邮箱」两项，且直接写在ejs文件里，测试时发现昵称长度必须大于3，查看引入的js源文件，代码如下（可Ctrl＋F查找定位）：12if(e.config.requiredFields.indexOf(&quot;nick&quot;) &gt; -1 &amp;&amp; E.nick.length &lt; 3) return v.nick[0].focus(), void e.$el.find(&quot;.status-bar&quot;).text(&quot;&quot; + e.i18n.t(&quot;nickFail&quot;)).empty(3e3);逻辑很简单，直接将判断条件中的昵称长度改为E.nick.length &lt; 1即可，亦即昵称非空。但是就还需要将该js文件放到本地，然后引入。所以我这里妥协了一下，只让必填项为「邮箱」，昵称默认是「Anonymous」。主题配置文件的配置参考前文Hexo博客搭建(2)——主题配置之评论系统。 4.5.修改后内容修改后完整内容如下：1234567891011121314151617181920212223242526272829&lt;% if (typeof(script) !== &#x27;undefined&#x27; &amp;&amp; script) &#123; %&gt; &lt;script src=&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//cdn.jsdelivr.net/npm/valine&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var GUEST = [&#x27;nick&#x27;, &#x27;mail&#x27;, &#x27;link&#x27;]; var meta = &#x27;&lt;%= theme.comment.valine.meta %&gt;&#x27;; meta = meta.split(&#x27;,&#x27;).filter(function(item) &#123; return GUEST.indexOf(item) &gt; -1; &#125;); var requiredFields = &#x27;&lt;%= theme.comment.valine.requiredFields %&gt;&#x27;; requiredFields = requiredFields.split(&#x27;,&#x27;); new Valine(&#123; el: &#x27;#vcomments&#x27;, appId: &#x27;&lt;%= theme.comment.valine.appid %&gt;&#x27;, appKey: &#x27;&lt;%= theme.comment.valine.appkey %&gt;&#x27;, verify: &lt;%= theme.comment.valine.verify %&gt;, notify: &lt;%= theme.comment.valine.notify %&gt;, placeholder: &#x27;&lt;%= theme.comment.valine.placeholder %&gt;&#x27;, avatar: &#x27;&lt;%= theme.comment.valine.avatar %&gt;&#x27;, meta: meta, pageSize: &#x27;&lt;%= theme.comment.valine.pageSize %&gt;&#x27; || 10, enableQQ: &#x27;&lt;%= theme.comment.valine.enableQQ %&gt;&#x27;, recordIP: &#x27;&lt;%= theme.comment.valine.recordIP %&gt;&#x27;, requiredFields: requiredFields, visitor: &lt;%= theme.comment.valine.visitor %&gt; &#125;); &lt;/script&gt;&lt;% &#125; %&gt; 5.添加身份标签5.1.前言 此部分主要参考以下文章： 【HCLonly】Valine添加标签及图标 【HCLonly】Hexo博客美化之valine评论添加博主等标签(仅Butterfly主题)) 【初辰の揽月】Valine添加标签及图标 说明：由于网上关于「添加博主标签」都是基于butterfly主题的，而我使用的是pure主题，因此配置方面有较大差别，并且无法显示操作系统和浏览器图标。 5.2.修改和配置样式文件为./themes/pure/layout/_script/_comment/valine.ejs，主题配置文件为./themes/pure/_config.yml。 pure主题关于valine只有上面一个文件，js文件是以&lt;script src=&quot;//xxx.js&quot;&gt;&lt;/script&gt;的形式引入的，原本已引入两个js文件，为了能显示身份标签还需引入https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js：123&lt;script src=&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;//cdn.jsdelivr.net/npm/valine&quot;&gt;&lt;/script&gt;&lt;script src=&quot;//cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js&quot;&gt;&lt;/script&gt;由于Butterfly主题使用.pug格式的样式文件，而Pure主题使用.ejs格式的样式文件，两者从主题配置文件获取配置参数的方式不一致：1234567// Butterfly主题valine.pugwindow.valine = new Valine(&#123; FIELD: &#x27;#&#123;theme.valine.FIELD&#125;&#x27;,// Pure主题valine.ejsnew Valine(&#123; FIELD: &#x27;&lt;%= theme.comment.valine.FIELD %&gt;&#x27;,因此，我们将这部分需要增加的字段不通过.yml文件而是直接写入.ejs文件中。 新引入的js文件与原版相比： 添加博主，小伙伴，访客标签（可自定义）； 添加浏览器和操作系统图标，需fontawesomeV5支持； 邮箱检测更严格； 增强QQ邮箱识别（原版只能通过昵称栏输入QQ号识别）； meta placeholder可自定义。 注意：由于此处有三个js文件共存，参数默认值可能与参考文章里的不一致，这里仅针对我修改的Pure主题。可添加的参数： 参数 类型 说明 默认值 master List/Str 加密的博主邮箱 [] friends List 加密的小伙伴邮箱 [] tagMeta List 身份标签 [&quot;博主&quot;,&quot;小伙伴&quot;,&quot;访客&quot;] metaPlaceholder Dict 自定义占位符 &#123;&quot;nick&quot;:&quot;昵称/QQ号(必填)&quot;,&quot;mail&quot;:&quot;邮箱(必填)&quot;,&quot;link&quot;:&quot;网址(https://)&quot;&#125; verify Bool 评论是否需要验证 false 参数进一步说明及示例参考： master：md5加密后的博主邮箱，32位长度的字符，邮箱加密可以点击MD5在线加密。示例：[&#39;f86269b0b1850cd62ca22b218aea1780&#39;]或&#39;f86269b0b1850cd62ca22b218aea1780&#39;。 friends：md5加密后的小伙伴邮箱，32位长度的字符。示例：[&#39;1725648a3566b8841f19423519e0a36e&#39;, &#39;87b6f0e96e63727d889bb3653fb5867c&#39;]。 tagMeta：显示的身份标签，自定义名称时需要保证数组顺序对应，顺序及颜色依次为「博主」、「小伙伴」和「访客」。示例：[&#39;鴻塵&#39;, &#39;蜜柚&#39;, &#39;访客&#39;]。 metaPlaceholder：原版默认值为&#123;&quot;nick&quot;:&quot;昵称&quot;,&quot;mail&quot;:&quot;邮箱&quot;,&quot;link&quot;:&quot;网址(http://)&quot;&#125;并且不支持自定义，新引入的js文件默认值如上表且支持修改。示例：&#123;&quot;nick&quot;:&quot;昵称/QQ号&quot;,&quot;mail&quot;:&quot;邮箱(必填)&quot;,&quot;link&quot;:&quot;个人主页&quot;&#125;。 verify：此选项在官方文档Valine配置项之verify中已废弃，并且用处不大，因此不予配置。 配置完成后的valine.ejs文件只需要在上文4.5节评论系统设置必填项之修改后内容的基础上添加js应用及参数：12345678&lt;script src=&quot;//cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js&quot;&gt;&lt;/script&gt;new Valine(&#123; master: &#x27;f86269b0b1850cd62ca22b218aea1780&#x27;, friends: [&#x27;1725648a3566b8841f19423519e0a36e&#x27;, &#x27;87b6f0e96e63727d889bb3653fb5867c&#x27;], tagMeta: [&#x27;鴻塵&#x27;, &#x27;蜜柚&#x27;, &#x27;访客&#x27;], metaPlaceholder: &#123;&quot;nick&quot;:&quot;昵称/QQ号&quot;,&quot;mail&quot;:&quot;邮箱(必填)&quot;,&quot;link&quot;:&quot;个人主页&quot;&#125; &#125;); 5.3.关于昵称长度的说明正如上文提到的： 原版获取QQ头像是需要在昵称栏输入QQ号，然后生成QQ邮箱，以此匹配头像并将输入的QQ号转换为QQ昵称。如果再修改了昵称，是不会匹配到正确的QQ头像的。新版增强了QQ邮箱识别，QQ头像只根据邮箱匹配，即使修改了昵称也能正确匹配头像。 Butterfly主题设置的是「昵称」必填，这会导致其长度必须大于等于3，虽然现在修改昵称长度也不会丢失头像，但我们是有三种js共存的！而且上文也取消了「昵称」必填的限制，所以这个问题不需要考虑。 评论测试如下，支持匿名和任意长度，符合我们的预期（因为此邮箱不是QQ邮箱，所以是系统头像）： 5.4.fontawesomeV5支持Butterfly主题天然支持fontawesomeV5而Pure主题不支持，因此无法显示「浏览器」和「操作系统」的图标，如图所示： 图标是否显示并没有太大区别，因此是否对Pure主题添加fontawesomeV5支持都无所谓。如果有需要，可以参考以下内容进行配置： Melody主题配置之社交图标，介绍了font-awesome相关知识和Hexo-theme-melody主题的图标配置，可以参考。 fontawesome-free CDN Files，这是解决办法需要用到的css链接，感谢HCLonely大佬的指点，才使得Pure主题完美支持。 解决办法：在样式文件./themes/pure/layout/_script/_comment/valine.ejs中引入外部CSS样式即可，all.css或all.min.css皆可：1234&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css&quot; /&gt;PS: 最开始把CSS当做js引入了，结果查错半天，像这种：&lt;script src=&quot;//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css&quot;&gt;&lt;/script&gt;但是仍然无法识别Mac OS、QQ浏览器、夸克浏览器、微信等，这个问题是font-awesome自身的问题。 修改完后的效果见评论区。 6.美化评论区样式此部分内容参考moyu的文章为博客添加一些小功能以及美化之美化基于valine的评论系统。 修改./themes/pure/source/css/style.css，可以添加如下三个部分： 添加评论框背景，编辑评论时自动隐藏； 评论及对应的回复采用了卡片式设计，鼠标经过时的阴影； 鼠标悬停于头像时，添加头像旋转。 将需要的部分直接在文件末尾加上：1234567891011121314151617181920212223242526272829303132333435363738394041/* 评论框背景及隐藏 */#veditor &#123; background-image: url(https://cdn.jsdelivr.net/gh/drew233/cdn/20200409110727.webp); background-size: contain; background-repeat: no-repeat; background-position: right; background-color: rgba(255, 255, 255, 0); resize: vertical;&#125;#veditor:focus&#123; background-position-y: 200px; transition: all 0.2s ease-in-out 0s;&#125;/* 评论及回复添加边框 */#vcomments .vcards .vcard &#123; padding: 15px 20px 0 20px; border-radius: 10px; margin-bottom: 15px; box-shadow: 0 0 4px 1px rgba(0, 0, 0, .12); transition: all .3s&#125;#vcomments .vcards .vcard:hover &#123; box-shadow: 0 0 8px 3px rgba(0, 0, 0, .12)&#125;#vcomments .vcards .vcard .vh .vcard &#123; border: none; box-shadow: none;&#125;/* 评论头像旋转 */img.vimg &#123; transition: all 1s&#125;img.vimg:hover &#123; transform: rotate(360deg); -webkit-transform: rotate(360deg); -moz-transform: rotate(360deg); -o-transform: rotate(360deg); -ms-transform: rotate(360deg);&#125;本站采用了后两项，效果见评论区。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://hwame.top/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://hwame.top/tags/Hexo/"}]},{"title":"Hexo博客搭建(2)——主题配置","slug":"hello-hexo-configuration","date":"2020-05-20T03:11:11.000Z","updated":"2020-05-22T00:23:15.000Z","comments":true,"path":"20200520/hello-hexo-configuration.html","link":"","permalink":"https://hwame.top/20200520/hello-hexo-configuration.html","excerpt":"摘要：博客搭建完成后，对其进行个性化配置，由于pure主题教程偏少且文档过于简洁，因此详细记录下来。","text":"摘要：博客搭建完成后，对其进行个性化配置，由于pure主题教程偏少且文档过于简洁，因此详细记录下来。 Hexo博客搭建博客系列：Hexo博客搭建(1)——建站及部署，环境搭建并部署至Github。博客系列：Hexo博客搭建(2)——主题配置，针对pure主题进行个性化配置。博客系列：Hexo博客搭建(3)——优化评论系统，主要对Valine评论系统进行优化。博客系列：Hexo博客搭建(4)——常见问题，修复了pure主题的系列小bug。文章作者：鴻塵 一、前言1.背景本博客使用的hexo-pure主题——hexo-theme-pure，由于该主题较为小众，使用人数不多，难以找到靠谱的参考文章，且不论是中文文档、英文文档，还是Hexo博客主题pure使用说明，都不够详细，实际动手过程中仍有许多问题。因此，将该主题的配置过程详细地记录下来。说明：主题配置大部分仍然是参考上述文档。 2.配置说明在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。为了描述方便，在以下说明中，将前者称为站点配置文件（./_config.yml）， 后者称为主题配置文件（./themes/pure/_config.yml）。 二、安装启用主题首先在博客根目录下运行以下命令：123git clone https://github.com/cofess/hexo-theme-pure.git themes/purecd ./themes/puregit pull 然后打开站点配置文件，找到theme字段，将其值更改为pure即可。到此，主题安装完成。然后启动Hexo服务验证主题是否正确启用。1hexo s 三、主题配置1.设置语言打开站点配置文件, 将language设置成你所需要的语言。建议明确设置你所需要的语言,可选值对应themes\\pure\\languages目录下语言文件，简体中文配置如下：1language: zh-CN 2.导航菜单menu和menu_icons默认即可，其中menu为页面左侧导航菜单，menu_icons为导航菜单图标，若需更改，参考这里。rss订阅用不上直接设置false即可~ 3.站点信息此部分只需要关注网站logo头像favicon的图片路径，将需要使用的logo图片放在./themes/pure/source/favicon.png，然后设置为favicon: /favicon.png即可。站点公告可用HTML格式，例如&lt;br&gt;换行、&lt;a href=&quot;xxx&quot; styly=&quot;xxx&quot;&gt;标签等进行配置。 4.主题个性配置 config：此部分对照注释配置即可。 pagination：分页设置，默认即可。 sidebar：右侧，默认即可。 widgets：右侧边栏小部件，根据需要展示，不需要注释掉即可。 index_widgets：默认注释掉，不知道是什么，取消注释也没反应。 fancybox：实现点击图片放大的部件，默认关闭，打开后会导致友链打不开（解决办法参考后文Hexo博客搭建(4)——常见问题之如何实现点击图片放大）。 search：分为站内搜索insight和百度搜索baidu，两者至多开启一个。站内搜索需要先安装hexo-generator-json-content插件，百度搜索则需要先被百度收录。 donate：打赏功能只需要将./themes/pure/source/images/donate/xxx.jpg替换为自己的。 share：*sites属性值为英文逗号分隔且无空格。 github：填写Github用户名，以正确获取仓库信息及Github主页。 5.评论系统博客采用Valine评论系统，此部分配置较为繁琐，此处配置仅针对主题配置文件的配置项，详细配置及源码修改分布详见后文Hexo博客搭建(3)——优化评论系统。以下配置中的enableQQ和requiredFields设置了也不会生效，因为评论样式文件./themes/pure/layout/_script/_comment/valine.js并没有包含这两个部分，所以需要修改源码。相关说明： valine：需要先将type设置为valine，表示启用Valine评论系统 appid和appkey：leancloud应用的专属appid和appkey，leancloud应用如图： notify和verify：该选项已被弃用 placeholder：评论框占位符，可自定义，换行符为\\n avatar：评论头像，参考valine配置项之avatar和valine头像配置 meta：评论框表头，默认显示「昵称」、「邮箱」、「网址」 pageSize：评论区分页 visitor：leancloud自带的文章阅读量统计（站长可随意修改），若开启则需关闭「不蒜子」，否则会显示两个阅读量，如图所示： enableQQ：是否启用昵称框自动获取QQ昵称和QQ头像, 默认关闭，需站长主动启用，启用后还需要修改源码 recordIP：是否记录访问者IP requiredFields：设置必填项，需要修改源码 123456789101112131415comment: type: valine valine: appid: ********************************* appkey: ************************ notify: true # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code（notify和verify已废弃） placeholder: 留下邮箱才可以收到新消息提醒哦~ avatar: robohash # gravatar style https://valine.js.org/configuration.html#avatar meta: nick,mail,link # custom comment header pageSize: 10 # pagination size visitor: true # Article reading statistic https://valine.js.org/visitor.html enableQQ: true recordIP: false requiredFields: [&#x27;mail&#x27;,] # Nick必填则需3+字符 6.其他 豆瓣书单：因为没有豆瓣的账号，此页面拟改为「相册」，因此此处关于「豆瓣」的全部注释掉了 pv：文章阅读量统计，由于Valine评论自带有阅读量统计，故此处busuanzi和leancloud直接设置为false禁用 postCount：文章字数及阅读时长统计，需要安装``插件 enable：启用postCount，设置为true wordcount：启用文章字数统计，设置为true min2read：启用阅读时长预计，设置为true plugins：插件，暂不需要，可根据自身实际配置 Miscellaneous：杂项（包括twitter，Google+，Facebook），暂不需要，可根据自身实际配置 7.个人信息profile此处配置主要是在页面左侧个人信息，以及「关于」页面右侧边栏的展示。labels、skills、links、works和projects显示在「关于」页面右侧边栏，配置格式为键值对形式，参考模板即可。 enabled：是否启用 avatar：个人头像，替换./themes/pure/source/images/avatar.jpg即可，路径设置为images/avatar.jpg gravatar：gravatar头像，属性值为Gravatar账户邮箱地址，将会覆盖上面的avatar配置 author：昵称 author_title：略（当做职业描述了…） author_description：个人简介 location：位置 follow：关注我的主页 social：社交平台链接，以图标形式显示在各页面的左下方 links：各个社交平台的连接可选值参考IconFont图标，一般有「Github」、「微博」、「twitter」、「facebook」、「知乎」、「领英」、「花瓣」、「思否」、「码云」、「QQ/空间」、「邮箱」、「掘金」、「微信」、「stackoverflow」、「支付宝」等，一般展示以4~6个为宜，参考后文Hexo博客搭建(4)——常见问题之如何更改左侧IconFont 图标 link_tooltip：建议设置为true labels：个人标签，显示在「关于」页面右侧边栏 skills：技能，显示在「关于」页面右侧边栏 links：个人链接，显示在「关于」页面右侧边栏 works：个人作品，显示在「关于」页面右侧边栏 projects：个人项目，显示在「关于」页面右侧边栏 四、站点配置站点配置参考：官方文档配置 1.网站 title：网站标题 subtitle：网站副标题 description：描述 keywords：关键字 author：作者 language：站点语言，第三步已配置 timezone：时区，默认即可 2.网址 url：主页URL，例如https://hwame.top root：网站根路径，需与url对应，如果站点位于子目录，则url为http://yoursite.com/child且同时设置root为/child permalink：文章链接，个人认为以日期为路由分隔即可：:year:month:day/:title.html，此项默认值为:year/:month/:day/:title/ permalink_defaults：各部分的默认值，留空即可 pretty_urls：如果设置为false则会去掉尾部的index.html或.html 3.目录/文章默认即可，或者参考官方文档配置 4.首页分页首页分页index_generator有一个小bug，即当最后一页只有一篇文章时，会直接打开那篇文章（如果设置了Read More，则显示到「摘要」），这个问题还未解决。 path：主页的路径，默认为&#39;&#39; per_page：每页展示数量，设置为0则禁用分页 order_by：默认按时间倒序排序 5.其他 Category &amp; Tag：默认分类default_category的默认值为uncategorized，pure主题已改为categories，其他默认即可。 Metadata elements：meta_generator不知道是什么，默认即可。 Date / Time format：日期时间格式默认即可。 6.归档分页此处配置为「归档」的分页，不同于「首页」的分页 per_page：每页显示的文章数量 ，默认值为10，设置为0则表示关闭分页功能 pagination_dir：分页目录，保持为默认值page即可 7.扩展 Include / Exclude file(s)：包括或不包括目录和文件，include/exclude仅应用于source/目录，而ignore将应用于所有目录。一般默认即可。 theme：应用的主题，第二部分已设置为pure。 Deployment：部署部分详见前文Hexo博客搭建(1)——建站及部署之部署Hexo。此处有个小问题，如果按之前配置：repository: https://github.com/username/username.github.io.git，则会有时候需要手动输入Github用户名密码，更好的方式是配置为repository: git@github.com:username/username.github.io.git，参考后文Hexo博客搭建(4)——常见问题之免密部署问题。 mathjax：数学公式支持。pure主题默认不支持mathjax，此处开启该选项，具体配置见后文Hexo博客搭建(4)——常见问题之如何使其支持Mathjax。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://hwame.top/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://hwame.top/tags/Hexo/"}]},{"title":"Hexo博客搭建(1)——建站及部署","slug":"hello-hexo-setup-deploy","date":"2020-05-19T21:20:52.000Z","updated":"2020-05-21T05:14:00.000Z","comments":true,"path":"20200520/hello-hexo-setup-deploy.html","link":"","permalink":"https://hwame.top/20200520/hello-hexo-setup-deploy.html","excerpt":"摘要：从零开始搭建Hexo博客，包括环境安装、建站写作和部署。","text":"摘要：从零开始搭建Hexo博客，包括环境安装、建站写作和部署。 Hexo博客搭建博客系列：Hexo博客搭建(1)——建站及部署，环境搭建并部署至Github。博客系列：Hexo博客搭建(2)——主题配置，针对pure主题进行个性化配置。博客系列：Hexo博客搭建(3)——优化评论系统，主要对Valine评论系统进行优化。博客系列：Hexo博客搭建(4)——常见问题，修复了pure主题的系列小bug。文章作者：鴻塵 1.开篇词1.1.背景很早就有搭建个人博客的想法，因为在平时的学习过程中难免遇到各种问题，记录遇到的问题也是提高自己的一种方式，并且互联网精神就在于分享和交流。由于疫情影响而无法开学，因此就更加坚定了这个想法。更让人惊喜的是，偶然得知了《阿里云高校师生计划》，可以白嫖一台服务器，可以免费使用1年： 阿里云配置为：2核，4G，1M带宽，外加40G硬盘我自己的虚拟机配置为：单核，2G，20G硬盘虽然配置不高，但是比我的虚拟机强多了，最关键的是有公网IP！ 我在5月14日申请到了服务器，前后花了几天时间包括安装系统、数据库、Nginx等，以及Node.js、Hexo等，架设好了完整的服务器。并且根据 B站教程 以Nginx部署了一个《国内疫情实时监测》的小项目，目前仍在稳定运行。 1.2.说明 本着“能不装就不装、能少装就少装”的原则，打造一个既能满足使用要求又精简轻量的个人博客 拒绝一切花里胡哨的东西，包括且不限于添加卡通人物，背景图片及特效，鼠标点击特效，页面特效，背景音乐，鸡肋挂件…… 2.安装步骤2.1.安装Node.js和Git我最开始是在Linux下搭建的，由于白嫖来的阿里云服务器配置比较低，并且上面已有多个项目运行，因此后面将其重新迁移到Windows并部署到Github。安装参考【官方中文文档】注意：Node.js版本需不低于 10.13，建议使用Node.js 12.0+版本；注意：Windows下需要注意设置环境变量，完成后重启命令行，否则会看到「&#39;xxxx&#39; 不是内部或外部命令，也不是可运行的程序或批处理文件」的报错（但实际上很可能已经安装好了）。 2.2.安装Hexo在Node.js和Git安装完成之后即可安装Hexo了，因为Hexo是以npm方式安装，所以没有操作系统的区别了。使用 npm 安装 Hexo的两种方式二选一即可：12$ npm install -g hexo-cli #完整版Hexo$ npm install hexo #精简版Hexo说明：推荐安装完整版，可直接使用hexo [command]；如果是精简版Hexo，则所有hexo相关命令都需要加上npx，即npx hexo [command]；说明：Linux一般自带有Git，无需安装。 3.建站3.1.初始化博客文件参考【官方中文文档】安装 Hexo 完成后，进入指定文件夹，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。例如我想在G:盘根目录创建名为blog的博客文件夹（注意blog文件夹不需要手动创建，会在init时自动创建），则：12345678$ G:# 当前路径为&quot;G:\\&quot;$ hexo init blog# 等待完成$ cd blog# 当前路径为&quot;G:\\blog&quot;$ npm install# 等待完成新建完成后，指定文件夹的目录如下：12345678.+-- _config.yml+-- package.json+-- scaffolds+-- source| +-- _drafts| +-- _posts+-- themes 3.2.文件说明 _config.yml，网站的配置信息，可以在此配置大部分的参数。注意：此文件称为站点配置文件，主题文件夹下也有个同名文件称为主题配置文件。 package.json，安装的应用程序的信息，如EJS、Stylus 和 Markdown renderer，可以根据需要自由添加和卸载。 scaffolds，模版文件夹，是指在新建的md文件中默认填充的内容。在每次新建文章或页面时，Hexo会根据scaffolds来建立文件。文章对应于scaffolds/post.md，页面对应于scaffolds/page.md。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source，资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件（夹）和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes，主题文件夹，这是下载的主题存放的位置，默认只有landscape主题。 3.3.启动服务器输入下列命令打开hexo的服务，在浏览器输入http://localhost:4000就可以看到生成的博客了。注意：如果Hexo安装的是精简版，则应输入npx hexo command；注意：连续命令以此执行，可以使用&amp;&amp;连接，如下所示；注意：服务默认端口为4000，若因端口占用等问题需要修改则添加相关参数，如hexo server -p 6666。命令详细用法及参数参考【官方中文文档】。 12345$ hexo generate #可简写为hexo g$ hexo server #可简写为hexo s# 可将上述命令合并$ hexo g &amp;&amp; hexo s 3.4.停止服务以hexo server方式启动的服务只能用于测试和调试，可以实时看到修改的效果，所以直接Ctrl + C即可停止服务。 4.开始写作4.1.创建第一篇文章你可以执行下列命令来创建一篇新文章（[option]表示可选参数）。注意：默认布局为post，新建文章时无需指定layout，新建页面时则需要显式地指定为page；注意：标题最好不要有空格，否则生成的md文件名将只包含一个单词，不利于理解和维护；参考：官方中文文档写作。12$ hexo new [layout] &quot;My New Post&quot; #不推荐标题含空格$ hexo new [layout] &quot;My-New-Post&quot; #推荐以分割线分隔标题 4.2.运行服务重新启动服务即可在浏览器中访问http://localhost:4000，如果服务已启动则只需要刷新页面。 5.部署到Github5.1.创建账户既然要使用GitHub的产品，那当然首先需要一个GitHub账户吧。注册地址：GitHub，全英文界面。 5.2.创建个人仓库注册登录后，在Repositories仓库选项卡中，新建一个仓库，如图所示：注意：仓库名称必须为&lt;username&gt;.github.io，其中username是GitHub的用户名即图中Owner所对应的。 5.3.初始化git在命令行或git bash中运行如下命令，其中username为GitHub用户名，email为GitHub邮箱，并以引号引包裹。注意：若初次使用Git，应首先进入到博客文件夹运行git init，然后进行接下来的操作。 123456$ git config --global user.name &lt;username&gt;$ git config --global user.email &lt;email&gt;# 可以用以下两条命令检查是否输入正确$ git config user.name$ git config user.email 5.4.配置SSH密钥创建SSH密钥，输入如下命令，根据提示输入三次回车（email为GitHub邮箱）：1ssh-keygen -t rsa -C &lt;email&gt;完成后会生成一幅圈圈星星图，这个时候就已经生成了.ssh的文件夹，文件一般位于用户文件夹下，即C:\\Users\\&lt;Administrator&gt;\\.ssh，其中&lt;Administrator&gt;为Windows用户名。文件夹内容如下： id_rsa，私钥。 id_rsa.pub，公钥。 known_hosts，顾名思义，此文件保存着其他主机远程登陆本机的信息。 先将公钥文件id_rsa.pub以记事本方式打开，复制全部信息到剪切板。 然后在GitHub主页的设置Settings（不是仓库的设置）中，页面左侧找到SSH and GPG keys的设置选项，点击右上角New SSH key，把复制的id_rsa.pub内容粘贴到Key中，写个标题，点击Add SSH key即可。 回到命令行输入如下命令，查看是否成功：123$ ssh -T git@github.com# 最后一行输出如下信息即为成功# Hi hwame! You&#x27;ve successfully authenticated... 5.5.部署Hexo要将hexo生成的文章部署到GitHub上，首先要编辑站点配置文件，将hexo和GitHub关联起来，其中username为GitHub用户名。在博客文件夹里，修改站点配置文件_config.yml，在文件最后加上（已有则修改）：123456deploy: type: git repository: https://github.com/username/username.github.io.git branch: master message: [description] #此行可省略 # message为自定义提交信息，默认为Site updated: YYYY-MM-DD HH:mm:ss 注意：需要先安装Git部署插件，才能用命令部署到GitHub，输入以下命令安装hexo-deployer-git插件。1$ npm install hexo-deployer-git --save 插件安装完成后，输入以下命令进行部署：注意：部署时强烈建议先hexo clean，因为有时候当你修改后发现无法生效，那么原因可能就是因为缓存文件（db.json）和静态文件（public）的问题。注意：部署时可能需要输入用户名和密码，也可能不需要。更新：此问题参考后文Hexo博客搭建(4)——常见问题之免密部署问题。 123456$ hexo clean #清除缓存和已生成的静态文件$ hexo generate #等于hexo g$ hexo deploy #等于hexo d# 可将上述命令合并为“一键三连”$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 当控制台输出下面信息时，则表明部署成功，浏览器中访问https://&lt;username&gt;.github.io即可看到你的博客了！！1234INFO Deploy done: git# 由于Windows字体问题，也可能是这种（问题不大）：←[32mINFO ←[39m Deploy done: ←[35mgit←[39m 6.结语至此，Hexo博客就基本完成了，该有的功能都可以使用。但是页面个性化不够、自定义程度不高，博客的优化及完善留作后篇。 博客系列：Hexo博客搭建(1)——建站及部署，环境搭建并部署至Github。 博客系列：Hexo博客搭建(2)——主题配置，针对pure主题进行个性化配置。 博客系列：Hexo博客搭建(3)——优化评论系统，主要对Valine评论系统进行优化。 博客系列：Hexo博客搭建(4)——常见问题，修复了pure主题的系列小bug。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://hwame.top/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://hwame.top/tags/Hexo/"}]}],"categories":[{"name":"Go","slug":"Go","permalink":"https://hwame.top/categories/Go/"},{"name":"miscellanea","slug":"miscellanea","permalink":"https://hwame.top/categories/miscellanea/"},{"name":"Linux","slug":"Linux","permalink":"https://hwame.top/categories/Linux/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://hwame.top/categories/MongoDB/"},{"name":"python","slug":"python","permalink":"https://hwame.top/categories/python/"},{"name":"Hexo","slug":"Hexo","permalink":"https://hwame.top/categories/Hexo/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://hwame.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://hwame.top/tags/Go/"},{"name":"miscellanea","slug":"miscellanea","permalink":"https://hwame.top/tags/miscellanea/"},{"name":"Linux","slug":"Linux","permalink":"https://hwame.top/tags/Linux/"},{"name":"shell","slug":"shell","permalink":"https://hwame.top/tags/shell/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://hwame.top/tags/MongoDB/"},{"name":"python","slug":"python","permalink":"https://hwame.top/tags/python/"},{"name":"Hexo","slug":"Hexo","permalink":"https://hwame.top/tags/Hexo/"},{"name":"matplotlib","slug":"matplotlib","permalink":"https://hwame.top/tags/matplotlib/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://hwame.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"爬虫","slug":"爬虫","permalink":"https://hwame.top/tags/%E7%88%AC%E8%99%AB/"},{"name":"CentOS","slug":"CentOS","permalink":"https://hwame.top/tags/CentOS/"},{"name":"Spark","slug":"Spark","permalink":"https://hwame.top/tags/Spark/"},{"name":"大数据","slug":"大数据","permalink":"https://hwame.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Linux部署","slug":"Linux部署","permalink":"https://hwame.top/tags/Linux%E9%83%A8%E7%BD%B2/"}]}